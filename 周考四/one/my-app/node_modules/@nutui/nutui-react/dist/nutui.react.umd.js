(function(global2, factory) {
  typeof exports === "object" && typeof module !== "undefined" ? factory(exports, require("react"), require("react-dom")) : typeof define === "function" && define.amd ? define(["exports", "react", "react-dom"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, factory(global2.nutui = {}, global2.React, global2.ReactDOM));
})(this, function(exports2, React, ReactDOM) {
  "use strict";/*!
* @nutui/nutui-react-taro v2.7.13 Thu Apr 03 2025 16:01:04 GMT+0800 (China Standard Time)
* (c) 2023 @jdf2e.
* Released under the MIT License.
*/

  function _interopNamespaceDefault(e) {
    const n2 = Object.create(null, { [Symbol.toStringTag]: { value: "Module" } });
    if (e) {
      for (const k in e) {
        if (k !== "default") {
          const d2 = Object.getOwnPropertyDescriptor(e, k);
          Object.defineProperty(n2, k, d2.get ? d2 : {
            enumerable: true,
            get: () => e[k]
          });
        }
      }
    }
    n2.default = e;
    return Object.freeze(n2);
  }
  const React__namespace = /* @__PURE__ */ _interopNamespaceDefault(React);
  const ReactDOM__namespace = /* @__PURE__ */ _interopNamespaceDefault(ReactDOM);
  var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
  function getDefaultExportFromCjs(x) {
    return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
  }
  var classnames = { exports: {} };
  /*!
  	Copyright (c) 2018 Jed Watson.
  	Licensed under the MIT License (MIT), see
  	http://jedwatson.github.io/classnames
  */
  (function(module2) {
    (function() {
      var hasOwn = {}.hasOwnProperty;
      function classNames2() {
        var classes = "";
        for (var i2 = 0; i2 < arguments.length; i2++) {
          var arg = arguments[i2];
          if (arg) {
            classes = appendClass(classes, parseValue(arg));
          }
        }
        return classes;
      }
      function parseValue(arg) {
        if (typeof arg === "string" || typeof arg === "number") {
          return arg;
        }
        if (typeof arg !== "object") {
          return "";
        }
        if (Array.isArray(arg)) {
          return classNames2.apply(null, arg);
        }
        if (arg.toString !== Object.prototype.toString && !arg.toString.toString().includes("[native code]")) {
          return arg.toString();
        }
        var classes = "";
        for (var key in arg) {
          if (hasOwn.call(arg, key) && arg[key]) {
            classes = appendClass(classes, key);
          }
        }
        return classes;
      }
      function appendClass(value, newClass) {
        if (!newClass) {
          return value;
        }
        if (value) {
          return value + " " + newClass;
        }
        return value + newClass;
      }
      if (module2.exports) {
        classNames2.default = classNames2;
        module2.exports = classNames2;
      } else {
        window.classNames = classNames2;
      }
    })();
  })(classnames);
  var classnamesExports = classnames.exports;
  const classNames = /* @__PURE__ */ getDefaultExportFromCjs(classnamesExports);
  const n$7 = {
    classPrefix: "nut-icon",
    tag: "i",
    fontClassName: "nutui-iconfont"
  };
  var Q = { exports: {} }, $ = {};
  /**
   * @license React
   * react-jsx-runtime.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  var Ce;
  function lr() {
    if (Ce)
      return $;
    Ce = 1;
    var F = React, E = Symbol.for("react.element"), D = Symbol.for("react.fragment"), _ = Object.prototype.hasOwnProperty, x = F.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, w = { key: true, ref: true, __self: true, __source: true };
    function C(m2, f, R) {
      var d2, h = {}, g = null, P = null;
      R !== void 0 && (g = "" + R), f.key !== void 0 && (g = "" + f.key), f.ref !== void 0 && (P = f.ref);
      for (d2 in f)
        _.call(f, d2) && !w.hasOwnProperty(d2) && (h[d2] = f[d2]);
      if (m2 && m2.defaultProps)
        for (d2 in f = m2.defaultProps, f)
          h[d2] === void 0 && (h[d2] = f[d2]);
      return { $$typeof: E, type: m2, key: g, ref: P, props: h, _owner: x.current };
    }
    return $.Fragment = D, $.jsx = C, $.jsxs = C, $;
  }
  Q.exports = lr();
  var ee = Q.exports;
  const fr = ee.Fragment, xe = ee.jsx, gr = ee.jsxs, dr = {
    className: "",
    style: void 0,
    viewBox: " 0 0 1024 1024",
    name: "",
    width: "",
    height: "",
    onClick: () => {
    }
  }, vr = (F) => {
    const E = n$7.classPrefix, { viewBox: D, className: _, style: x, name: w, color: C, width: m2, height: f, children: R, onClick: d2 } = { ...dr, ...F }, h = (s2) => {
      d2 && d2(s2);
    }, g = (s2) => s2 === "" ? "" : isNaN(Number(s2)) ? String(s2) : s2 + "px", P = () => `${E} ${E}-${w} ${_}`, S = {}, N = g(m2 || ""), Y = g(f || "");
    N && (S.width = N), Y && (S.height = Y);
    const T = () => ({
      ...x,
      ...S
    });
    return /* @__PURE__ */ xe(fr, { children: /* @__PURE__ */ xe(
      "svg",
      {
        className: P(),
        style: T(),
        onClick: h,
        xmlns: "http://www.w3.org/2000/svg",
        color: C,
        viewBox: D,
        "aria-labelledby": w,
        role: "presentation",
        children: R
      }
    ) });
  }, mr = vr;
  const i$9 = (a) => {
    const r = { ...dr, ...a };
    return /* @__PURE__ */ xe(mr, { ...r, name: r.name || "ArrowDown", viewBox: "0 0 1024 1024", children: /* @__PURE__ */ xe(
      "path",
      {
        d: "M158.17 289.83a42.67 42.67 0 1 0-60.34 60.34l384 384a42.67 42.67 0 0 0 60.36 0l384-384a42.67 42.67 0 1 0-60.36-60.34L512 643.67z",
        fill: "currentColor",
        fillOpacity: "0.9"
      }
    ) });
  };
  const n$6 = (o) => {
    const r = { ...dr, ...o };
    return /* @__PURE__ */ xe(mr, { ...r, name: r.name || "ArrowLeft", viewBox: "0 0 1024 1024", children: /* @__PURE__ */ xe(
      "path",
      {
        d: "M712.83 158.17a42.67 42.67 0 1 0-60.33-60.34l-384 384a42.67 42.67 0 0 0 0 60.36l384 384a42.67 42.67 0 1 0 60.33-60.36L359 512z",
        fill: "currentColor",
        fillOpacity: "0.9"
      }
    ) });
  };
  const i$8 = (o) => {
    const r = { ...dr, ...o };
    return /* @__PURE__ */ xe(mr, { ...r, name: r.name || "ArrowUp", viewBox: "0 0 1024 1024", children: /* @__PURE__ */ xe(
      "path",
      {
        d: "M158.17 734.17a42.67 42.67 0 1 1-60.34-60.34l384-384a42.67 42.67 0 0 1 60.36 0l384 384a42.67 42.67 0 1 1-60.36 60.34L512 380.33z",
        fill: "currentColor",
        fillOpacity: "0.9"
      }
    ) });
  };
  const p$5 = (o) => {
    const r = { ...dr, ...o };
    return /* @__PURE__ */ gr(mr, { ...r, name: r.name || "CheckChecked", viewBox: "0 0 1024 1024", children: [
      /* @__PURE__ */ xe(
        "path",
        {
          d: "M506.65 2.82C228.01 2.82.03 230.8.03 509.44s227.98 506.62 506.62 506.62 506.62-227.98 506.63-506.62S788.11 2.82 506.65 2.82m0 788.08c-154.8 0-281.46-126.66-281.45-281.46s126.66-281.46 281.45-281.46 281.46 126.66 281.46 281.46S661.45 790.9 506.65 790.9",
          fill: "currentColor",
          fillOpacity: "0.9"
        }
      ),
      ",",
      /* @__PURE__ */ xe(
        "path",
        {
          d: "M380 509.44a126.66 126.66 0 1 0 253.31 0 126.66 126.66 0 1 0-253.31 0",
          fill: "currentColor",
          fillOpacity: "0.9"
        }
      )
    ] });
  };
  const i$7 = (a) => {
    const r = { ...dr, ...a };
    return /* @__PURE__ */ xe(mr, { ...r, name: r.name || "CheckDisabled", viewBox: "0 0 1024 1024", children: /* @__PURE__ */ xe(
      "path",
      {
        d: "M506.47 0C227.97 0 .1 227.87.09 506.37s227.87 506.37 506.38 506.38 506.37-227.87 506.37-506.38S787.78 0 506.47 0m202.55 571.08H306.73c-45.01 0-67.52-22.51-67.52-67.52 0-45.01 22.5-67.52 67.52-67.52h402.29c45.01 0 67.52 22.5 67.51 67.52 0 45.01-22.5 67.52-67.51 67.52",
        fill: "currentColor",
        fillOpacity: "0.9"
      }
    ) });
  };
  const i$6 = (o) => {
    const r = { ...dr, ...o };
    return /* @__PURE__ */ xe(mr, { ...r, name: r.name || "CheckNormal", viewBox: "0 0 1024 1024", children: /* @__PURE__ */ xe(
      "path",
      {
        d: "M512 1024c-136.53 0-264.53-54.04-361.24-150.76C54.05 776.53 0 648.53 0 512s54.04-264.53 150.76-361.24C247.47 54.05 375.47 0 512 0s264.53 54.04 361.24 150.76C969.95 247.47 1024 375.47 1024 512s-54.04 264.53-150.76 361.24C776.53 969.95 648.53 1024 512 1024m0-938.67c-113.78 0-221.87 45.51-301.51 125.16S85.33 398.22 85.33 512s45.51 221.87 125.16 301.51S398.22 938.67 512 938.67s221.87-45.51 301.51-125.16S938.67 625.78 938.67 512s-45.51-221.87-125.16-301.51S625.78 85.33 512 85.33",
        fill: "currentColor",
        fillOpacity: "0.9"
      }
    ) });
  };
  const i$5 = (t) => {
    const r = { ...dr, ...t };
    return /* @__PURE__ */ xe(mr, { ...r, name: r.name || "Check", viewBox: "0 0 1024 1024", children: /* @__PURE__ */ xe(
      "path",
      {
        d: "M998.4 245.03c-219.43 153.6-398.63 332.8-552.23 552.23-40.23 58.51-128 54.86-164.57-3.66-69.49-106.06-149.94-186.51-256-256-51.2-32.91-18.29-113.37 40.23-98.74 117.03 21.94 208.46 69.49 292.57 146.28 157.26-190.17 358.4-340.11 588.8-435.2 62.17-25.6 106.06 58.51 51.2 95.09",
        fill: "currentColor",
        fillOpacity: "0.9"
      }
    ) });
  };
  const d = (e) => {
    const r = { ...dr, ...e };
    return /* @__PURE__ */ xe(mr, { ...r, name: r.name || "Checked", viewBox: "0 0 1024 1024", children: /* @__PURE__ */ xe(
      "path",
      {
        d: "M512 0C230.4 0 0 230.4 0 512s230.4 512 512 512 512-230.4 512-512S793.6 0 512 0m281.6 369.78c-14.22 11.38-193.42 130.84-321.42 321.42 0 0 0 2.84-2.85 2.84-8.53 5.69-48.35 36.98-88.17-8.53-39.82-51.2-62.58-99.56-142.23-142.22-2.84 0-2.84-2.85-2.84-2.85-8.53-11.38-39.82-56.89 19.91-56.88 45.51 0 91.02 11.38 162.13 73.95 5.69 5.69 14.22 5.69 17.07 0 34.13-39.82 173.51-190.58 332.8-238.93 0 0 19.91-2.85 31.29 14.22 5.69 11.38 11.38 22.76-5.69 36.98",
        fill: "currentColor",
        fillOpacity: "0.9"
      }
    ) });
  };
  const i$4 = (t) => {
    const r = { ...dr, ...t };
    return /* @__PURE__ */ xe(mr, { ...r, name: r.name || "Checklist", viewBox: "0 0 1024 1024", children: /* @__PURE__ */ xe(
      "path",
      {
        d: "M159.29 500.62c62.58 0 125.16 17.07 221.87 102.4 8.53 5.69 19.91 5.69 25.6 0 48.35-54.04 238.93-261.69 455.11-329.95 0 0 28.45-5.69 42.66 19.91 8.53 17.07 19.91 34.13-5.69 54.04-22.75 17.07-264.53 179.2-440.88 440.89l-2.85 2.85c-11.38 8.53-68.27 51.2-119.47-14.23-56.89-71.11-85.33-139.38-196.26-196.26-2.85 0-2.85-2.85-5.69-5.69-11.38-11.38-54.04-73.95 25.6-73.96",
        fill: "currentColor",
        fillOpacity: "0.9"
      }
    ) });
  };
  const n$5 = (r) => {
    const a = { ...dr, ...r };
    return /* @__PURE__ */ xe(mr, { ...a, name: a.name || "Close", viewBox: "0 0 1024 1024", children: /* @__PURE__ */ xe(
      "path",
      {
        d: "M865.83 926.17a42.67 42.67 0 1 0 60.36-60.34L572.35 512l353.84-353.83a42.67 42.67 0 0 0-60.36-60.34L512 451.67 158.19 97.83a42.67 42.67 0 0 0-60.36 60.34L451.67 512 97.83 865.83a42.67 42.67 0 1 0 60.34 60.34L512 572.33z",
        fill: "currentColor",
        fillOpacity: "0.9"
      }
    ) });
  };
  const p$4 = (r) => {
    const a = { ...dr, ...r };
    return /* @__PURE__ */ gr(mr, { ...a, name: a.name || "Del", viewBox: "0 0 1024 1024", children: [
      /* @__PURE__ */ xe(
        "path",
        {
          d: "M298.67 42.67a42.67 42.67 0 1 0 0 85.33h426.66a42.67 42.67 0 1 0 0-85.33zM448 469.33h-85.33v256H448zm213.33 0H576v256h85.33z",
          fill: "currentColor",
          fillOpacity: "0.9"
        }
      ),
      ",",
      /* @__PURE__ */ xe(
        "path",
        {
          d: "M0 256a42.67 42.67 0 0 1 42.67-42.67h938.66a42.67 42.67 0 1 1 0 85.34h-47.4l-31.21 561.77a128 128 0 0 1-127.79 120.89H249.07a128 128 0 0 1-127.79-120.89L90.07 298.67h-47.4A42.67 42.67 0 0 1 0 256m175.53 42.67 30.98 557.01A42.67 42.67 0 0 0 249.09 896h525.82a42.67 42.67 0 0 0 42.6-40.32l30.94-557.01h-672.9z",
          fill: "currentColor",
          fillOpacity: "0.9"
        }
      )
    ] });
  };
  const p$3 = (a) => {
    const l = { ...dr, ...a };
    return /* @__PURE__ */ gr(mr, { ...l, name: l.name || "Failure", viewBox: "0 0 1024 1024", children: [
      /* @__PURE__ */ xe(
        "path",
        {
          d: "M313.3 373.65 451.65 512 313.3 650.35l60.35 60.35L512 572.33 650.35 710.7l60.33-60.35L572.33 512 710.7 373.65l-60.35-60.35L512 451.67 373.65 313.3z",
          fill: "currentColor",
          fillOpacity: "0.9"
        }
      ),
      ",",
      /* @__PURE__ */ xe(
        "path",
        {
          d: "M1024 512c0 282.77-229.23 512-512 512S0 794.77 0 512 229.23 0 512 0s512 229.23 512 512m-85.33 0c0-235.65-191.02-426.67-426.67-426.67S85.33 276.35 85.33 512 276.35 938.67 512 938.67 938.67 747.65 938.67 512",
          fill: "currentColor",
          fillOpacity: "0.9"
        }
      )
    ] });
  };
  const p$2 = (a) => {
    const l = { ...dr, ...a };
    return /* @__PURE__ */ gr(mr, { ...l, name: l.name || "ImageError", viewBox: "0 0 1024 1024", children: [
      /* @__PURE__ */ xe(
        "path",
        {
          d: "M696.43 465.25c40.61 0 73.53-32.72 73.53-73.09s-32.96-73.08-73.53-73.08-73.54 32.72-73.54 73.08 32.92 73.09 73.54 73.09M535.74 650.62l-273.61-259.4a56.19 56.19 0 0 0-15.36 11.58l-114 119.63-6-222.77c-.73-26.82 20.84-49.41 47.67-50.14l201.77-5.44 47.34-50-250.43 6.75C119 202.33 76.33 247.17 77.78 301l7.32 271.4 4.5 166.78C91.06 793 136.05 835.47 190.2 834l176-4.75 12-.32 47.34-50 116.18-122.64z",
          fill: "currentColor",
          fillOpacity: "0.9"
        }
      ),
      ",",
      /* @__PURE__ */ xe(
        "path",
        {
          d: "m861.71 214.8-242.83-33.86-55.09 41.46L855 263a49.05 49.05 0 0 1 41.79 55.13l-54.33 389.59-120.87-159.05A59.86 59.86 0 0 0 638.06 537l-44 33.08 65.07 86.15L603.84 698l-79.57 60.1-54.92 41.48 34.17 4.76 270.73 37.76a97.55 97.55 0 0 0 109.88-79.6 22.37 22.37 0 0 0 .65-3.44l60.53-434.16c7.44-53.32-29.95-102.62-83.6-110.1",
          fill: "currentColor",
          fillOpacity: "0.9"
        }
      )
    ] });
  };
  const p$1 = (o) => {
    const a = { ...dr, ...o };
    return /* @__PURE__ */ gr(mr, { ...a, name: a.name || "Image", viewBox: "0 0 1024 1024", children: [
      /* @__PURE__ */ xe(
        "path",
        {
          d: "M384 341.33a85.33 85.33 0 1 1-170.67 0 85.33 85.33 0 0 1 170.67 0",
          fill: "currentColor",
          fillOpacity: "0.9"
        }
      ),
      ",",
      /* @__PURE__ */ xe(
        "path",
        {
          d: "M0 170.67a128 128 0 0 1 128-128h768a128 128 0 0 1 128 128v682.66a128 128 0 0 1-128 128H128a128 128 0 0 1-128-128zM128 128a42.67 42.67 0 0 0-42.67 42.67v405.84a383.38 383.38 0 0 1 128-21.84c71.89 0 139.16 19.75 196.68 54.12C492.46 473.96 641.05 384 810.67 384c44.37 0 87.32 6.17 128 17.66V170.67A42.67 42.67 0 0 0 896 128zM85.33 668.74v184.59A42.67 42.67 0 0 0 128 896h380.97C488.28 751.25 363.8 640 213.33 640c-45.8 0-89.19 10.3-128 28.74M594.99 896H896a42.67 42.67 0 0 0 42.67-42.67V491.18a383.36 383.36 0 0 0-128-21.85c-141.91 0-265.81 76.97-332.31 191.45A382.98 382.98 0 0 1 594.99 896",
          fill: "currentColor",
          fillOpacity: "0.9"
        }
      )
    ] });
  };
  const c$3 = (a) => {
    const o = { ...dr, ...a };
    return /* @__PURE__ */ xe(mr, { ...o, name: o.name || "JoySmile", viewBox: "0 0 1024 1024", children: /* @__PURE__ */ xe(
      "path",
      {
        d: "M728.58 159.81a39.33 39.33 0 1 0-54.28-56.95c-94.92 90.4-244.1 90.4-339.03 0A39.35 39.35 0 0 0 281 159.81c125.33 119.35 322.24 119.35 447.58 0",
        fill: "currentColor",
        fillOpacity: "0.9"
      }
    ) });
  };
  const s$3 = (r) => {
    const a = { ...dr, ...r };
    return /* @__PURE__ */ xe(mr, { ...a, name: a.name || "Link", viewBox: "0 0 1024 1024", children: /* @__PURE__ */ xe(
      "path",
      {
        d: "M777.87 246.13a166.03 166.03 0 0 0-234.78 0l-74.39 74.24a43.89 43.89 0 0 1-62.03-62.1l74.24-74.24A253.81 253.81 0 0 1 839.9 543.01l-74.17 74.32a43.89 43.89 0 1 1-62.1-62.03l74.24-74.24a166.03 166.03 0 0 0 0-234.86zM637.44 386.56a43.89 43.89 0 0 1 0 62.03L448.66 637.51a43.89 43.89 0 1 1-62.1-62.1l188.93-188.92a43.89 43.89 0 0 1 62.1 0zm-317.07 20.11a43.89 43.89 0 0 1 0 62.03l-74.24 74.31a166.03 166.03 0 0 0 234.78 234.86l74.39-74.24a43.89 43.89 0 0 1 62.03 62.1l-74.24 74.17A253.81 253.81 0 1 1 184.1 480.99l74.17-74.32a43.89 43.89 0 0 1 62.1 0",
        fill: "currentColor",
        fillOpacity: "0.9"
      }
    ) });
  };
  const n$4 = (o) => {
    const a = { ...dr, ...o };
    return /* @__PURE__ */ xe(mr, { ...a, name: a.name || "Loading", viewBox: "0 0 1024 1024", children: /* @__PURE__ */ xe(
      "path",
      {
        d: "M512 73.14a43.89 43.89 0 0 1 43.89 43.89v118.49a43.89 43.89 0 0 1-87.78 0V117.03A43.89 43.89 0 0 1 512 73.14M201.65 201.65a43.89 43.89 0 0 1 62.1 0l83.68 83.83a43.89 43.89 0 1 1-62.03 62.02l-83.75-83.75a43.89 43.89 0 0 1 0-62.1m620.7 0a43.89 43.89 0 0 1 0 62.1l-83.83 83.68a43.89 43.89 0 1 1-62.02-62.03l83.75-83.82a43.89 43.89 0 0 1 62.1 0zM73.14 512a43.89 43.89 0 0 1 43.89-43.89h118.49a43.89 43.89 0 0 1 0 87.78H117.03A43.89 43.89 0 0 1 73.14 512m671.45 0a43.89 43.89 0 0 1 43.89-43.89h118.49a43.89 43.89 0 1 1 0 87.78H788.48A43.89 43.89 0 0 1 744.59 512M347.5 676.5a43.89 43.89 0 0 1 0 62.02l-83.75 83.83a43.89 43.89 0 1 1-62.1-62.1l83.83-83.68a43.89 43.89 0 0 1 62.02 0zm329 0a43.89 43.89 0 0 1 62.02 0l83.83 83.75a43.89 43.89 0 1 1-62.1 62.1l-83.68-83.83a43.89 43.89 0 0 1 0-62.02zM512 744.59a43.89 43.89 0 0 1 43.89 43.89v118.49a43.89 43.89 0 1 1-87.78 0V788.48A43.89 43.89 0 0 1 512 744.59",
        fill: "currentColor",
        fillOpacity: "0.9"
      }
    ) });
  };
  const n$3 = (a) => {
    const o = { ...dr, ...a };
    return /* @__PURE__ */ xe(mr, { ...o, name: o.name || "Loading1", viewBox: "0 0 1024 1024", children: /* @__PURE__ */ xe(
      "path",
      {
        d: "M520.66 64.56a29.24 29.24 0 0 0-7.07-.89c-16.21 0-29.35 13.14-29.35 29.35 0 15.83 12.54 28.7 28.23 29.29v.08c.38 0 .75-.01 1.12-.02 216.49 0 389.63 173.94 389.63 390.44S730.08 901.64 513.59 901.63 123.96 729.3 123.96 512.8c0-.27.01-.54.01-.8h-.01c0-16.21-13.14-29.35-29.35-29.35S65.26 495.79 65.26 512c0 .06.01.11.01.16 0 .21-.01.42-.01.64 0 247.61 200.72 448.33 448.33 448.33 247.61 0 448.33-200.72 448.33-448.33 0-245.24-196.92-444.46-441.25-448.24z",
        fill: "currentColor",
        fillOpacity: "0.9"
      }
    ) });
  };
  const n$2 = (r) => {
    const a = { ...dr, ...r };
    return /* @__PURE__ */ gr(mr, { ...a, name: a.name || "Location", viewBox: "0 0 1024 1024", children: [
      /* @__PURE__ */ xe(
        "path",
        {
          d: "M682.67 470.04c0 94.4-76.42 170.94-170.67 170.94s-170.67-76.54-170.67-170.94S417.75 299.12 512 299.11s170.67 76.52 170.67 170.93m-85.34 0A85.4 85.4 0 0 0 512 384.58c-47.15 0-85.33 38.27-85.33 85.46A85.4 85.4 0 0 0 512 555.5c47.15 0 85.33-38.25 85.33-85.46",
          fill: "currentColor",
          fillOpacity: "0.9"
        }
      ),
      ",",
      /* @__PURE__ */ xe(
        "path",
        {
          d: "M981.33 470.04c0 277.76-312.75 465.73-464.15 552.53a10.22 10.22 0 0 1-10.36 0C355.42 935.79 42.67 747.82 42.67 470.06 42.67 210.45 252.8 0 512 0s469.33 210.45 469.33 470.04m-85.33 0c0-212.39-171.93-384.58-384-384.58S128 257.64 128 470.04c0 106.24 60.52 202.73 151.85 288.85 74.6 70.4 161.98 126.46 232.15 167.89 70.19-41.43 157.55-97.49 232.15-167.89C835.46 672.77 896 576.28 896 470.04",
          fill: "currentColor",
          fillOpacity: "0.9"
        }
      )
    ] });
  };
  const i$3 = (r) => {
    const s2 = { ...dr, ...r };
    return /* @__PURE__ */ xe(mr, { ...s2, name: s2.name || "MaskClose", viewBox: "0 0 1024 1024", children: /* @__PURE__ */ xe(
      "path",
      {
        d: "M512 14.9C238.59 14.9 14.9 238.6 14.9 512s223.7 497.1 497.1 497.1 497.1-223.7 497.1-497.1S785.4 14.9 512 14.9m207.13 646.23c16.57 16.57 16.57 41.42 0 58s-41.42 16.57-58 0L512 570 362.87 719.13c-16.57 16.57-41.43 16.57-58 0s-16.57-41.42 0-58L454 512 304.87 362.87c-16.57-16.57-16.57-41.43 0-58s41.42-16.57 58 0L512 454l149.13-149.13c16.57-16.57 41.43-16.57 58 0s16.57 41.42 0 58L570 512z",
        fill: "currentColor",
        fillOpacity: "0.9"
      }
    ) });
  };
  const n$1 = (s2) => {
    const r = { ...dr, ...s2 };
    return /* @__PURE__ */ xe(mr, { ...r, name: r.name || "Minus", viewBox: "0 0 1024 1024", children: /* @__PURE__ */ xe(
      "path",
      {
        d: "M299.52 460.8h409.6c28.16 0 51.2 23.04 51.2 51.2s-23.04 51.2-51.2 51.2h-409.6c-28.16 0-51.2-23.04-51.2-51.2s23.04-51.2 51.2-51.2",
        fill: "currentColor",
        fillOpacity: "0.9"
      }
    ) });
  };
  const m = (o) => {
    const r = { ...dr, ...o };
    return /* @__PURE__ */ xe(mr, { ...r, name: r.name || "More", viewBox: "0 0 1024 1024", children: /* @__PURE__ */ xe(
      "path",
      {
        d: "M170.67 512A85.33 85.33 0 1 1 0 512a85.33 85.33 0 0 1 170.67 0m426.66 0a85.33 85.33 0 1 1-170.66 0 85.33 85.33 0 0 1 170.66 0m341.34 85.33a85.33 85.33 0 1 0 0-170.66 85.33 85.33 0 0 0 0 170.66",
        fill: "currentColor",
        fillOpacity: "0.9"
      }
    ) });
  };
  const c$2 = (r) => {
    const a = { ...dr, ...r };
    return /* @__PURE__ */ xe(mr, { ...a, name: a.name || "Notice", viewBox: "0 0 1024 1024", children: /* @__PURE__ */ xe(
      "path",
      {
        d: "M128 384v213.33a128 128 0 0 0 0 256h768a128 128 0 0 0 0-256V384C896 171.93 724.07 0 512 0S128 171.93 128 384m0 298.67h42.67A42.67 42.67 0 0 0 213.33 640V384c0-164.95 133.72-298.67 298.67-298.67S810.67 219.05 810.67 384v256a42.67 42.67 0 0 0 42.66 42.67H896a42.67 42.67 0 1 1 0 85.33H128a42.67 42.67 0 1 1 0-85.33m256 256a42.67 42.67 0 1 0 0 85.33h256a42.67 42.67 0 1 0 0-85.33z",
        fill: "currentColor",
        fillOpacity: "0.9"
      }
    ) });
  };
  const c$1 = (o) => {
    const a = { ...dr, ...o };
    return /* @__PURE__ */ gr(mr, { ...a, name: a.name || "Photograph", viewBox: "0 0 1024 1024", children: [
      /* @__PURE__ */ xe(
        "path",
        {
          d: "M512 768c117.82 0 213.33-95.51 213.33-213.33S629.82 341.34 512 341.33s-213.33 95.51-213.33 213.34S394.18 768 512 768m0-85.33a128 128 0 1 1 0-256 128 128 0 0 1 0 256m298.67-256a42.67 42.67 0 1 0 0-85.34 42.67 42.67 0 0 0 0 85.34",
          fill: "currentColor",
          fillOpacity: "0.9"
        }
      ),
      ",",
      /* @__PURE__ */ xe(
        "path",
        {
          d: "M256 170.67H128a128 128 0 0 0-128 128v554.66a128 128 0 0 0 128 128h768a128 128 0 0 0 128-128V298.67a128 128 0 0 0-128-128H768l-47.34-71a128 128 0 0 0-106.47-57H409.81a128 128 0 0 0-106.49 57zM301.65 256l72.69-109.01A42.67 42.67 0 0 1 409.83 128h204.34a42.67 42.67 0 0 1 35.49 18.99L722.33 256H896a42.67 42.67 0 0 1 42.67 42.67v554.66A42.67 42.67 0 0 1 896 896H128a42.67 42.67 0 0 1-42.67-42.67V298.67A42.67 42.67 0 0 1 128 256z",
          fill: "currentColor",
          fillOpacity: "0.9"
        }
      )
    ] });
  };
  const n = (o) => {
    const t = { ...dr, ...o };
    return /* @__PURE__ */ xe(mr, { ...t, name: t.name || "Plus", viewBox: "0 0 1024 1024", children: /* @__PURE__ */ xe(
      "path",
      {
        d: "M345.6 460.8h409.6q51.2 0 51.2 51.2t-51.2 51.2H345.6q-51.2 0-51.2-51.2t51.2-51.2M550.4 256q51.2 0 51.2 51.2v409.6q0 51.2-51.2 51.2t-51.2-51.2V307.2q0-51.2 51.2-51.2",
        fill: "currentColor",
        fillOpacity: "0.9"
      }
    ) });
  };
  const i$2 = (o) => {
    const r = { ...dr, ...o };
    return /* @__PURE__ */ xe(mr, { ...r, name: r.name || "Search", viewBox: "0 0 1024 1024", children: /* @__PURE__ */ xe(
      "path",
      {
        d: "M469.33 938.67c259.2 0 469.33-210.13 469.34-469.34S728.54 0 469.33 0 0 210.13 0 469.33s210.13 469.33 469.33 469.34m0-85.34c-212.07 0-384-171.93-384-384s171.93-384 384-384 384 171.93 384 384-171.93 384-384 384m435.5-8.83a42.67 42.67 0 1 0-60.33 60.33l106.67 106.67a42.67 42.67 0 1 0 60.33-60.33z",
        fill: "currentColor",
        fillOpacity: "0.9"
      }
    ) });
  };
  const i$1 = (c6) => {
    const s2 = { ...dr, ...c6 };
    return /* @__PURE__ */ xe(mr, { ...s2, name: s2.name || "Service", viewBox: "0 0 1024 1024", children: /* @__PURE__ */ xe(
      "path",
      {
        d: "M1024 657.72H905.85V531.69c0-228.43-177.23-413.54-393.85-413.54S118.15 303.26 118.15 531.69v126.03H0V531.69C0 236.3 228.43 0 512 0s512 236.31 512 531.69zM196.92 866.46C86.64 866.46 0 779.81 0 669.54s86.65-196.92 196.92-196.93 196.92 86.65 196.93 196.93-86.65 196.92-196.93 196.92m0-275.69c-43.32 0-78.77 35.45-78.77 78.77s35.45 78.77 78.77 78.77 78.77-35.45 78.77-78.77-35.45-78.77-78.77-78.77m630.16 275.69c-110.28 0-196.92-86.65-196.93-196.92s86.65-196.92 196.93-196.93S1024 559.26 1024 669.54s-86.65 196.92-196.92 196.92m0-275.69c-43.32 0-78.77 35.45-78.77 78.77s35.45 78.77 78.77 78.77 78.77-35.45 78.77-78.77-35.45-78.77-78.77-78.77m-149.66 429.29c-23.63 0-47.26-15.75-55.14-43.32-7.88-31.51 7.88-63.02 39.38-74.83 102.4-31.51 189.05-102.4 236.31-196.93 15.75-27.57 51.2-39.38 78.77-23.63s39.38 51.2 23.63 78.77c-63.02 122.09-177.23 216.61-307.2 256-3.94 3.94-11.81 3.94-15.75 3.94",
        fill: "currentColor",
        fillOpacity: "0.9"
      }
    ) });
  };
  const s$2 = (o) => {
    const l = { ...dr, ...o };
    return /* @__PURE__ */ xe(mr, { ...l, name: l.name || "StarFill", viewBox: "0 0 1024 1024", children: /* @__PURE__ */ xe(
      "path",
      {
        d: "m908.1 353.1-253.9-36.9L540.7 86.1c-3.1-6.3-8.2-11.4-14.5-14.5-15.8-7.8-35-1.3-42.9 14.5L369.8 316.2l-253.9 36.9c-7 1-13.4 4.3-18.3 9.3-12.3 12.7-12.1 32.9.6 45.3l183.7 179.1-43.4 252.9c-1.2 6.9-.1 14.1 3.2 20.3 8.2 15.6 27.6 21.7 43.2 13.4L512 754l227.1 119.4c6.2 3.3 13.4 4.4 20.3 3.2 17.4-3 29.1-19.5 26.1-36.9l-43.4-252.9 183.7-179.1c5-4.9 8.3-11.3 9.3-18.3 2.7-17.5-9.5-33.7-27-36.3",
        fill: "currentColor",
        fillOpacity: "0.9"
      }
    ) });
  };
  const c = (r) => {
    const a = { ...dr, ...r };
    return /* @__PURE__ */ gr(mr, { ...a, name: a.name || "Tips", viewBox: "0 0 1024 1024", children: [
      /* @__PURE__ */ xe(
        "path",
        {
          d: "M530.65 456.17H425.54l-21.34 55.85h74.39l-38.18 210.13a34.97 34.97 0 0 0 34.38 41.22H579.9l21.34-55.85h-74.39l38.18-210.13a34.92 34.92 0 0 0-34.38-41.22M512 384a64 64 0 1 0 0-128 64 64 0 0 0 0 128",
          fill: "currentColor",
          fillOpacity: "0.9"
        }
      ),
      ",",
      /* @__PURE__ */ xe(
        "path",
        {
          d: "M512 1024c282.77 0 512-229.23 512-512S794.77 0 512 0 0 229.23 0 512s229.23 512 512 512m0-85.33C276.35 938.67 85.33 747.65 85.33 512S276.35 85.33 512 85.33 938.67 276.35 938.67 512 747.65 938.67 512 938.67",
          fill: "currentColor",
          fillOpacity: "0.9"
        }
      )
    ] });
  };
  const s$1 = (r) => {
    const a = { ...dr, ...r };
    return /* @__PURE__ */ xe(mr, { ...a, name: a.name || "Top", viewBox: "0 0 1024 1024", children: /* @__PURE__ */ xe(
      "path",
      {
        d: "M128 0a42.67 42.67 0 1 0 0 85.33h768A42.67 42.67 0 1 0 896 0zm391.21 173.42a10.88 10.88 0 0 0-14.42 0L3.61 619.67a10.71 10.71 0 0 0 7.21 18.67h241.34v257.11c0 71 58.05 128.55 129.64 128.55h260.4c71.59 0 129.64-57.56 129.64-128.55V638.34h241.34a10.71 10.71 0 0 0 7.21-18.67zM338.6 895.45V552.64H208.21L512 282.15l303.77 270.49H685.42v342.83c0 23.64-19.37 42.84-43.22 42.83H381.8c-23.85 0-43.2-19.2-43.2-42.85",
        fill: "currentColor",
        fillOpacity: "0.9"
      }
    ) });
  };
  const s = (o) => {
    const r = { ...dr, ...o };
    return /* @__PURE__ */ xe(mr, { ...r, name: r.name || "TriangleDown", viewBox: "0 0 1024 1024", children: /* @__PURE__ */ xe(
      "path",
      {
        d: "m573.06 752 308.8-404.61A76.8 76.8 0 0 0 820.74 224H203.23a76.8 76.8 0 0 0-61.05 123.39L450.98 752a76.8 76.8 0 0 0 122.08 0",
        fill: "currentColor",
        fillOpacity: "0.9"
      }
    ) });
  };
  const p = (o) => {
    const r = { ...dr, ...o };
    return /* @__PURE__ */ xe(mr, { ...r, name: r.name || "TriangleUp", viewBox: "0 0 1024 1024", children: /* @__PURE__ */ xe(
      "path",
      {
        d: "m573.06 272 308.8 404.61A76.8 76.8 0 0 1 820.74 800H203.23a76.8 76.8 0 0 1-61.05-123.39L450.98 272a76.8 76.8 0 0 1 122.08 0",
        fill: "currentColor",
        fillOpacity: "0.9"
      }
    ) });
  };
  const i = (c6) => {
    const r = { ...dr, ...c6 };
    return /* @__PURE__ */ xe(mr, { ...r, name: r.name || "User", viewBox: "0 0 1024 1024", children: /* @__PURE__ */ xe(
      "path",
      {
        d: "M511.86 804.3c-223.01 0-402.15-179.14-402.15-402.15S288.85 0 511.86 0s402.15 179.14 402.15 402.15S734.87 804.3 511.86 804.3m0-694.62c-160.86 0-292.47 131.61-292.47 292.47S351 694.62 511.86 694.62s292.47-131.61 292.48-292.47-131.61-292.47-292.48-292.47m237.64 913.97c-29.25 0-51.18-21.94-54.84-51.18-7.31-95.05-87.74-168.17-182.8-168.17s-175.48 73.12-182.79 168.17c-3.66 29.25-29.25 54.84-58.5 51.18-29.25 0-51.18-29.25-51.18-58.49 10.97-153.55 138.92-270.54 292.47-270.54s281.5 120.64 292.47 270.54c3.65 29.25-21.94 54.84-51.18 58.49zM511.86 548.38c-47.53 0-91.4-21.93-120.64-58.49-18.28-25.59-14.62-58.49 7.31-76.77 25.59-18.28 58.49-14.62 76.77 7.31s51.18 21.93 69.47 0 54.84-29.25 76.77-7.31c21.93 18.28 29.25 54.84 7.31 76.77-25.59 40.22-69.46 58.49-116.99 58.49",
        fill: "currentColor",
        fillOpacity: "0.9"
      }
    ) });
  };
  const ComponentDefaults = {
    className: "",
    style: {}
  };
  const prefixCls$2 = "nut-button";
  const defaultProps$1u = {
    ...ComponentDefaults,
    color: "",
    type: "default",
    size: "normal",
    shape: "round",
    fill: "outline",
    loading: false,
    disabled: false,
    block: false,
    icon: null,
    rightIcon: null,
    nativeType: "button",
    onClick: (e) => {
    }
  };
  const Button = React.forwardRef(
    (props, ref) => {
      const {
        color,
        shape,
        fill,
        loading,
        disabled,
        type,
        size,
        block,
        icon,
        rightIcon,
        children,
        className,
        style,
        nativeType,
        onClick,
        ...rest
      } = {
        ...defaultProps$1u,
        ...props
      };
      const getStyle = React.useCallback(() => {
        const style2 = {};
        if (color) {
          if (props.fill === "outline" || props.fill === "dashed") {
            style2.color = color;
            if (!(color == null ? void 0 : color.includes("gradient"))) {
              style2.borderColor = color;
            }
          } else {
            style2.color = "#fff";
            style2.background = color;
            style2.borderColor = "transparent";
          }
        }
        return style2;
      }, [color, props.fill]);
      const handleClick2 = (e) => {
        if (!loading && !disabled && onClick) {
          onClick(e);
        }
      };
      return /* @__PURE__ */ React.createElement(
        "button",
        {
          ...rest,
          ref,
          type: nativeType,
          className: classNames(
            prefixCls$2,
            `${prefixCls$2}-${type}`,
            props.fill ? `${prefixCls$2}-${fill}` : null,
            children ? "" : `${prefixCls$2}-icononly`,
            {
              [`${prefixCls$2}-${size}`]: size,
              [`${prefixCls$2}-${shape}`]: shape,
              [`${prefixCls$2}-block`]: block,
              [`${prefixCls$2}-disabled`]: disabled || loading,
              [`${prefixCls$2}-loading`]: loading
            },
            className
          ),
          style: { ...getStyle(), ...style },
          onClick: (e) => handleClick2(e)
        },
        /* @__PURE__ */ React.createElement("div", { className: "nut-button-wrap" }, loading && /* @__PURE__ */ React.createElement(n$4, { className: "nut-icon-loading" }), !loading && icon ? icon : null, children && /* @__PURE__ */ React.createElement(
          "div",
          {
            className: `${icon || loading ? "nut-button-text" : ""}${rightIcon ? " nut-button-text right" : ""}`
          },
          children
        ), rightIcon || null)
      );
    }
  );
  Button.displayName = "NutButton";
  const CellGroupContext = React.createContext(null);
  const defaultProps$1t = {
    ...ComponentDefaults,
    title: "",
    description: "",
    divider: true
  };
  const classPrefix$r = "nut-cell-group";
  const CellGroup = (props) => {
    const { children, className, title, description, divider, ...rest } = {
      ...defaultProps$1t,
      ...props
    };
    return /* @__PURE__ */ React.createElement("div", { className: classNames(classPrefix$r, className), ...rest }, title ? /* @__PURE__ */ React.createElement("div", { className: `${classPrefix$r}-title` }, title) : null, description ? /* @__PURE__ */ React.createElement("div", { className: `${classPrefix$r}-description` }, description) : null, /* @__PURE__ */ React.createElement(
      "div",
      {
        className: `${classPrefix$r}-wrap ${divider ? `${classPrefix$r}-wrap-divider` : ""}`
      },
      /* @__PURE__ */ React.createElement(CellGroupContext.Provider, { value: { divider } }, children)
    ));
  };
  CellGroup.displayName = "NutCellGroup";
  const defaultProps$1s = {
    ...ComponentDefaults,
    title: null,
    description: null,
    extra: null,
    radius: "6px",
    align: "flex-start",
    clickable: false,
    onClick: (event) => {
    }
  };
  const classPrefix$q = "nut-cell";
  const Cell = (props) => {
    const ctx2 = React.useContext(CellGroupContext);
    const {
      children,
      clickable,
      onClick,
      title,
      description,
      extra,
      radius,
      align,
      className,
      style,
      ...rest
    } = {
      ...defaultProps$1s,
      ...props
    };
    const handleClick2 = (event) => {
      onClick(event);
    };
    const baseStyle = {
      ...style,
      borderRadius: Number.isNaN(Number(radius)) ? String(radius) : `${radius}px`,
      alignItems: align
    };
    const styles = title || description ? {} : {
      flex: 1
    };
    return /* @__PURE__ */ React.createElement(
      "div",
      {
        className: `${classNames(classPrefix$q, className, clickable ? `${classPrefix$q}-clickable` : "")}`,
        onClick: (event) => handleClick2(event),
        style: baseStyle,
        ...rest
      },
      children || /* @__PURE__ */ React.createElement(React.Fragment, null, title || description ? /* @__PURE__ */ React.createElement("div", { className: `${classPrefix$q}-left` }, title ? /* @__PURE__ */ React.createElement("div", { className: `${classPrefix$q}-title` }, title) : null, description ? /* @__PURE__ */ React.createElement("div", { className: `${classPrefix$q}-description` }, description) : null) : null, extra ? /* @__PURE__ */ React.createElement(
        "div",
        {
          className: `${classPrefix$q}-extra`,
          style: styles
        },
        extra
      ) : null),
      (ctx2 == null ? void 0 : ctx2.divider) ? /* @__PURE__ */ React.createElement("div", { className: `${classPrefix$q}-divider` }) : null
    );
  };
  Cell.displayName = "NutCell";
  Cell.Group = CellGroup;
  var INFINITY = 1 / 0;
  var symbolTag = "[object Symbol]";
  var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
  var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
  var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f\\ufe20-\\ufe23", rsComboSymbolsRange = "\\u20d0-\\u20f0", rsDingbatRange = "\\u2700-\\u27bf", rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff", rsMathOpRange = "\\xac\\xb1\\xd7\\xf7", rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", rsPunctuationRange = "\\u2000-\\u206f", rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde", rsVarRange = "\\ufe0e\\ufe0f", rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
  var rsApos = "['’]", rsBreak = "[" + rsBreakRange + "]", rsCombo = "[" + rsComboMarksRange + rsComboSymbolsRange + "]", rsDigits = "\\d+", rsDingbat = "[" + rsDingbatRange + "]", rsLower = "[" + rsLowerRange + "]", rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsUpper = "[" + rsUpperRange + "]", rsZWJ = "\\u200d";
  var rsLowerMisc = "(?:" + rsLower + "|" + rsMisc + ")", rsUpperMisc = "(?:" + rsUpper + "|" + rsMisc + ")", rsOptLowerContr = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?", rsOptUpperContr = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?", reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq;
  var reApos = RegExp(rsApos, "g");
  var reComboMark = RegExp(rsCombo, "g");
  var reUnicodeWord = RegExp([
    rsUpper + "?" + rsLower + "+" + rsOptLowerContr + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
    rsUpperMisc + "+" + rsOptUpperContr + "(?=" + [rsBreak, rsUpper + rsLowerMisc, "$"].join("|") + ")",
    rsUpper + "?" + rsLowerMisc + "+" + rsOptLowerContr,
    rsUpper + "+" + rsOptUpperContr,
    rsDigits,
    rsEmoji
  ].join("|"), "g");
  var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2,}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
  var deburredLetters = {
    // Latin-1 Supplement block.
    "À": "A",
    "Á": "A",
    "Â": "A",
    "Ã": "A",
    "Ä": "A",
    "Å": "A",
    "à": "a",
    "á": "a",
    "â": "a",
    "ã": "a",
    "ä": "a",
    "å": "a",
    "Ç": "C",
    "ç": "c",
    "Ð": "D",
    "ð": "d",
    "È": "E",
    "É": "E",
    "Ê": "E",
    "Ë": "E",
    "è": "e",
    "é": "e",
    "ê": "e",
    "ë": "e",
    "Ì": "I",
    "Í": "I",
    "Î": "I",
    "Ï": "I",
    "ì": "i",
    "í": "i",
    "î": "i",
    "ï": "i",
    "Ñ": "N",
    "ñ": "n",
    "Ò": "O",
    "Ó": "O",
    "Ô": "O",
    "Õ": "O",
    "Ö": "O",
    "Ø": "O",
    "ò": "o",
    "ó": "o",
    "ô": "o",
    "õ": "o",
    "ö": "o",
    "ø": "o",
    "Ù": "U",
    "Ú": "U",
    "Û": "U",
    "Ü": "U",
    "ù": "u",
    "ú": "u",
    "û": "u",
    "ü": "u",
    "Ý": "Y",
    "ý": "y",
    "ÿ": "y",
    "Æ": "Ae",
    "æ": "ae",
    "Þ": "Th",
    "þ": "th",
    "ß": "ss",
    // Latin Extended-A block.
    "Ā": "A",
    "Ă": "A",
    "Ą": "A",
    "ā": "a",
    "ă": "a",
    "ą": "a",
    "Ć": "C",
    "Ĉ": "C",
    "Ċ": "C",
    "Č": "C",
    "ć": "c",
    "ĉ": "c",
    "ċ": "c",
    "č": "c",
    "Ď": "D",
    "Đ": "D",
    "ď": "d",
    "đ": "d",
    "Ē": "E",
    "Ĕ": "E",
    "Ė": "E",
    "Ę": "E",
    "Ě": "E",
    "ē": "e",
    "ĕ": "e",
    "ė": "e",
    "ę": "e",
    "ě": "e",
    "Ĝ": "G",
    "Ğ": "G",
    "Ġ": "G",
    "Ģ": "G",
    "ĝ": "g",
    "ğ": "g",
    "ġ": "g",
    "ģ": "g",
    "Ĥ": "H",
    "Ħ": "H",
    "ĥ": "h",
    "ħ": "h",
    "Ĩ": "I",
    "Ī": "I",
    "Ĭ": "I",
    "Į": "I",
    "İ": "I",
    "ĩ": "i",
    "ī": "i",
    "ĭ": "i",
    "į": "i",
    "ı": "i",
    "Ĵ": "J",
    "ĵ": "j",
    "Ķ": "K",
    "ķ": "k",
    "ĸ": "k",
    "Ĺ": "L",
    "Ļ": "L",
    "Ľ": "L",
    "Ŀ": "L",
    "Ł": "L",
    "ĺ": "l",
    "ļ": "l",
    "ľ": "l",
    "ŀ": "l",
    "ł": "l",
    "Ń": "N",
    "Ņ": "N",
    "Ň": "N",
    "Ŋ": "N",
    "ń": "n",
    "ņ": "n",
    "ň": "n",
    "ŋ": "n",
    "Ō": "O",
    "Ŏ": "O",
    "Ő": "O",
    "ō": "o",
    "ŏ": "o",
    "ő": "o",
    "Ŕ": "R",
    "Ŗ": "R",
    "Ř": "R",
    "ŕ": "r",
    "ŗ": "r",
    "ř": "r",
    "Ś": "S",
    "Ŝ": "S",
    "Ş": "S",
    "Š": "S",
    "ś": "s",
    "ŝ": "s",
    "ş": "s",
    "š": "s",
    "Ţ": "T",
    "Ť": "T",
    "Ŧ": "T",
    "ţ": "t",
    "ť": "t",
    "ŧ": "t",
    "Ũ": "U",
    "Ū": "U",
    "Ŭ": "U",
    "Ů": "U",
    "Ű": "U",
    "Ų": "U",
    "ũ": "u",
    "ū": "u",
    "ŭ": "u",
    "ů": "u",
    "ű": "u",
    "ų": "u",
    "Ŵ": "W",
    "ŵ": "w",
    "Ŷ": "Y",
    "ŷ": "y",
    "Ÿ": "Y",
    "Ź": "Z",
    "Ż": "Z",
    "Ž": "Z",
    "ź": "z",
    "ż": "z",
    "ž": "z",
    "Ĳ": "IJ",
    "ĳ": "ij",
    "Œ": "Oe",
    "œ": "oe",
    "ŉ": "'n",
    "ſ": "ss"
  };
  var freeGlobal = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
  var freeSelf = typeof self == "object" && self && self.Object === Object && self;
  var root = freeGlobal || freeSelf || Function("return this")();
  function arrayReduce(array, iteratee, accumulator, initAccum) {
    var index = -1, length = array ? array.length : 0;
    while (++index < length) {
      accumulator = iteratee(accumulator, array[index], index, array);
    }
    return accumulator;
  }
  function asciiWords(string2) {
    return string2.match(reAsciiWord) || [];
  }
  function basePropertyOf(object) {
    return function(key) {
      return object == null ? void 0 : object[key];
    };
  }
  var deburrLetter = basePropertyOf(deburredLetters);
  function hasUnicodeWord(string2) {
    return reHasUnicodeWord.test(string2);
  }
  function unicodeWords(string2) {
    return string2.match(reUnicodeWord) || [];
  }
  var objectProto = Object.prototype;
  var objectToString = objectProto.toString;
  var Symbol$1 = root.Symbol;
  var symbolProto = Symbol$1 ? Symbol$1.prototype : void 0, symbolToString = symbolProto ? symbolProto.toString : void 0;
  function baseToString(value) {
    if (typeof value == "string") {
      return value;
    }
    if (isSymbol(value)) {
      return symbolToString ? symbolToString.call(value) : "";
    }
    var result = value + "";
    return result == "0" && 1 / value == -INFINITY ? "-0" : result;
  }
  function createCompounder(callback) {
    return function(string2) {
      return arrayReduce(words(deburr(string2).replace(reApos, "")), callback, "");
    };
  }
  function isObjectLike(value) {
    return !!value && typeof value == "object";
  }
  function isSymbol(value) {
    return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
  }
  function toString(value) {
    return value == null ? "" : baseToString(value);
  }
  function deburr(string2) {
    string2 = toString(string2);
    return string2 && string2.replace(reLatin, deburrLetter).replace(reComboMark, "");
  }
  var kebabCase = createCompounder(function(result, word, index) {
    return result + (index ? "-" : "") + word.toLowerCase();
  });
  function words(string2, pattern, guard) {
    string2 = toString(string2);
    pattern = pattern;
    if (pattern === void 0) {
      return hasUnicodeWord(string2) ? unicodeWords(string2) : asciiWords(string2);
    }
    return string2.match(pattern) || [];
  }
  var lodash_kebabcase = kebabCase;
  const kebabCase$1 = /* @__PURE__ */ getDefaultExportFromCjs(lodash_kebabcase);
  var lodash_isequal = { exports: {} };
  lodash_isequal.exports;
  (function(module2, exports3) {
    var LARGE_ARRAY_SIZE = 200;
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
    var MAX_SAFE_INTEGER = 9007199254740991;
    var argsTag = "[object Arguments]", arrayTag = "[object Array]", asyncTag = "[object AsyncFunction]", boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", nullTag = "[object Null]", objectTag = "[object Object]", promiseTag = "[object Promise]", proxyTag = "[object Proxy]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag2 = "[object Symbol]", undefinedTag = "[object Undefined]", weakMapTag = "[object WeakMap]";
    var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
    var freeGlobal2 = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
    var freeSelf2 = typeof self == "object" && self && self.Object === Object && self;
    var root2 = freeGlobal2 || freeSelf2 || Function("return this")();
    var freeExports = exports3 && !exports3.nodeType && exports3;
    var freeModule = freeExports && true && module2 && !module2.nodeType && module2;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var freeProcess = moduleExports && freeGlobal2.process;
    var nodeUtil = function() {
      try {
        return freeProcess && freeProcess.binding && freeProcess.binding("util");
      } catch (e) {
      }
    }();
    var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    function arrayFilter(array, predicate) {
      var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
      while (++index < length) {
        var value = array[index];
        if (predicate(value, index, array)) {
          result[resIndex++] = value;
        }
      }
      return result;
    }
    function arrayPush(array, values) {
      var index = -1, length = values.length, offset = array.length;
      while (++index < length) {
        array[offset + index] = values[index];
      }
      return array;
    }
    function arraySome(array, predicate) {
      var index = -1, length = array == null ? 0 : array.length;
      while (++index < length) {
        if (predicate(array[index], index, array)) {
          return true;
        }
      }
      return false;
    }
    function baseTimes(n2, iteratee) {
      var index = -1, result = Array(n2);
      while (++index < n2) {
        result[index] = iteratee(index);
      }
      return result;
    }
    function baseUnary(func) {
      return function(value) {
        return func(value);
      };
    }
    function cacheHas(cache, key) {
      return cache.has(key);
    }
    function getValue2(object, key) {
      return object == null ? void 0 : object[key];
    }
    function mapToArray(map) {
      var index = -1, result = Array(map.size);
      map.forEach(function(value, key) {
        result[++index] = [key, value];
      });
      return result;
    }
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    function setToArray(set) {
      var index = -1, result = Array(set.size);
      set.forEach(function(value) {
        result[++index] = value;
      });
      return result;
    }
    var arrayProto = Array.prototype, funcProto = Function.prototype, objectProto2 = Object.prototype;
    var coreJsData = root2["__core-js_shared__"];
    var funcToString = funcProto.toString;
    var hasOwnProperty = objectProto2.hasOwnProperty;
    var maskSrcKey = function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
      return uid ? "Symbol(src)_1." + uid : "";
    }();
    var nativeObjectToString = objectProto2.toString;
    var reIsNative = RegExp(
      "^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
    );
    var Buffer = moduleExports ? root2.Buffer : void 0, Symbol2 = root2.Symbol, Uint8Array = root2.Uint8Array, propertyIsEnumerable = objectProto2.propertyIsEnumerable, splice = arrayProto.splice, symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
    var nativeGetSymbols = Object.getOwnPropertySymbols, nativeIsBuffer = Buffer ? Buffer.isBuffer : void 0, nativeKeys = overArg(Object.keys, Object);
    var DataView = getNative(root2, "DataView"), Map2 = getNative(root2, "Map"), Promise2 = getNative(root2, "Promise"), Set2 = getNative(root2, "Set"), WeakMap = getNative(root2, "WeakMap"), nativeCreate = getNative(Object, "create");
    var dataViewCtorString = toSource(DataView), mapCtorString = toSource(Map2), promiseCtorString = toSource(Promise2), setCtorString = toSource(Set2), weakMapCtorString = toSource(WeakMap);
    var symbolProto2 = Symbol2 ? Symbol2.prototype : void 0, symbolValueOf = symbolProto2 ? symbolProto2.valueOf : void 0;
    function Hash(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
      this.size = 0;
    }
    function hashDelete(key) {
      var result = this.has(key) && delete this.__data__[key];
      this.size -= result ? 1 : 0;
      return result;
    }
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? void 0 : result;
      }
      return hasOwnProperty.call(data, key) ? data[key] : void 0;
    }
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? data[key] !== void 0 : hasOwnProperty.call(data, key);
    }
    function hashSet(key, value) {
      var data = this.__data__;
      this.size += this.has(key) ? 0 : 1;
      data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
      return this;
    }
    Hash.prototype.clear = hashClear;
    Hash.prototype["delete"] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    function ListCache(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function listCacheClear() {
      this.__data__ = [];
      this.size = 0;
    }
    function listCacheDelete(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }
      --this.size;
      return true;
    }
    function listCacheGet(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      return index < 0 ? void 0 : data[index][1];
    }
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }
    function listCacheSet(key, value) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        ++this.size;
        data.push([key, value]);
      } else {
        data[index][1] = value;
      }
      return this;
    }
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    function MapCache(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function mapCacheClear() {
      this.size = 0;
      this.__data__ = {
        "hash": new Hash(),
        "map": new (Map2 || ListCache)(),
        "string": new Hash()
      };
    }
    function mapCacheDelete(key) {
      var result = getMapData(this, key)["delete"](key);
      this.size -= result ? 1 : 0;
      return result;
    }
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }
    function mapCacheSet(key, value) {
      var data = getMapData(this, key), size = data.size;
      data.set(key, value);
      this.size += data.size == size ? 0 : 1;
      return this;
    }
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    function SetCache(values) {
      var index = -1, length = values == null ? 0 : values.length;
      this.__data__ = new MapCache();
      while (++index < length) {
        this.add(values[index]);
      }
    }
    function setCacheAdd(value) {
      this.__data__.set(value, HASH_UNDEFINED);
      return this;
    }
    function setCacheHas(value) {
      return this.__data__.has(value);
    }
    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
    SetCache.prototype.has = setCacheHas;
    function Stack(entries) {
      var data = this.__data__ = new ListCache(entries);
      this.size = data.size;
    }
    function stackClear() {
      this.__data__ = new ListCache();
      this.size = 0;
    }
    function stackDelete(key) {
      var data = this.__data__, result = data["delete"](key);
      this.size = data.size;
      return result;
    }
    function stackGet(key) {
      return this.__data__.get(key);
    }
    function stackHas(key) {
      return this.__data__.has(key);
    }
    function stackSet(key, value) {
      var data = this.__data__;
      if (data instanceof ListCache) {
        var pairs = data.__data__;
        if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
          pairs.push([key, value]);
          this.size = ++data.size;
          return this;
        }
        data = this.__data__ = new MapCache(pairs);
      }
      data.set(key, value);
      this.size = data.size;
      return this;
    }
    Stack.prototype.clear = stackClear;
    Stack.prototype["delete"] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;
    function arrayLikeKeys(value, inherited) {
      var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
      for (var key in value) {
        if (hasOwnProperty.call(value, key) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
        (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
        isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
        isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
        isIndex(key, length)))) {
          result.push(key);
        }
      }
      return result;
    }
    function assocIndexOf(array, key) {
      var length = array.length;
      while (length--) {
        if (eq(array[length][0], key)) {
          return length;
        }
      }
      return -1;
    }
    function baseGetAllKeys(object, keysFunc, symbolsFunc) {
      var result = keysFunc(object);
      return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
    }
    function baseGetTag(value) {
      if (value == null) {
        return value === void 0 ? undefinedTag : nullTag;
      }
      return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString2(value);
    }
    function baseIsArguments(value) {
      return isObjectLike2(value) && baseGetTag(value) == argsTag;
    }
    function baseIsEqual(value, other, bitmask, customizer, stack) {
      if (value === other) {
        return true;
      }
      if (value == null || other == null || !isObjectLike2(value) && !isObjectLike2(other)) {
        return value !== value && other !== other;
      }
      return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
    }
    function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
      var objIsArr = isArray(object), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
      objTag = objTag == argsTag ? objectTag : objTag;
      othTag = othTag == argsTag ? objectTag : othTag;
      var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
      if (isSameTag && isBuffer(object)) {
        if (!isBuffer(other)) {
          return false;
        }
        objIsArr = true;
        objIsObj = false;
      }
      if (isSameTag && !objIsObj) {
        stack || (stack = new Stack());
        return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
      }
      if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
        var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
        if (objIsWrapped || othIsWrapped) {
          var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
          stack || (stack = new Stack());
          return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
        }
      }
      if (!isSameTag) {
        return false;
      }
      stack || (stack = new Stack());
      return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
    }
    function baseIsNative(value) {
      if (!isObject2(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction2(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    function baseIsTypedArray(value) {
      return isObjectLike2(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
    }
    function baseKeys(object) {
      if (!isPrototype(object)) {
        return nativeKeys(object);
      }
      var result = [];
      for (var key in Object(object)) {
        if (hasOwnProperty.call(object, key) && key != "constructor") {
          result.push(key);
        }
      }
      return result;
    }
    function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
      if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
        return false;
      }
      var stacked = stack.get(array);
      if (stacked && stack.get(other)) {
        return stacked == other;
      }
      var index = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : void 0;
      stack.set(array, other);
      stack.set(other, array);
      while (++index < arrLength) {
        var arrValue = array[index], othValue = other[index];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
        }
        if (compared !== void 0) {
          if (compared) {
            continue;
          }
          result = false;
          break;
        }
        if (seen) {
          if (!arraySome(other, function(othValue2, othIndex) {
            if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
              return seen.push(othIndex);
            }
          })) {
            result = false;
            break;
          }
        } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
          result = false;
          break;
        }
      }
      stack["delete"](array);
      stack["delete"](other);
      return result;
    }
    function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
      switch (tag) {
        case dataViewTag:
          if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
            return false;
          }
          object = object.buffer;
          other = other.buffer;
        case arrayBufferTag:
          if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
            return false;
          }
          return true;
        case boolTag:
        case dateTag:
        case numberTag:
          return eq(+object, +other);
        case errorTag:
          return object.name == other.name && object.message == other.message;
        case regexpTag:
        case stringTag:
          return object == other + "";
        case mapTag:
          var convert = mapToArray;
        case setTag:
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
          convert || (convert = setToArray);
          if (object.size != other.size && !isPartial) {
            return false;
          }
          var stacked = stack.get(object);
          if (stacked) {
            return stacked == other;
          }
          bitmask |= COMPARE_UNORDERED_FLAG;
          stack.set(object, other);
          var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
          stack["delete"](object);
          return result;
        case symbolTag2:
          if (symbolValueOf) {
            return symbolValueOf.call(object) == symbolValueOf.call(other);
          }
      }
      return false;
    }
    function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
      if (objLength != othLength && !isPartial) {
        return false;
      }
      var index = objLength;
      while (index--) {
        var key = objProps[index];
        if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
          return false;
        }
      }
      var stacked = stack.get(object);
      if (stacked && stack.get(other)) {
        return stacked == other;
      }
      var result = true;
      stack.set(object, other);
      stack.set(other, object);
      var skipCtor = isPartial;
      while (++index < objLength) {
        key = objProps[index];
        var objValue = object[key], othValue = other[key];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
        }
        if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
          result = false;
          break;
        }
        skipCtor || (skipCtor = key == "constructor");
      }
      if (result && !skipCtor) {
        var objCtor = object.constructor, othCtor = other.constructor;
        if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
          result = false;
        }
      }
      stack["delete"](object);
      stack["delete"](other);
      return result;
    }
    function getAllKeys(object) {
      return baseGetAllKeys(object, keys, getSymbols);
    }
    function getMapData(map, key) {
      var data = map.__data__;
      return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
    }
    function getNative(object, key) {
      var value = getValue2(object, key);
      return baseIsNative(value) ? value : void 0;
    }
    function getRawTag(value) {
      var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
      try {
        value[symToStringTag] = void 0;
        var unmasked = true;
      } catch (e) {
      }
      var result = nativeObjectToString.call(value);
      if (unmasked) {
        if (isOwn) {
          value[symToStringTag] = tag;
        } else {
          delete value[symToStringTag];
        }
      }
      return result;
    }
    var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
      if (object == null) {
        return [];
      }
      object = Object(object);
      return arrayFilter(nativeGetSymbols(object), function(symbol) {
        return propertyIsEnumerable.call(object, symbol);
      });
    };
    var getTag = baseGetTag;
    if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap && getTag(new WeakMap()) != weakMapTag) {
      getTag = function(value) {
        var result = baseGetTag(value), Ctor = result == objectTag ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
        if (ctorString) {
          switch (ctorString) {
            case dataViewCtorString:
              return dataViewTag;
            case mapCtorString:
              return mapTag;
            case promiseCtorString:
              return promiseTag;
            case setCtorString:
              return setTag;
            case weakMapCtorString:
              return weakMapTag;
          }
        }
        return result;
      };
    }
    function isIndex(value, length) {
      length = length == null ? MAX_SAFE_INTEGER : length;
      return !!length && (typeof value == "number" || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
    }
    function isKeyable(value) {
      var type = typeof value;
      return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
    }
    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto2;
      return value === proto;
    }
    function objectToString2(value) {
      return nativeObjectToString.call(value);
    }
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e) {
        }
        try {
          return func + "";
        } catch (e) {
        }
      }
      return "";
    }
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    var isArguments = baseIsArguments(/* @__PURE__ */ function() {
      return arguments;
    }()) ? baseIsArguments : function(value) {
      return isObjectLike2(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
    };
    var isArray = Array.isArray;
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction2(value);
    }
    var isBuffer = nativeIsBuffer || stubFalse;
    function isEqual2(value, other) {
      return baseIsEqual(value, other);
    }
    function isFunction2(value) {
      if (!isObject2(value)) {
        return false;
      }
      var tag = baseGetTag(value);
      return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
    }
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    function isObject2(value) {
      var type = typeof value;
      return value != null && (type == "object" || type == "function");
    }
    function isObjectLike2(value) {
      return value != null && typeof value == "object";
    }
    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
    function keys(object) {
      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
    }
    function stubArray() {
      return [];
    }
    function stubFalse() {
      return false;
    }
    module2.exports = isEqual2;
  })(lodash_isequal, lodash_isequal.exports);
  var lodash_isequalExports = lodash_isequal.exports;
  const isequal = /* @__PURE__ */ getDefaultExportFromCjs(lodash_isequalExports);
  function useMemo(getValue2, condition, shouldUpdate) {
    const cacheRef = React__namespace.useRef({});
    if (!("value" in cacheRef.current) || shouldUpdate(cacheRef.current.condition, condition)) {
      cacheRef.current.value = getValue2();
      cacheRef.current.condition = condition;
    }
    return cacheRef.current.value;
  }
  const zhCN = {
    save: "保存",
    confirm: "确认",
    cancel: "取消",
    done: "完成",
    noData: "暂无数据",
    placeholder: "请输入内容",
    select: "请选择",
    edit: "编辑",
    reset: "重置",
    video: {
      errorTip: "视频加载失败",
      clickRetry: "点击重试"
    },
    fixednav: {
      activeText: "收起导航",
      inactiveText: "快速导航"
    },
    infiniteloading: {
      pullRefreshText: "松开刷新",
      loadText: "加载中",
      loadMoreText: "没有更多了"
    },
    pagination: {
      prev: "上一页",
      next: "下一页"
    },
    range: {
      rangeText: "不在该区间内"
    },
    calendaritem: {
      weekdays: ["日", "一", "二", "三", "四", "五", "六"],
      end: "结束",
      start: "开始",
      confirm: "确认",
      title: "日历选择",
      week: "周",
      month: "月",
      year: "年",
      quarter: "季度",
      monthTitle: (year, month) => `${year}年${Number(month) < 10 ? `0${Number(month)}` : month}月`,
      today: "今天",
      loadPreviousMonth: "加载上一个月",
      noEarlierMonth: "没有更早月份"
    },
    shortpassword: {
      title: "请输入密码",
      description: "您使用了虚拟资产，请进行验证",
      tips: "忘记密码"
    },
    uploader: {
      list: "上传文件",
      ready: "准备完成",
      readyUpload: "准备上传",
      waitingUpload: "等待上传",
      uploading: "上传中...",
      success: "上传成功",
      error: "上传失败",
      deleteWord: "用户阻止了删除！"
    },
    countdown: {
      day: "天",
      hour: "时",
      minute: "分",
      second: "秒"
    },
    address: {
      selectRegion: "请选择地址",
      deliveryTo: "配送至",
      chooseAnotherAddress: "选择其他地址"
    },
    signature: {
      reSign: "重签",
      unsupported: "对不起，当前浏览器不支持Canvas，无法使用本控件！"
    },
    ecard: {
      chooseText: "请选择电子卡面值",
      otherValueText: "其他面值",
      placeholder: "请输入1-5000整数"
    },
    timeselect: {
      pickupTime: "取件时间"
    },
    sku: {
      buyNow: "立即购买",
      buyNumber: "购买数量",
      addToCard: "加入购物车"
    },
    skuheader: {
      skuId: "商品编号"
    },
    addresslist: {
      addAddress: "新建地址"
    },
    comment: {
      complaintsText: "我要投诉",
      additionalReview: (day) => `购买${day}天后追评`,
      additionalImages: (length) => `${length}张追评图片`
    },
    searchbar: {
      basePlaceholder: "上京东，购好物",
      text: "文本",
      test: "测试",
      title1: "基础用法",
      title2: "搜索框形状及最大长度",
      title3: "搜索框内外背景设置",
      title4: "搜索框文本设置",
      title5: "自定义图标设置",
      title6: "数据改变监听"
    },
    audio: {
      back: "快退",
      forward: "快进",
      pause: "暂停",
      start: "开始",
      mute: "静音",
      tips: "onPlayEnd事件在loop=false时才会触发"
    },
    avatarCropper: { rotate: "旋转", selectImage: "选择图片" },
    datepicker: {
      year: "年",
      month: "月",
      day: "日",
      hour: "时",
      min: "分",
      seconds: "秒"
    },
    pullToRefresh: {
      pullingText: "下拉刷新",
      canReleaseText: "松手刷新",
      refreshingText: "刷新中",
      completeText: "刷新成功"
    },
    tour: {
      prevStepText: "上一步",
      completeText: "完成",
      nextStepText: "下一步"
    },
    watermark: {
      errorCanvasTips: "当前环境不支持Canvas"
    }
  };
  const inBrowser = typeof window !== "undefined";
  function requestAniFrame() {
    if (inBrowser) {
      const _window = window;
      return _window.requestAnimationFrame || _window.webkitRequestAnimationFrame || function(callback) {
        _window.setTimeout(callback, 1e3 / 60);
      };
    }
    return (callback) => {
      setTimeout(callback, 1e3 / 60);
    };
  }
  function cancelRaf(id) {
    if (inBrowser) {
      const _window = window;
      (_window.cancelAnimationFrame || _window.webkitCancelAnimationFrame)(id);
    } else {
      clearTimeout(id);
    }
  }
  const requestAniFrame$1 = requestAniFrame();
  const classPrefix$p = "nut-configprovider";
  const defaultConfigRef = {
    current: {
      locale: zhCN
    }
  };
  const setDefaultConfig = (config2) => {
    defaultConfigRef.current = config2;
  };
  const getDefaultConfig = () => {
    return defaultConfigRef.current;
  };
  const ConfigContext = React.createContext(null);
  const useConfig = () => {
    return React.useContext(ConfigContext) ?? getDefaultConfig();
  };
  function convertThemeVarsToCSSVars(themeVars) {
    const cssVars = {};
    Object.keys(themeVars).forEach((key) => {
      cssVars[`--${kebabCase$1(key)}`] = themeVars[key];
    });
    return cssVars;
  }
  const useRtl = () => {
    const { direction } = useConfig();
    if (direction) {
      return direction === "rtl";
    }
    return inBrowser && document.dir === "rtl";
  };
  const ConfigProvider = (props) => {
    const { style, className, children, direction, ...config2 } = props;
    const mergedConfig = useMemo(
      () => {
        return {
          ...getDefaultConfig(),
          ...config2,
          direction
        };
      },
      [config2, direction],
      (prev, next) => prev.some((prevTheme, index) => {
        const nextTheme = next[index];
        return !isequal(prevTheme, nextTheme);
      })
    );
    const cssVarStyle = React.useMemo(() => {
      return convertThemeVarsToCSSVars(mergedConfig.theme || {});
    }, [mergedConfig.theme]);
    return /* @__PURE__ */ React.createElement(ConfigContext.Provider, { value: mergedConfig }, /* @__PURE__ */ React.createElement(
      "div",
      {
        className: classNames(classPrefix$p, className),
        style: {
          ...cssVarStyle,
          ...style,
          direction
        },
        dir: direction
      },
      children
    ));
  };
  ConfigProvider.displayName = "NutConfigProvider";
  const pxCheck = (value) => {
    return Number.isNaN(Number(value)) ? String(value) : `${value}px`;
  };
  const defaultProps$1r = {
    ...ComponentDefaults,
    fit: "fill",
    position: "center",
    alt: "",
    width: "",
    height: "",
    error: true,
    loading: true,
    lazy: false
  };
  const classPrefix$o = "nut-image";
  const Image$1 = (props) => {
    const {
      className,
      style,
      src,
      fit,
      position,
      alt,
      width,
      height,
      radius,
      error,
      loading,
      lazy,
      draggable,
      onClick,
      onLoad,
      onError
    } = { ...defaultProps$1r, ...props };
    const [innerLoading, setInnerLoading] = React.useState(false);
    const [isError, setIsError] = React.useState(false);
    const [complete, setComplete] = React.useState(false);
    const imgRef = React.useRef(null);
    React.useEffect(() => {
      if (imgRef.current && imgRef.current.complete && !lazy) {
        if (imgRef.current.naturalHeight === 0) {
          handleError();
        } else {
          handleLoad();
        }
      } else {
        setInnerLoading(true);
      }
    }, [imgRef]);
    React.useEffect(() => {
      setComplete(false);
    }, [src]);
    const handleLoad = () => {
      if (!complete) {
        setIsError(false);
        setInnerLoading(false);
        onLoad && onLoad();
        setComplete(true);
      }
    };
    const handleError = () => {
      if (!complete) {
        setIsError(true);
        setInnerLoading(false);
        onError && onError();
        setComplete(true);
      }
    };
    const containerStyle = {
      height: height ? pxCheck(height) : "",
      width: width ? pxCheck(width) : "",
      overflow: radius !== void 0 && radius !== null ? "hidden" : "",
      borderRadius: radius !== void 0 && radius !== null ? pxCheck(radius) : "",
      ...style
    };
    const imgStyle = {
      objectFit: fit,
      objectPosition: position,
      ...style
    };
    const observer = React.useRef(null);
    const initObserver = () => {
      const options2 = {
        threshold: [0],
        // 交会处
        rootMargin: "0px"
        // 对视口进行收缩和扩张
      };
      observer.current = new IntersectionObserver((entires, self2) => {
        entires.forEach((item) => {
          if (item.isIntersecting) {
            setTimeout(() => {
              const img = item.target;
              if (img.dataset.src) {
                img.src = img.dataset.src;
                img.removeAttribute("data-src");
              }
              resetObserver();
            }, 300);
          }
        });
      }, options2);
      observer.current.observe(imgRef.current);
    };
    const resetObserver = () => {
      observer.current.disconnect && observer.current.disconnect();
    };
    React.useEffect(() => {
      lazy && initObserver();
      return () => {
        lazy && resetObserver();
      };
    }, [lazy]);
    const imageClick = (event) => {
      onClick && onClick(event);
    };
    const renderErrorImg = React.useCallback(() => {
      if (!isError) return null;
      if (typeof error === "boolean" && error === true && !innerLoading) {
        return /* @__PURE__ */ React.createElement("div", { className: "nut-img-error" }, /* @__PURE__ */ React.createElement(p$2, null));
      }
      if (React.isValidElement(error) && !innerLoading) {
        return /* @__PURE__ */ React.createElement("div", { className: "nut-img-error" }, error);
      }
      return null;
    }, [error, isError]);
    const renderLoading = React.useCallback(() => {
      if (!loading) return null;
      if (typeof loading === "boolean" && loading === true && innerLoading) {
        return /* @__PURE__ */ React.createElement("div", { className: "nut-img-loading" }, /* @__PURE__ */ React.createElement(p$1, null));
      }
      if (React.isValidElement(loading) && innerLoading) {
        return /* @__PURE__ */ React.createElement("div", { className: "nut-img-loading" }, loading);
      }
      return null;
    }, [loading, innerLoading]);
    return /* @__PURE__ */ React.createElement(
      "div",
      {
        className: classNames(classPrefix$o, className),
        style: containerStyle,
        onClick: (e) => {
          imageClick(e);
        }
      },
      lazy ? /* @__PURE__ */ React.createElement(
        "img",
        {
          ref: imgRef,
          className: "nut-img lazyload",
          style: imgStyle,
          "data-src": src,
          alt,
          loading: "lazy",
          onLoad: handleLoad,
          onError: handleError,
          draggable
        }
      ) : /* @__PURE__ */ React.createElement(
        "img",
        {
          ref: imgRef,
          className: "nut-img",
          style: imgStyle,
          src,
          alt,
          onLoad: handleLoad,
          onError: handleError,
          draggable
        }
      ),
      renderLoading(),
      renderErrorImg()
    );
  };
  Image$1.displayName = "NutImage";
  function _extends$4() {
    return _extends$4 = Object.assign ? Object.assign.bind() : function(n2) {
      for (var e = 1; e < arguments.length; e++) {
        var t = arguments[e];
        for (var r in t) ({}).hasOwnProperty.call(t, r) && (n2[r] = t[r]);
      }
      return n2;
    }, _extends$4.apply(null, arguments);
  }
  function _objectWithoutPropertiesLoose$3(r, e) {
    if (null == r) return {};
    var t = {};
    for (var n2 in r) if ({}.hasOwnProperty.call(r, n2)) {
      if (e.includes(n2)) continue;
      t[n2] = r[n2];
    }
    return t;
  }
  function _setPrototypeOf$1(t, e) {
    return _setPrototypeOf$1 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t2, e2) {
      return t2.__proto__ = e2, t2;
    }, _setPrototypeOf$1(t, e);
  }
  function _inheritsLoose$1(t, o) {
    t.prototype = Object.create(o.prototype), t.prototype.constructor = t, _setPrototypeOf$1(t, o);
  }
  function hasClass(element, className) {
    if (element.classList) return !!className && element.classList.contains(className);
    return (" " + (element.className.baseVal || element.className) + " ").indexOf(" " + className + " ") !== -1;
  }
  function addClass(element, className) {
    if (element.classList) element.classList.add(className);
    else if (!hasClass(element, className)) if (typeof element.className === "string") element.className = element.className + " " + className;
    else element.setAttribute("class", (element.className && element.className.baseVal || "") + " " + className);
  }
  function replaceClassName(origClass, classToRemove) {
    return origClass.replace(new RegExp("(^|\\s)" + classToRemove + "(?:\\s|$)", "g"), "$1").replace(/\s+/g, " ").replace(/^\s*|\s*$/g, "");
  }
  function removeClass$1(element, className) {
    if (element.classList) {
      element.classList.remove(className);
    } else if (typeof element.className === "string") {
      element.className = replaceClassName(element.className, className);
    } else {
      element.setAttribute("class", replaceClassName(element.className && element.className.baseVal || "", className));
    }
  }
  const config$2 = {
    disabled: false
  };
  const TransitionGroupContext = React.createContext(null);
  var forceReflow = function forceReflow2(node) {
    return node.scrollTop;
  };
  var UNMOUNTED = "unmounted";
  var EXITED = "exited";
  var ENTERING = "entering";
  var ENTERED = "entered";
  var EXITING = "exiting";
  var Transition = /* @__PURE__ */ function(_React$Component) {
    _inheritsLoose$1(Transition2, _React$Component);
    function Transition2(props, context) {
      var _this;
      _this = _React$Component.call(this, props, context) || this;
      var parentGroup = context;
      var appear = parentGroup && !parentGroup.isMounting ? props.enter : props.appear;
      var initialStatus;
      _this.appearStatus = null;
      if (props.in) {
        if (appear) {
          initialStatus = EXITED;
          _this.appearStatus = ENTERING;
        } else {
          initialStatus = ENTERED;
        }
      } else {
        if (props.unmountOnExit || props.mountOnEnter) {
          initialStatus = UNMOUNTED;
        } else {
          initialStatus = EXITED;
        }
      }
      _this.state = {
        status: initialStatus
      };
      _this.nextCallback = null;
      return _this;
    }
    Transition2.getDerivedStateFromProps = function getDerivedStateFromProps(_ref, prevState) {
      var nextIn = _ref.in;
      if (nextIn && prevState.status === UNMOUNTED) {
        return {
          status: EXITED
        };
      }
      return null;
    };
    var _proto = Transition2.prototype;
    _proto.componentDidMount = function componentDidMount() {
      this.updateStatus(true, this.appearStatus);
    };
    _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
      var nextStatus = null;
      if (prevProps !== this.props) {
        var status = this.state.status;
        if (this.props.in) {
          if (status !== ENTERING && status !== ENTERED) {
            nextStatus = ENTERING;
          }
        } else {
          if (status === ENTERING || status === ENTERED) {
            nextStatus = EXITING;
          }
        }
      }
      this.updateStatus(false, nextStatus);
    };
    _proto.componentWillUnmount = function componentWillUnmount() {
      this.cancelNextCallback();
    };
    _proto.getTimeouts = function getTimeouts() {
      var timeout2 = this.props.timeout;
      var exit, enter, appear;
      exit = enter = appear = timeout2;
      if (timeout2 != null && typeof timeout2 !== "number") {
        exit = timeout2.exit;
        enter = timeout2.enter;
        appear = timeout2.appear !== void 0 ? timeout2.appear : enter;
      }
      return {
        exit,
        enter,
        appear
      };
    };
    _proto.updateStatus = function updateStatus(mounting, nextStatus) {
      if (mounting === void 0) {
        mounting = false;
      }
      if (nextStatus !== null) {
        this.cancelNextCallback();
        if (nextStatus === ENTERING) {
          if (this.props.unmountOnExit || this.props.mountOnEnter) {
            var node = this.props.nodeRef ? this.props.nodeRef.current : ReactDOM.findDOMNode(this);
            if (node) forceReflow(node);
          }
          this.performEnter(mounting);
        } else {
          this.performExit();
        }
      } else if (this.props.unmountOnExit && this.state.status === EXITED) {
        this.setState({
          status: UNMOUNTED
        });
      }
    };
    _proto.performEnter = function performEnter(mounting) {
      var _this2 = this;
      var enter = this.props.enter;
      var appearing = this.context ? this.context.isMounting : mounting;
      var _ref2 = this.props.nodeRef ? [appearing] : [ReactDOM.findDOMNode(this), appearing], maybeNode = _ref2[0], maybeAppearing = _ref2[1];
      var timeouts2 = this.getTimeouts();
      var enterTimeout = appearing ? timeouts2.appear : timeouts2.enter;
      if (!mounting && !enter || config$2.disabled) {
        this.safeSetState({
          status: ENTERED
        }, function() {
          _this2.props.onEntered(maybeNode);
        });
        return;
      }
      this.props.onEnter(maybeNode, maybeAppearing);
      this.safeSetState({
        status: ENTERING
      }, function() {
        _this2.props.onEntering(maybeNode, maybeAppearing);
        _this2.onTransitionEnd(enterTimeout, function() {
          _this2.safeSetState({
            status: ENTERED
          }, function() {
            _this2.props.onEntered(maybeNode, maybeAppearing);
          });
        });
      });
    };
    _proto.performExit = function performExit() {
      var _this3 = this;
      var exit = this.props.exit;
      var timeouts2 = this.getTimeouts();
      var maybeNode = this.props.nodeRef ? void 0 : ReactDOM.findDOMNode(this);
      if (!exit || config$2.disabled) {
        this.safeSetState({
          status: EXITED
        }, function() {
          _this3.props.onExited(maybeNode);
        });
        return;
      }
      this.props.onExit(maybeNode);
      this.safeSetState({
        status: EXITING
      }, function() {
        _this3.props.onExiting(maybeNode);
        _this3.onTransitionEnd(timeouts2.exit, function() {
          _this3.safeSetState({
            status: EXITED
          }, function() {
            _this3.props.onExited(maybeNode);
          });
        });
      });
    };
    _proto.cancelNextCallback = function cancelNextCallback() {
      if (this.nextCallback !== null) {
        this.nextCallback.cancel();
        this.nextCallback = null;
      }
    };
    _proto.safeSetState = function safeSetState(nextState, callback) {
      callback = this.setNextCallback(callback);
      this.setState(nextState, callback);
    };
    _proto.setNextCallback = function setNextCallback(callback) {
      var _this4 = this;
      var active = true;
      this.nextCallback = function(event) {
        if (active) {
          active = false;
          _this4.nextCallback = null;
          callback(event);
        }
      };
      this.nextCallback.cancel = function() {
        active = false;
      };
      return this.nextCallback;
    };
    _proto.onTransitionEnd = function onTransitionEnd(timeout2, handler) {
      this.setNextCallback(handler);
      var node = this.props.nodeRef ? this.props.nodeRef.current : ReactDOM.findDOMNode(this);
      var doesNotHaveTimeoutOrListener = timeout2 == null && !this.props.addEndListener;
      if (!node || doesNotHaveTimeoutOrListener) {
        setTimeout(this.nextCallback, 0);
        return;
      }
      if (this.props.addEndListener) {
        var _ref3 = this.props.nodeRef ? [this.nextCallback] : [node, this.nextCallback], maybeNode = _ref3[0], maybeNextCallback = _ref3[1];
        this.props.addEndListener(maybeNode, maybeNextCallback);
      }
      if (timeout2 != null) {
        setTimeout(this.nextCallback, timeout2);
      }
    };
    _proto.render = function render2() {
      var status = this.state.status;
      if (status === UNMOUNTED) {
        return null;
      }
      var _this$props = this.props, children = _this$props.children;
      _this$props.in;
      _this$props.mountOnEnter;
      _this$props.unmountOnExit;
      _this$props.appear;
      _this$props.enter;
      _this$props.exit;
      _this$props.timeout;
      _this$props.addEndListener;
      _this$props.onEnter;
      _this$props.onEntering;
      _this$props.onEntered;
      _this$props.onExit;
      _this$props.onExiting;
      _this$props.onExited;
      _this$props.nodeRef;
      var childProps = _objectWithoutPropertiesLoose$3(_this$props, ["children", "in", "mountOnEnter", "unmountOnExit", "appear", "enter", "exit", "timeout", "addEndListener", "onEnter", "onEntering", "onEntered", "onExit", "onExiting", "onExited", "nodeRef"]);
      return (
        // allows for nested Transitions
        /* @__PURE__ */ React.createElement(TransitionGroupContext.Provider, {
          value: null
        }, typeof children === "function" ? children(status, childProps) : React.cloneElement(React.Children.only(children), childProps))
      );
    };
    return Transition2;
  }(React.Component);
  Transition.contextType = TransitionGroupContext;
  Transition.propTypes = {};
  function noop$2() {
  }
  Transition.defaultProps = {
    in: false,
    mountOnEnter: false,
    unmountOnExit: false,
    appear: false,
    enter: true,
    exit: true,
    onEnter: noop$2,
    onEntering: noop$2,
    onEntered: noop$2,
    onExit: noop$2,
    onExiting: noop$2,
    onExited: noop$2
  };
  Transition.UNMOUNTED = UNMOUNTED;
  Transition.EXITED = EXITED;
  Transition.ENTERING = ENTERING;
  Transition.ENTERED = ENTERED;
  Transition.EXITING = EXITING;
  var _addClass = function addClass$1(node, classes) {
    return node && classes && classes.split(" ").forEach(function(c6) {
      return addClass(node, c6);
    });
  };
  var removeClass = function removeClass2(node, classes) {
    return node && classes && classes.split(" ").forEach(function(c6) {
      return removeClass$1(node, c6);
    });
  };
  var CSSTransition = /* @__PURE__ */ function(_React$Component) {
    _inheritsLoose$1(CSSTransition2, _React$Component);
    function CSSTransition2() {
      var _this;
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
      _this.appliedClasses = {
        appear: {},
        enter: {},
        exit: {}
      };
      _this.onEnter = function(maybeNode, maybeAppearing) {
        var _this$resolveArgument = _this.resolveArguments(maybeNode, maybeAppearing), node = _this$resolveArgument[0], appearing = _this$resolveArgument[1];
        _this.removeClasses(node, "exit");
        _this.addClass(node, appearing ? "appear" : "enter", "base");
        if (_this.props.onEnter) {
          _this.props.onEnter(maybeNode, maybeAppearing);
        }
      };
      _this.onEntering = function(maybeNode, maybeAppearing) {
        var _this$resolveArgument2 = _this.resolveArguments(maybeNode, maybeAppearing), node = _this$resolveArgument2[0], appearing = _this$resolveArgument2[1];
        var type = appearing ? "appear" : "enter";
        _this.addClass(node, type, "active");
        if (_this.props.onEntering) {
          _this.props.onEntering(maybeNode, maybeAppearing);
        }
      };
      _this.onEntered = function(maybeNode, maybeAppearing) {
        var _this$resolveArgument3 = _this.resolveArguments(maybeNode, maybeAppearing), node = _this$resolveArgument3[0], appearing = _this$resolveArgument3[1];
        var type = appearing ? "appear" : "enter";
        _this.removeClasses(node, type);
        _this.addClass(node, type, "done");
        if (_this.props.onEntered) {
          _this.props.onEntered(maybeNode, maybeAppearing);
        }
      };
      _this.onExit = function(maybeNode) {
        var _this$resolveArgument4 = _this.resolveArguments(maybeNode), node = _this$resolveArgument4[0];
        _this.removeClasses(node, "appear");
        _this.removeClasses(node, "enter");
        _this.addClass(node, "exit", "base");
        if (_this.props.onExit) {
          _this.props.onExit(maybeNode);
        }
      };
      _this.onExiting = function(maybeNode) {
        var _this$resolveArgument5 = _this.resolveArguments(maybeNode), node = _this$resolveArgument5[0];
        _this.addClass(node, "exit", "active");
        if (_this.props.onExiting) {
          _this.props.onExiting(maybeNode);
        }
      };
      _this.onExited = function(maybeNode) {
        var _this$resolveArgument6 = _this.resolveArguments(maybeNode), node = _this$resolveArgument6[0];
        _this.removeClasses(node, "exit");
        _this.addClass(node, "exit", "done");
        if (_this.props.onExited) {
          _this.props.onExited(maybeNode);
        }
      };
      _this.resolveArguments = function(maybeNode, maybeAppearing) {
        return _this.props.nodeRef ? [_this.props.nodeRef.current, maybeNode] : [maybeNode, maybeAppearing];
      };
      _this.getClassNames = function(type) {
        var classNames2 = _this.props.classNames;
        var isStringClassNames = typeof classNames2 === "string";
        var prefix2 = isStringClassNames && classNames2 ? classNames2 + "-" : "";
        var baseClassName = isStringClassNames ? "" + prefix2 + type : classNames2[type];
        var activeClassName = isStringClassNames ? baseClassName + "-active" : classNames2[type + "Active"];
        var doneClassName = isStringClassNames ? baseClassName + "-done" : classNames2[type + "Done"];
        return {
          baseClassName,
          activeClassName,
          doneClassName
        };
      };
      return _this;
    }
    var _proto = CSSTransition2.prototype;
    _proto.addClass = function addClass2(node, type, phase) {
      var className = this.getClassNames(type)[phase + "ClassName"];
      var _this$getClassNames = this.getClassNames("enter"), doneClassName = _this$getClassNames.doneClassName;
      if (type === "appear" && phase === "done" && doneClassName) {
        className += " " + doneClassName;
      }
      if (phase === "active") {
        if (node) forceReflow(node);
      }
      if (className) {
        this.appliedClasses[type][phase] = className;
        _addClass(node, className);
      }
    };
    _proto.removeClasses = function removeClasses(node, type) {
      var _this$appliedClasses$ = this.appliedClasses[type], baseClassName = _this$appliedClasses$.base, activeClassName = _this$appliedClasses$.active, doneClassName = _this$appliedClasses$.done;
      this.appliedClasses[type] = {};
      if (baseClassName) {
        removeClass(node, baseClassName);
      }
      if (activeClassName) {
        removeClass(node, activeClassName);
      }
      if (doneClassName) {
        removeClass(node, doneClassName);
      }
    };
    _proto.render = function render2() {
      var _this$props = this.props;
      _this$props.classNames;
      var props = _objectWithoutPropertiesLoose$3(_this$props, ["classNames"]);
      return /* @__PURE__ */ React.createElement(Transition, _extends$4({}, props, {
        onEnter: this.onEnter,
        onEntered: this.onEntered,
        onEntering: this.onEntering,
        onExit: this.onExit,
        onExiting: this.onExiting,
        onExited: this.onExited
      }));
    };
    return CSSTransition2;
  }(React.Component);
  CSSTransition.defaultProps = {
    classNames: ""
  };
  CSSTransition.propTypes = {};
  const MIN_DISTANCE = 10;
  function getDirection(x, y) {
    if (x > y && x > MIN_DISTANCE) {
      return "horizontal";
    }
    if (y > x && y > MIN_DISTANCE) {
      return "vertical";
    }
    return "";
  }
  function useTouch() {
    const startX = React.useRef(0);
    const startY = React.useRef(0);
    const deltaX = React.useRef(0);
    const deltaY = React.useRef(0);
    const delta = React.useRef(0);
    const offsetX = React.useRef(0);
    const offsetY = React.useRef(0);
    const direction = React.useRef("");
    const last = React.useRef(false);
    const velocity = React.useRef(0);
    const touchTime = React.useRef(Date.now());
    const isVertical = () => direction.current === "vertical";
    const isHorizontal = () => direction.current === "horizontal";
    const reset = () => {
      touchTime.current = Date.now();
      deltaX.current = 0;
      deltaY.current = 0;
      offsetX.current = 0;
      offsetY.current = 0;
      delta.current = 0;
      direction.current = "";
      last.current = false;
    };
    const start2 = (event) => {
      reset();
      touchTime.current = Date.now();
      startX.current = event.touches[0].clientX;
      startY.current = event.touches[0].clientY;
    };
    const move = (event) => {
      const touch = event.touches[0];
      deltaX.current = touch.clientX < 0 ? 0 : touch.clientX - startX.current;
      deltaY.current = touch.clientY - startY.current;
      offsetX.current = Math.abs(deltaX.current);
      offsetY.current = Math.abs(deltaY.current);
      delta.current = isVertical() ? deltaY.current : deltaX.current;
      if (!direction.current) {
        direction.current = getDirection(offsetX.current, offsetY.current);
      }
    };
    const end = (event) => {
      last.current = true;
      velocity.current = Math.sqrt(deltaX.current ** 2 + deltaY.current ** 2) / (Date.now() - touchTime.current);
    };
    return {
      end,
      move,
      start: start2,
      reset,
      touchTime,
      startX,
      startY,
      deltaX,
      deltaY,
      delta,
      offsetX,
      offsetY,
      direction,
      isVertical,
      isHorizontal,
      last
    };
  }
  const canUseDom = !!(typeof window !== "undefined" && typeof document !== "undefined" && window.document && window.document.createElement);
  const defaultRoot = canUseDom ? window : void 0;
  const overflowStylePatterns = ["scroll", "auto", "overlay"];
  function isElement(node) {
    const ELEMENT_NODE_TYPE = 1;
    return node.nodeType === ELEMENT_NODE_TYPE;
  }
  function getScrollParent(el, root2 = defaultRoot) {
    let node = el;
    while (node && node !== root2 && isElement(node)) {
      if (node === document.body) {
        return root2;
      }
      const { overflowY } = window.getComputedStyle(node);
      if (overflowStylePatterns.includes(overflowY) && node.scrollHeight > node.clientHeight) {
        return node;
      }
      node = node.parentNode;
    }
    return root2;
  }
  function getAllScrollableParents(element, scrollableParents = []) {
    if (!element) {
      return scrollableParents;
    }
    const isScrollable = element.scrollHeight > element.clientHeight || element.scrollWidth > element.clientWidth;
    if (isScrollable) {
      if (element.nodeName === "HTML") {
        scrollableParents.push(document);
      } else {
        scrollableParents.push(element);
      }
    }
    return getAllScrollableParents(element.parentElement, scrollableParents);
  }
  let passiveSupported = false;
  if (canUseDom) {
    try {
      const opts = Object.defineProperty({}, "passive", {
        get() {
          passiveSupported = true;
        }
      });
      window.addEventListener("test-passive-supported", null, opts);
    } catch (e) {
      console.log(e);
    }
  }
  let totalLockCount = 0;
  const BODY_LOCK_CLASS = "nut-overflow-hidden";
  function getScrollableElement(el) {
    let current = el == null ? void 0 : el.parentElement;
    while (current) {
      if (current.clientHeight < current.scrollHeight) {
        return current;
      }
      current = current.parentElement;
    }
    return null;
  }
  function useLockScroll(rootRef, shouldLock) {
    const touch = useTouch();
    const onTouchMove = (event) => {
      touch.move(event);
      const direction = touch.deltaY.current > 0 ? "10" : "01";
      const el = getScrollParent(
        event.target,
        rootRef.current
      );
      if (!el) return;
      if (shouldLock === "strict") {
        const scrollableParent = getScrollableElement(event.target);
        if (scrollableParent === document.body || scrollableParent === document.documentElement) {
          event.preventDefault();
          return;
        }
      }
      const { scrollHeight, offsetHeight, scrollTop } = el;
      let status = "11";
      if (scrollTop === 0) {
        status = offsetHeight >= scrollHeight ? "00" : "01";
      } else if (scrollTop + offsetHeight >= scrollHeight) {
        status = "10";
      }
      if (status !== "11" && touch.isVertical() && !(parseInt(status, 2) & parseInt(direction, 2))) {
        if (event.cancelable) {
          event.preventDefault();
        }
      }
    };
    const lock = () => {
      document.addEventListener("touchstart", touch.start);
      document.addEventListener(
        "touchmove",
        onTouchMove,
        passiveSupported ? { passive: false } : false
      );
      if (!totalLockCount) {
        document.body.classList.add(BODY_LOCK_CLASS);
      }
      totalLockCount++;
    };
    const unlock = () => {
      if (totalLockCount) {
        document.removeEventListener("touchstart", touch.start);
        document.removeEventListener("touchmove", onTouchMove);
        totalLockCount--;
        if (!totalLockCount) {
          document.body.classList.remove(BODY_LOCK_CLASS);
        }
      }
    };
    React.useEffect(() => {
      if (shouldLock) {
        lock();
        return () => {
          unlock();
        };
      }
    }, [shouldLock]);
  }
  const defaultOverlayProps = {
    ...ComponentDefaults,
    zIndex: 1e3,
    duration: 300,
    closeOnOverlayClick: true,
    visible: false,
    lockScroll: true,
    onClick: (event) => {
    }
  };
  const Overlay = (props) => {
    const {
      children,
      zIndex,
      duration,
      className,
      closeOnOverlayClick,
      visible,
      lockScroll,
      style,
      afterShow,
      afterClose,
      onClick,
      ...rest
    } = {
      ...defaultOverlayProps,
      ...props
    };
    const classPrefix2 = `nut-overlay`;
    const [innerVisible, setInnerVisible] = React.useState(visible);
    const nodeRef = React.useRef(null);
    React.useEffect(() => {
      if (visible) {
        setInnerVisible(true);
      } else {
        setInnerVisible(false);
      }
    }, [visible]);
    const shouldLockScroll = !innerVisible ? false : lockScroll;
    useLockScroll(nodeRef, shouldLockScroll);
    const classes = classNames(classPrefix2, className);
    const styles = {
      ...style
    };
    const handleClick2 = (e) => {
      if (closeOnOverlayClick) {
        onClick && onClick(e);
      }
    };
    const onHandleOpened = (e) => {
      afterShow && afterShow();
    };
    const onHandleClosed = (e) => {
      afterClose && afterClose();
    };
    return /* @__PURE__ */ React.createElement(
      CSSTransition,
      {
        nodeRef,
        classNames: `${classPrefix2}-slide`,
        unmountOnExit: true,
        timeout: duration,
        in: innerVisible,
        onEntered: onHandleOpened,
        onExited: onHandleClosed
      },
      /* @__PURE__ */ React.createElement(
        "div",
        {
          ref: nodeRef,
          className: classes,
          style: styles,
          ...rest,
          onClick: handleClick2
        },
        children
      )
    );
  };
  Overlay.displayName = "NutOverlay";
  const DataContext$1 = React.createContext({});
  const defaultProps$1q = {
    ...ComponentDefaults,
    span: "24",
    offset: "0",
    gutter: "0"
  };
  const Col = (props) => {
    const { className, style, span, offset, children, onClick } = {
      ...defaultProps$1q,
      ...props
    };
    const [colName, setColName] = React.useState("");
    const [colStyle, setColStyle] = React.useState({});
    const { gutter } = React.useContext(DataContext$1);
    const classs = () => {
      const prefixCls2 = "nut-col";
      return `${prefixCls2} ${prefixCls2}-${span} ${gutter ? `${prefixCls2}-gutter` : ""} ${prefixCls2}-offset-${offset}`;
    };
    const getStyle = () => {
      const style2 = {};
      style2.paddingLeft = `${gutter / 2}px`;
      style2.paddingRight = `${gutter / 2}px`;
      return style2;
    };
    React.useEffect(() => {
      setColName(classs);
      setColStyle(getStyle);
    }, [span, offset, gutter]);
    return /* @__PURE__ */ React.createElement(
      "div",
      {
        className: classNames(colName, className),
        style: { ...style, ...colStyle },
        onClick: (e) => {
          onClick && onClick(e, "col");
        }
      },
      children
    );
  };
  Col.displayName = "NutCol";
  const defaultProps$1p = {
    ...ComponentDefaults,
    contentPosition: "center",
    direction: "horizontal"
  };
  const classPrefix$n = `nut-divider`;
  const Divider = (props) => {
    const { children, contentPosition, style, className, direction, ...rest } = {
      ...defaultProps$1p,
      ...props
    };
    const classes = direction === "horizontal" ? classNames({
      [`${classPrefix$n}`]: true,
      [`${classPrefix$n}-center`]: children,
      [`${classPrefix$n}-left`]: contentPosition === "left",
      [`${classPrefix$n}-right`]: contentPosition === "right",
      [`${classPrefix$n}-hairline`]: true
    }) : classNames({
      [`${classPrefix$n}`]: true,
      [`${classPrefix$n}-vertical`]: direction === "vertical"
    });
    return /* @__PURE__ */ React.createElement("div", { className: `${classes} ${className || ""}`, style, ...rest }, children);
  };
  Divider.displayName = "NutDivider";
  const gridContext = {
    onClick: (item, index) => {
    }
  };
  const GridContext = React.createContext(gridContext);
  const defaultProps$1o = {
    text: "",
    columns: 4,
    gap: 0,
    center: true,
    square: false,
    reverse: false,
    direction: "vertical"
  };
  const GridItem = (props) => {
    const {
      children,
      style,
      columns,
      index,
      gap,
      square,
      text,
      center,
      reverse,
      direction,
      className,
      onClick,
      ...rest
    } = {
      ...defaultProps$1o,
      ...props
    };
    const classPrefix2 = "nut-grid-item";
    const classes = classNames(classPrefix2, className);
    const context = React.useContext(GridContext);
    const rootStyle = () => {
      const styles = {
        flexBasis: `${100 / +columns}%`,
        ...style
      };
      if (square) {
        styles.paddingTop = `${100 / +columns}%`;
      } else if (gap) {
        styles.paddingRight = pxCheck(gap);
        if (index >= Number(columns)) {
          styles.marginTop = pxCheck(gap);
        }
      }
      return styles;
    };
    const contentClass = () => {
      return classNames(`${classPrefix2}-content`, {
        [`${classPrefix2}-content-border`]: true,
        [`${classPrefix2}-content-surround`]: gap,
        [`${classPrefix2}-content-center`]: center,
        [`${classPrefix2}-content-square`]: square,
        [`${classPrefix2}-content-reverse`]: reverse,
        [`${classPrefix2}-content-${direction}`]: !!direction
      });
    };
    const handleClick2 = (e) => {
      onClick && onClick(e);
      context.onClick && context.onClick(
        {
          text,
          index,
          columns,
          gap,
          center,
          square,
          reverse,
          direction
        },
        index
      );
    };
    return /* @__PURE__ */ React.createElement(
      "div",
      {
        className: classes,
        style: rootStyle(),
        ...rest,
        onClick: handleClick2
      },
      /* @__PURE__ */ React.createElement("div", { className: contentClass() }, children && /* @__PURE__ */ React.createElement(React.Fragment, null, children), text && /* @__PURE__ */ React.createElement("div", { className: `${classPrefix2}-text` }, text))
    );
  };
  GridItem.displayName = "NutGridItem";
  const defaultProps$1n = {
    columns: 4,
    gap: 0,
    center: true,
    square: false,
    reverse: false,
    direction: "vertical"
  };
  const Grid = (props) => {
    const {
      children,
      columns,
      gap,
      center,
      square,
      reverse,
      direction,
      style,
      className,
      onClick,
      ...rest
    } = { ...defaultProps$1n, ...props };
    const childrenDom = React.Children.toArray(children);
    const classPrefix2 = "nut-grid";
    const rootClass = () => {
      return classNames(
        classPrefix2,
        {
          [`${classPrefix2}-border`]: !gap
        },
        className
      );
    };
    const rootStyle = () => {
      let styleSelf = {};
      if (style) {
        styleSelf = style;
      }
      if (gap) {
        styleSelf.paddingLeft = pxCheck(gap);
      }
      return styleSelf;
    };
    return /* @__PURE__ */ React.createElement("div", { className: rootClass(), style: rootStyle(), ...rest }, /* @__PURE__ */ React.createElement(GridContext.Provider, { value: { onClick } }, childrenDom.map((item, idex) => {
      return React.cloneElement(item, {
        index: idex,
        columns,
        center,
        gap,
        square,
        reverse,
        direction
      });
    })));
  };
  Grid.displayName = "NutGrid";
  Grid.Item = GridItem;
  const Layout = () => {
    return /* @__PURE__ */ React.createElement("div", { className: "nut-layout" }, "Layout");
  };
  Layout.displayName = "NutLayout";
  const classPrefix$m = "nut-row";
  const defaultProps$1m = {
    ...ComponentDefaults,
    type: "",
    justify: "start",
    align: "flex-start",
    wrap: "nowrap",
    gutter: "0"
  };
  const Row = (props) => {
    const {
      className,
      style,
      children,
      type,
      justify,
      align,
      wrap,
      gutter,
      onClick
    } = {
      ...defaultProps$1m,
      ...props
    };
    const getClass = (prefix2, type22) => {
      const classType = type22 ? `nut-row-${prefix2}-${type22}` : "";
      const className2 = prefix2 ? classType : `nut-row-${type22}`;
      return className2;
    };
    const getClasses = () => {
      return classNames(
        classPrefix$m,
        getClass("", type),
        getClass("justify", justify),
        getClass("align", align),
        getClass("flex", wrap)
      );
    };
    const parentRow = {
      gutter
    };
    return /* @__PURE__ */ React.createElement(DataContext$1.Provider, { value: parentRow }, React.createElement(
      "div",
      {
        className: classNames(getClasses(), className),
        style,
        onClick: (e) => {
          onClick && onClick(e, "row");
        }
      },
      children
    ));
  };
  Row.displayName = "NutRow";
  const prefixCls$1 = "nut-space";
  const defaultProps$1l = {
    direction: "horizontal"
  };
  const Space = (props) => {
    const { className, style, children, wrap, align, direction, justify } = {
      ...defaultProps$1l,
      ...props
    };
    const cls = classNames(
      prefixCls$1,
      wrap && `${prefixCls$1}-wrap`,
      direction && `${prefixCls$1}-${direction}`,
      align && `${prefixCls$1}-align-${align}`,
      justify && `${prefixCls$1}-justify-${justify}`,
      className
    );
    return /* @__PURE__ */ React.createElement("div", { className: cls, style }, React.Children.map(children, (child) => {
      return child !== null && child !== void 0 && /* @__PURE__ */ React.createElement("div", { className: `${prefixCls$1}-item` }, child);
    }));
  };
  Space.displayName = "NutSpace";
  function isWindow(val) {
    return val === window;
  }
  const getRect = (elementRef) => {
    const element = elementRef;
    if (isWindow(element)) {
      const width = element.innerWidth;
      const height = element.innerHeight;
      return {
        top: 0,
        left: 0,
        right: width,
        bottom: height,
        width,
        height
      };
    }
    if (element && element.getBoundingClientRect) {
      return element.getBoundingClientRect();
    }
    return {
      top: 0,
      left: 0,
      right: 0,
      bottom: 0,
      width: 0,
      height: 0
    };
  };
  function useWatch$1(dep, callback, config2 = { immediate: false }) {
    const { immediate } = config2;
    const prev = React.useRef();
    const inited = React.useRef(false);
    const stop2 = React.useRef(false);
    React.useEffect(() => {
      const execute = () => callback(prev.current);
      if (!stop2.current) {
        if (!inited.current) {
          inited.current = true;
          if (immediate) {
            execute();
          }
        } else {
          execute();
        }
        prev.current = dep;
      }
    }, [dep]);
    return () => {
      stop2.current = true;
    };
  }
  const defaultProps$1k = {
    ...ComponentDefaults,
    position: "top",
    threshold: 0,
    zIndex: 900
  };
  const classPrefix$l = "nut-sticky";
  const Sticky = (props) => {
    const {
      position,
      zIndex,
      children,
      container,
      style,
      className,
      threshold,
      onChange,
      ...rest
    } = { ...defaultProps$1k, ...props };
    const stickyRef = React.useRef(null);
    const rootRef = React.useRef(null);
    const [isFixed, setIsFixed] = React.useState(false);
    const [stickyStyle, setStickyStyle] = React.useState({
      [position]: `${threshold}px`,
      zIndex
    });
    React.useEffect(() => {
      setStickyStyle({ ...stickyStyle, [position]: `${threshold}px`, zIndex });
    }, [threshold, position, zIndex]);
    const [rootStyle, setRootStyle] = React.useState({});
    const getElement = React.useCallback(() => {
      return getScrollParent(rootRef.current);
    }, []);
    React.useEffect(() => {
      if (position === "top") return;
      const containerEle = container && container.current;
      const rootEle = rootRef.current;
      const stickyEle = stickyRef.current;
      if (!rootEle && !containerEle) return;
      const rootRect = getRect(rootEle);
      const containerRect = getRect(containerEle);
      const clientHeight = document.documentElement.clientHeight;
      const stickyRect = getRect(stickyEle);
      let fixed = clientHeight - threshold < rootRect.bottom;
      if (containerEle) {
        fixed = containerRect.bottom > clientHeight - threshold - stickyRect.height && clientHeight - threshold - stickyRect.height > containerRect.top;
      }
      const defaultPostVal = fixed ? "fixed" : "inherit";
      setStickyStyle((prev) => {
        return {
          ...prev,
          position: defaultPostVal
        };
      });
      setIsFixed(fixed);
    }, [position, container, threshold]);
    const handleScroll = React.useCallback(() => {
      const containerEle = container && container.current;
      const rootEle = rootRef.current;
      const stickyEle = stickyRef.current;
      if (!rootEle && !containerEle) return;
      const rootRect = getRect(rootEle);
      const stickyRect = getRect(stickyEle);
      const containerRect = getRect(containerEle);
      if (rootRect.height) {
        setRootStyle((prev) => ({
          ...prev,
          height: rootRect.height
        }));
      }
      const getFixed = () => {
        let fixed2 = false;
        if (position === "top") {
          fixed2 = containerEle ? threshold > rootRect.top && containerRect.bottom > 0 : threshold > rootRect.top;
        } else {
          const clientHeight = document.documentElement.clientHeight;
          fixed2 = containerEle ? containerRect.bottom > 0 && clientHeight - threshold - stickyRect.height > containerRect.top : clientHeight - threshold < rootRect.bottom;
        }
        return {
          position: fixed2 ? "fixed" : "inherit",
          fixed: fixed2
        };
      };
      const getTransform = () => {
        if (position === "top" && containerEle) {
          const diff = containerRect.bottom - threshold - stickyRect.height;
          const transform = diff < 0 ? diff : 0;
          return { transform: `translate3d(0, ${transform}px, 0)` };
        }
        if (position === "bottom" && containerEle) {
          const clientHeight = document.documentElement.clientHeight;
          const diff = containerRect.bottom - (clientHeight - threshold);
          const transform = diff < 0 ? diff : 0;
          return { transform: `translate3d(0, ${transform}px, 0)` };
        }
        return {};
      };
      const fixed = getFixed();
      setStickyStyle((prev) => {
        return {
          ...prev,
          ...getTransform(),
          position: fixed.position
        };
      });
      setIsFixed(fixed.fixed);
    }, [position, threshold, container]);
    useWatch$1(isFixed, () => {
      onChange && onChange(isFixed);
    });
    React.useEffect(() => {
      const el = getElement();
      el == null ? void 0 : el.addEventListener("scroll", handleScroll, false);
      return () => {
        el == null ? void 0 : el.removeEventListener("scroll", handleScroll);
      };
    }, [getElement, handleScroll]);
    return /* @__PURE__ */ React.createElement(
      "div",
      {
        ref: rootRef,
        style: { ...style, ...rootStyle },
        className: classNames(classPrefix$l, className),
        ...rest
      },
      /* @__PURE__ */ React.createElement("div", { className: "nut-sticky-box", ref: stickyRef, style: stickyStyle }, children)
    );
  };
  Sticky.displayName = "NutSticky";
  const classPrefix$k = "nut-safe-area";
  const SafeArea = (props) => {
    return /* @__PURE__ */ React.createElement(
      "div",
      {
        className: classNames(
          classPrefix$k,
          `${classPrefix$k}-position-${props.position}`
        )
      }
    );
  };
  SafeArea.displayName = "NutSafeArea";
  const defaultProps$1j = {
    ...ComponentDefaults,
    target: "",
    threshold: 200,
    zIndex: 900,
    duration: 1e3
  };
  const BackTop = (props) => {
    const rtl = useRtl();
    const {
      children,
      target,
      threshold,
      zIndex,
      className,
      duration,
      style,
      onClick
    } = {
      ...defaultProps$1j,
      ...props
    };
    const classPrefix2 = "nut-backtop";
    const [backTop, SetBackTop] = React.useState(false);
    const [scrollTop, SetScrollTop] = React.useState(0);
    let startTime = 0;
    const scrollEl = React.useRef(null);
    const cls = classNames(classPrefix2, { show: backTop }, className);
    const scrollListener = React.useCallback(() => {
      var _a;
      let top = null;
      if (scrollEl.current instanceof Window) {
        top = scrollEl.current.scrollY;
      } else {
        top = (_a = scrollEl.current) == null ? void 0 : _a.scrollTop;
      }
      SetScrollTop(top);
      SetBackTop(top >= threshold);
    }, [threshold]);
    const init = React.useCallback(() => {
      var _a, _b;
      if (target && document.getElementById(target)) {
        scrollEl.current = document.getElementById(target);
      } else {
        scrollEl.current = window;
      }
      (_a = scrollEl.current) == null ? void 0 : _a.addEventListener("scroll", scrollListener, false);
      (_b = scrollEl.current) == null ? void 0 : _b.addEventListener("resize", scrollListener, false);
    }, [target, scrollListener]);
    React.useEffect(() => {
      init();
      return () => {
        var _a, _b;
        (_a = scrollEl.current) == null ? void 0 : _a.removeEventListener("scroll", scrollListener, false);
        (_b = scrollEl.current) == null ? void 0 : _b.removeEventListener("resize", scrollListener, false);
      };
    }, [init, scrollListener]);
    const scroll = (y = 0) => {
      if (scrollEl.current instanceof Window) {
        window.scrollTo(0, y);
      } else {
        scrollEl.current.scrollTop = y;
        window.scrollTo(0, y);
      }
    };
    const scrollAnimation = () => {
      let cid = requestAniFrame$1(function fn() {
        const t = duration - Math.max(0, startTime - +/* @__PURE__ */ new Date() + duration / 2);
        const y = t * -scrollTop / duration + scrollTop;
        scroll(y);
        cid = requestAniFrame$1(fn);
        if (t === duration || y === 0) {
          cancelRaf(cid);
        }
      });
    };
    const goTop = (e) => {
      onClick && onClick(e);
      startTime = +/* @__PURE__ */ new Date();
      duration > 0 ? scrollAnimation() : scroll();
    };
    const styles = Object.keys(style || {}).length !== 0 ? {
      zIndex,
      ...style
    } : {
      [rtl ? "left" : "right"]: "10px",
      bottom: "20px",
      zIndex
    };
    return /* @__PURE__ */ React.createElement("div", { className: cls, style: styles, onClick: (e) => goTop(e) }, children || /* @__PURE__ */ React.createElement(s$1, { width: 19, height: 19, className: "nut-backtop-main" }));
  };
  BackTop.displayName = "NutBackTop";
  function clamp$2(v, min, max) {
    return Math.max(min, Math.min(v, max));
  }
  const V = {
    toVector(v, fallback) {
      if (v === void 0) v = fallback;
      return Array.isArray(v) ? v : [v, v];
    },
    add(v1, v2) {
      return [v1[0] + v2[0], v1[1] + v2[1]];
    },
    sub(v1, v2) {
      return [v1[0] - v2[0], v1[1] - v2[1]];
    },
    addTo(v1, v2) {
      v1[0] += v2[0];
      v1[1] += v2[1];
    },
    subTo(v1, v2) {
      v1[0] -= v2[0];
      v1[1] -= v2[1];
    }
  };
  function rubberband$1(distance, dimension, constant) {
    if (dimension === 0 || Math.abs(dimension) === Infinity) return Math.pow(distance, constant * 5);
    return distance * dimension * constant / (dimension + constant * distance);
  }
  function rubberbandIfOutOfBounds$1(position, min, max, constant = 0.15) {
    if (constant === 0) return clamp$2(position, min, max);
    if (position < min) return -rubberband$1(min - position, max - min, constant) + min;
    if (position > max) return +rubberband$1(position - max, max - min, constant) + max;
    return position;
  }
  function computeRubberband(bounds, [Vx, Vy], [Rx, Ry]) {
    const [[X0, X1], [Y0, Y1]] = bounds;
    return [rubberbandIfOutOfBounds$1(Vx, X0, X1, Rx), rubberbandIfOutOfBounds$1(Vy, Y0, Y1, Ry)];
  }
  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread2(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = null != arguments[i2] ? arguments[i2] : {};
      i2 % 2 ? ownKeys(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  const EVENT_TYPE_MAP = {
    pointer: {
      start: "down",
      change: "move",
      end: "up"
    },
    mouse: {
      start: "down",
      change: "move",
      end: "up"
    },
    touch: {
      start: "start",
      change: "move",
      end: "end"
    },
    gesture: {
      start: "start",
      change: "change",
      end: "end"
    }
  };
  function capitalize(string2) {
    if (!string2) return "";
    return string2[0].toUpperCase() + string2.slice(1);
  }
  const actionsWithoutCaptureSupported = ["enter", "leave"];
  function hasCapture(capture = false, actionKey) {
    return capture && !actionsWithoutCaptureSupported.includes(actionKey);
  }
  function toHandlerProp(device, action = "", capture = false) {
    const deviceProps = EVENT_TYPE_MAP[device];
    const actionKey = deviceProps ? deviceProps[action] || action : action;
    return "on" + capitalize(device) + capitalize(actionKey) + (hasCapture(capture, actionKey) ? "Capture" : "");
  }
  const pointerCaptureEvents = ["gotpointercapture", "lostpointercapture"];
  function parseProp(prop) {
    let eventKey = prop.substring(2).toLowerCase();
    const passive = !!~eventKey.indexOf("passive");
    if (passive) eventKey = eventKey.replace("passive", "");
    const captureKey = pointerCaptureEvents.includes(eventKey) ? "capturecapture" : "capture";
    const capture = !!~eventKey.indexOf(captureKey);
    if (capture) eventKey = eventKey.replace("capture", "");
    return {
      device: eventKey,
      capture,
      passive
    };
  }
  function toDomEventType(device, action = "") {
    const deviceProps = EVENT_TYPE_MAP[device];
    const actionKey = deviceProps ? deviceProps[action] || action : action;
    return device + actionKey;
  }
  function isTouch(event) {
    return "touches" in event;
  }
  function getPointerType(event) {
    if (isTouch(event)) return "touch";
    if ("pointerType" in event) return event.pointerType;
    return "mouse";
  }
  function getCurrentTargetTouchList(event) {
    return Array.from(event.touches).filter((e) => {
      var _event$currentTarget, _event$currentTarget$;
      return e.target === event.currentTarget || ((_event$currentTarget = event.currentTarget) === null || _event$currentTarget === void 0 ? void 0 : (_event$currentTarget$ = _event$currentTarget.contains) === null || _event$currentTarget$ === void 0 ? void 0 : _event$currentTarget$.call(_event$currentTarget, e.target));
    });
  }
  function getTouchList(event) {
    return event.type === "touchend" || event.type === "touchcancel" ? event.changedTouches : event.targetTouches;
  }
  function getValueEvent(event) {
    return isTouch(event) ? getTouchList(event)[0] : event;
  }
  function distanceAngle(P1, P2) {
    const dx = P2.clientX - P1.clientX;
    const dy = P2.clientY - P1.clientY;
    const cx = (P2.clientX + P1.clientX) / 2;
    const cy = (P2.clientY + P1.clientY) / 2;
    const distance = Math.hypot(dx, dy);
    const angle = -(Math.atan2(dx, dy) * 180) / Math.PI;
    const origin = [cx, cy];
    return {
      angle,
      distance,
      origin
    };
  }
  function touchIds(event) {
    return getCurrentTargetTouchList(event).map((touch) => touch.identifier);
  }
  function touchDistanceAngle(event, ids) {
    const [P1, P2] = Array.from(event.touches).filter((touch) => ids.includes(touch.identifier));
    return distanceAngle(P1, P2);
  }
  function pointerId(event) {
    const valueEvent = getValueEvent(event);
    return isTouch(event) ? valueEvent.identifier : valueEvent.pointerId;
  }
  function pointerValues(event) {
    const valueEvent = getValueEvent(event);
    return [valueEvent.clientX, valueEvent.clientY];
  }
  const LINE_HEIGHT = 40;
  const PAGE_HEIGHT = 800;
  function wheelValues(event) {
    let {
      deltaX,
      deltaY,
      deltaMode
    } = event;
    if (deltaMode === 1) {
      deltaX *= LINE_HEIGHT;
      deltaY *= LINE_HEIGHT;
    } else if (deltaMode === 2) {
      deltaX *= PAGE_HEIGHT;
      deltaY *= PAGE_HEIGHT;
    }
    return [deltaX, deltaY];
  }
  function scrollValues(event) {
    var _ref, _ref2;
    const {
      scrollX,
      scrollY,
      scrollLeft,
      scrollTop
    } = event.currentTarget;
    return [(_ref = scrollX !== null && scrollX !== void 0 ? scrollX : scrollLeft) !== null && _ref !== void 0 ? _ref : 0, (_ref2 = scrollY !== null && scrollY !== void 0 ? scrollY : scrollTop) !== null && _ref2 !== void 0 ? _ref2 : 0];
  }
  function getEventDetails(event) {
    const payload = {};
    if ("buttons" in event) payload.buttons = event.buttons;
    if ("shiftKey" in event) {
      const {
        shiftKey,
        altKey,
        metaKey,
        ctrlKey
      } = event;
      Object.assign(payload, {
        shiftKey,
        altKey,
        metaKey,
        ctrlKey
      });
    }
    return payload;
  }
  function call$1(v, ...args) {
    if (typeof v === "function") {
      return v(...args);
    } else {
      return v;
    }
  }
  function noop$1() {
  }
  function chain(...fns) {
    if (fns.length === 0) return noop$1;
    if (fns.length === 1) return fns[0];
    return function() {
      let result;
      for (const fn of fns) {
        result = fn.apply(this, arguments) || result;
      }
      return result;
    };
  }
  function assignDefault(value, fallback) {
    return Object.assign({}, fallback, value || {});
  }
  const BEFORE_LAST_KINEMATICS_DELAY = 32;
  class Engine {
    constructor(ctrl, args, key) {
      this.ctrl = ctrl;
      this.args = args;
      this.key = key;
      if (!this.state) {
        this.state = {};
        this.computeValues([0, 0]);
        this.computeInitial();
        if (this.init) this.init();
        this.reset();
      }
    }
    get state() {
      return this.ctrl.state[this.key];
    }
    set state(state) {
      this.ctrl.state[this.key] = state;
    }
    get shared() {
      return this.ctrl.state.shared;
    }
    get eventStore() {
      return this.ctrl.gestureEventStores[this.key];
    }
    get timeoutStore() {
      return this.ctrl.gestureTimeoutStores[this.key];
    }
    get config() {
      return this.ctrl.config[this.key];
    }
    get sharedConfig() {
      return this.ctrl.config.shared;
    }
    get handler() {
      return this.ctrl.handlers[this.key];
    }
    reset() {
      const {
        state,
        shared,
        ingKey,
        args
      } = this;
      shared[ingKey] = state._active = state.active = state._blocked = state._force = false;
      state._step = [false, false];
      state.intentional = false;
      state._movement = [0, 0];
      state._distance = [0, 0];
      state._direction = [0, 0];
      state._delta = [0, 0];
      state._bounds = [[-Infinity, Infinity], [-Infinity, Infinity]];
      state.args = args;
      state.axis = void 0;
      state.memo = void 0;
      state.elapsedTime = 0;
      state.direction = [0, 0];
      state.distance = [0, 0];
      state.overflow = [0, 0];
      state._movementBound = [false, false];
      state.velocity = [0, 0];
      state.movement = [0, 0];
      state.delta = [0, 0];
      state.timeStamp = 0;
    }
    start(event) {
      const state = this.state;
      const config2 = this.config;
      if (!state._active) {
        this.reset();
        this.computeInitial();
        state._active = true;
        state.target = event.target;
        state.currentTarget = event.currentTarget;
        state.lastOffset = config2.from ? call$1(config2.from, state) : state.offset;
        state.offset = state.lastOffset;
      }
      state.startTime = state.timeStamp = event.timeStamp;
    }
    computeValues(values) {
      const state = this.state;
      state._values = values;
      state.values = this.config.transform(values);
    }
    computeInitial() {
      const state = this.state;
      state._initial = state._values;
      state.initial = state.values;
    }
    compute(event) {
      const {
        state,
        config: config2,
        shared
      } = this;
      state.args = this.args;
      let dt = 0;
      if (event) {
        state.event = event;
        if (config2.preventDefault && event.cancelable) state.event.preventDefault();
        state.type = event.type;
        shared.touches = this.ctrl.pointerIds.size || this.ctrl.touchIds.size;
        shared.locked = !!document.pointerLockElement;
        Object.assign(shared, getEventDetails(event));
        shared.down = shared.pressed = shared.buttons % 2 === 1 || shared.touches > 0;
        dt = event.timeStamp - state.timeStamp;
        state.timeStamp = event.timeStamp;
        state.elapsedTime = state.timeStamp - state.startTime;
      }
      if (state._active) {
        const _absoluteDelta = state._delta.map(Math.abs);
        V.addTo(state._distance, _absoluteDelta);
      }
      if (this.axisIntent) this.axisIntent(event);
      const [_m0, _m1] = state._movement;
      const [t0, t1] = config2.threshold;
      const {
        _step,
        values
      } = state;
      if (config2.hasCustomTransform) {
        if (_step[0] === false) _step[0] = Math.abs(_m0) >= t0 && values[0];
        if (_step[1] === false) _step[1] = Math.abs(_m1) >= t1 && values[1];
      } else {
        if (_step[0] === false) _step[0] = Math.abs(_m0) >= t0 && Math.sign(_m0) * t0;
        if (_step[1] === false) _step[1] = Math.abs(_m1) >= t1 && Math.sign(_m1) * t1;
      }
      state.intentional = _step[0] !== false || _step[1] !== false;
      if (!state.intentional) return;
      const movement = [0, 0];
      if (config2.hasCustomTransform) {
        const [v0, v1] = values;
        movement[0] = _step[0] !== false ? v0 - _step[0] : 0;
        movement[1] = _step[1] !== false ? v1 - _step[1] : 0;
      } else {
        movement[0] = _step[0] !== false ? _m0 - _step[0] : 0;
        movement[1] = _step[1] !== false ? _m1 - _step[1] : 0;
      }
      if (this.restrictToAxis && !state._blocked) this.restrictToAxis(movement);
      const previousOffset = state.offset;
      const gestureIsActive = state._active && !state._blocked || state.active;
      if (gestureIsActive) {
        state.first = state._active && !state.active;
        state.last = !state._active && state.active;
        state.active = shared[this.ingKey] = state._active;
        if (event) {
          if (state.first) {
            if ("bounds" in config2) state._bounds = call$1(config2.bounds, state);
            if (this.setup) this.setup();
          }
          state.movement = movement;
          this.computeOffset();
        }
      }
      const [ox, oy] = state.offset;
      const [[x0, x1], [y0, y1]] = state._bounds;
      state.overflow = [ox < x0 ? -1 : ox > x1 ? 1 : 0, oy < y0 ? -1 : oy > y1 ? 1 : 0];
      state._movementBound[0] = state.overflow[0] ? state._movementBound[0] === false ? state._movement[0] : state._movementBound[0] : false;
      state._movementBound[1] = state.overflow[1] ? state._movementBound[1] === false ? state._movement[1] : state._movementBound[1] : false;
      const rubberband2 = state._active ? config2.rubberband || [0, 0] : [0, 0];
      state.offset = computeRubberband(state._bounds, state.offset, rubberband2);
      state.delta = V.sub(state.offset, previousOffset);
      this.computeMovement();
      if (gestureIsActive && (!state.last || dt > BEFORE_LAST_KINEMATICS_DELAY)) {
        state.delta = V.sub(state.offset, previousOffset);
        const absoluteDelta = state.delta.map(Math.abs);
        V.addTo(state.distance, absoluteDelta);
        state.direction = state.delta.map(Math.sign);
        state._direction = state._delta.map(Math.sign);
        if (!state.first && dt > 0) {
          state.velocity = [absoluteDelta[0] / dt, absoluteDelta[1] / dt];
        }
      }
    }
    emit() {
      const state = this.state;
      const shared = this.shared;
      const config2 = this.config;
      if (!state._active) this.clean();
      if ((state._blocked || !state.intentional) && !state._force && !config2.triggerAllEvents) return;
      const memo = this.handler(_objectSpread2(_objectSpread2(_objectSpread2({}, shared), state), {}, {
        [this.aliasKey]: state.values
      }));
      if (memo !== void 0) state.memo = memo;
    }
    clean() {
      this.eventStore.clean();
      this.timeoutStore.clean();
    }
  }
  function selectAxis([dx, dy], threshold) {
    const absDx = Math.abs(dx);
    const absDy = Math.abs(dy);
    if (absDx > absDy && absDx > threshold) {
      return "x";
    }
    if (absDy > absDx && absDy > threshold) {
      return "y";
    }
    return void 0;
  }
  class CoordinatesEngine extends Engine {
    constructor(...args) {
      super(...args);
      _defineProperty(this, "aliasKey", "xy");
    }
    reset() {
      super.reset();
      this.state.axis = void 0;
    }
    init() {
      this.state.offset = [0, 0];
      this.state.lastOffset = [0, 0];
    }
    computeOffset() {
      this.state.offset = V.add(this.state.lastOffset, this.state.movement);
    }
    computeMovement() {
      this.state.movement = V.sub(this.state.offset, this.state.lastOffset);
    }
    axisIntent(event) {
      const state = this.state;
      const config2 = this.config;
      if (!state.axis && event) {
        const threshold = typeof config2.axisThreshold === "object" ? config2.axisThreshold[getPointerType(event)] : config2.axisThreshold;
        state.axis = selectAxis(state._movement, threshold);
      }
      state._blocked = (config2.lockDirection || !!config2.axis) && !state.axis || !!config2.axis && config2.axis !== state.axis;
    }
    restrictToAxis(v) {
      if (this.config.axis || this.config.lockDirection) {
        switch (this.state.axis) {
          case "x":
            v[1] = 0;
            break;
          case "y":
            v[0] = 0;
            break;
        }
      }
    }
  }
  const identity = (v) => v;
  const DEFAULT_RUBBERBAND = 0.15;
  const commonConfigResolver = {
    enabled(value = true) {
      return value;
    },
    eventOptions(value, _k, config2) {
      return _objectSpread2(_objectSpread2({}, config2.shared.eventOptions), value);
    },
    preventDefault(value = false) {
      return value;
    },
    triggerAllEvents(value = false) {
      return value;
    },
    rubberband(value = 0) {
      switch (value) {
        case true:
          return [DEFAULT_RUBBERBAND, DEFAULT_RUBBERBAND];
        case false:
          return [0, 0];
        default:
          return V.toVector(value);
      }
    },
    from(value) {
      if (typeof value === "function") return value;
      if (value != null) return V.toVector(value);
    },
    transform(value, _k, config2) {
      const transform = value || config2.shared.transform;
      this.hasCustomTransform = !!transform;
      return transform || identity;
    },
    threshold(value) {
      return V.toVector(value, 0);
    }
  };
  const DEFAULT_AXIS_THRESHOLD = 0;
  const coordinatesConfigResolver = _objectSpread2(_objectSpread2({}, commonConfigResolver), {}, {
    axis(_v, _k, {
      axis
    }) {
      this.lockDirection = axis === "lock";
      if (!this.lockDirection) return axis;
    },
    axisThreshold(value = DEFAULT_AXIS_THRESHOLD) {
      return value;
    },
    bounds(value = {}) {
      if (typeof value === "function") {
        return (state) => coordinatesConfigResolver.bounds(value(state));
      }
      if ("current" in value) {
        return () => value.current;
      }
      if (typeof HTMLElement === "function" && value instanceof HTMLElement) {
        return value;
      }
      const {
        left = -Infinity,
        right = Infinity,
        top = -Infinity,
        bottom = Infinity
      } = value;
      return [[left, right], [top, bottom]];
    }
  });
  const DISPLACEMENT = 10;
  const KEYS_DELTA_MAP = {
    ArrowRight: (factor = 1) => [DISPLACEMENT * factor, 0],
    ArrowLeft: (factor = 1) => [-DISPLACEMENT * factor, 0],
    ArrowUp: (factor = 1) => [0, -DISPLACEMENT * factor],
    ArrowDown: (factor = 1) => [0, DISPLACEMENT * factor]
  };
  class DragEngine extends CoordinatesEngine {
    constructor(...args) {
      super(...args);
      _defineProperty(this, "ingKey", "dragging");
    }
    reset() {
      super.reset();
      const state = this.state;
      state._pointerId = void 0;
      state._pointerActive = false;
      state._keyboardActive = false;
      state._preventScroll = false;
      state._delayed = false;
      state.swipe = [0, 0];
      state.tap = false;
      state.canceled = false;
      state.cancel = this.cancel.bind(this);
    }
    setup() {
      const state = this.state;
      if (state._bounds instanceof HTMLElement) {
        const boundRect = state._bounds.getBoundingClientRect();
        const targetRect = state.currentTarget.getBoundingClientRect();
        const _bounds = {
          left: boundRect.left - targetRect.left + state.offset[0],
          right: boundRect.right - targetRect.right + state.offset[0],
          top: boundRect.top - targetRect.top + state.offset[1],
          bottom: boundRect.bottom - targetRect.bottom + state.offset[1]
        };
        state._bounds = coordinatesConfigResolver.bounds(_bounds);
      }
    }
    cancel() {
      const state = this.state;
      if (state.canceled) return;
      state.canceled = true;
      state._active = false;
      setTimeout(() => {
        this.compute();
        this.emit();
      }, 0);
    }
    setActive() {
      this.state._active = this.state._pointerActive || this.state._keyboardActive;
    }
    clean() {
      this.pointerClean();
      this.state._pointerActive = false;
      this.state._keyboardActive = false;
      super.clean();
    }
    pointerDown(event) {
      const config2 = this.config;
      const state = this.state;
      if (event.buttons != null && (Array.isArray(config2.pointerButtons) ? !config2.pointerButtons.includes(event.buttons) : config2.pointerButtons !== -1 && config2.pointerButtons !== event.buttons)) return;
      const ctrlIds = this.ctrl.setEventIds(event);
      if (config2.pointerCapture) {
        event.target.setPointerCapture(event.pointerId);
      }
      if (ctrlIds && ctrlIds.size > 1 && state._pointerActive) return;
      this.start(event);
      this.setupPointer(event);
      state._pointerId = pointerId(event);
      state._pointerActive = true;
      this.computeValues(pointerValues(event));
      this.computeInitial();
      if (config2.preventScrollAxis && getPointerType(event) !== "mouse") {
        state._active = false;
        this.setupScrollPrevention(event);
      } else if (config2.delay > 0) {
        this.setupDelayTrigger(event);
        if (config2.triggerAllEvents) {
          this.compute(event);
          this.emit();
        }
      } else {
        this.startPointerDrag(event);
      }
    }
    startPointerDrag(event) {
      const state = this.state;
      state._active = true;
      state._preventScroll = true;
      state._delayed = false;
      this.compute(event);
      this.emit();
    }
    pointerMove(event) {
      const state = this.state;
      const config2 = this.config;
      if (!state._pointerActive) return;
      if (state.type === event.type && event.timeStamp === state.timeStamp) return;
      const id = pointerId(event);
      if (state._pointerId !== void 0 && id !== state._pointerId) return;
      const _values = pointerValues(event);
      if (document.pointerLockElement === event.target) {
        state._delta = [event.movementX, event.movementY];
      } else {
        state._delta = V.sub(_values, state._values);
        this.computeValues(_values);
      }
      V.addTo(state._movement, state._delta);
      this.compute(event);
      if (state._delayed && state.intentional) {
        this.timeoutStore.remove("dragDelay");
        state.active = false;
        this.startPointerDrag(event);
        return;
      }
      if (config2.preventScrollAxis && !state._preventScroll) {
        if (state.axis) {
          if (state.axis === config2.preventScrollAxis || config2.preventScrollAxis === "xy") {
            state._active = false;
            this.clean();
            return;
          } else {
            this.timeoutStore.remove("startPointerDrag");
            this.startPointerDrag(event);
            return;
          }
        } else {
          return;
        }
      }
      this.emit();
    }
    pointerUp(event) {
      this.ctrl.setEventIds(event);
      try {
        if (this.config.pointerCapture && event.target.hasPointerCapture(event.pointerId)) {
          ;
          event.target.releasePointerCapture(event.pointerId);
        }
      } catch (_unused) {
      }
      const state = this.state;
      const config2 = this.config;
      if (!state._active || !state._pointerActive) return;
      const id = pointerId(event);
      if (state._pointerId !== void 0 && id !== state._pointerId) return;
      this.state._pointerActive = false;
      this.setActive();
      this.compute(event);
      const [dx, dy] = state._distance;
      state.tap = dx <= config2.tapsThreshold && dy <= config2.tapsThreshold;
      if (state.tap && config2.filterTaps) {
        state._force = true;
      } else {
        const [dirx, diry] = state.direction;
        const [vx, vy] = state.velocity;
        const [mx, my] = state.movement;
        const [svx, svy] = config2.swipe.velocity;
        const [sx, sy] = config2.swipe.distance;
        const sdt = config2.swipe.duration;
        if (state.elapsedTime < sdt) {
          if (Math.abs(vx) > svx && Math.abs(mx) > sx) state.swipe[0] = dirx;
          if (Math.abs(vy) > svy && Math.abs(my) > sy) state.swipe[1] = diry;
        }
      }
      this.emit();
    }
    pointerClick(event) {
      if (!this.state.tap && event.detail > 0) {
        event.preventDefault();
        event.stopPropagation();
      }
    }
    setupPointer(event) {
      const config2 = this.config;
      const device = config2.device;
      if (config2.pointerLock) {
        event.currentTarget.requestPointerLock();
      }
      if (!config2.pointerCapture) {
        this.eventStore.add(this.sharedConfig.window, device, "change", this.pointerMove.bind(this));
        this.eventStore.add(this.sharedConfig.window, device, "end", this.pointerUp.bind(this));
        this.eventStore.add(this.sharedConfig.window, device, "cancel", this.pointerUp.bind(this));
      }
    }
    pointerClean() {
      if (this.config.pointerLock && document.pointerLockElement === this.state.currentTarget) {
        document.exitPointerLock();
      }
    }
    preventScroll(event) {
      if (this.state._preventScroll && event.cancelable) {
        event.preventDefault();
      }
    }
    setupScrollPrevention(event) {
      this.state._preventScroll = false;
      persistEvent(event);
      const remove = this.eventStore.add(this.sharedConfig.window, "touch", "change", this.preventScroll.bind(this), {
        passive: false
      });
      this.eventStore.add(this.sharedConfig.window, "touch", "end", remove);
      this.eventStore.add(this.sharedConfig.window, "touch", "cancel", remove);
      this.timeoutStore.add("startPointerDrag", this.startPointerDrag.bind(this), this.config.preventScrollDelay, event);
    }
    setupDelayTrigger(event) {
      this.state._delayed = true;
      this.timeoutStore.add("dragDelay", () => {
        this.state._step = [0, 0];
        this.startPointerDrag(event);
      }, this.config.delay);
    }
    keyDown(event) {
      const deltaFn = KEYS_DELTA_MAP[event.key];
      if (deltaFn) {
        const state = this.state;
        const factor = event.shiftKey ? 10 : event.altKey ? 0.1 : 1;
        this.start(event);
        state._delta = deltaFn(factor);
        state._keyboardActive = true;
        V.addTo(state._movement, state._delta);
        this.compute(event);
        this.emit();
      }
    }
    keyUp(event) {
      if (!(event.key in KEYS_DELTA_MAP)) return;
      this.state._keyboardActive = false;
      this.setActive();
      this.compute(event);
      this.emit();
    }
    bind(bindFunction) {
      const device = this.config.device;
      bindFunction(device, "start", this.pointerDown.bind(this));
      if (this.config.pointerCapture) {
        bindFunction(device, "change", this.pointerMove.bind(this));
        bindFunction(device, "end", this.pointerUp.bind(this));
        bindFunction(device, "cancel", this.pointerUp.bind(this));
        bindFunction("lostPointerCapture", "", this.pointerUp.bind(this));
      }
      if (this.config.keys) {
        bindFunction("key", "down", this.keyDown.bind(this));
        bindFunction("key", "up", this.keyUp.bind(this));
      }
      if (this.config.filterTaps) {
        bindFunction("click", "", this.pointerClick.bind(this), {
          capture: true,
          passive: false
        });
      }
    }
  }
  function persistEvent(event) {
    "persist" in event && typeof event.persist === "function" && event.persist();
  }
  const isBrowser = typeof window !== "undefined" && window.document && window.document.createElement;
  function supportsTouchEvents() {
    return isBrowser && "ontouchstart" in window;
  }
  function isTouchScreen() {
    return supportsTouchEvents() || isBrowser && window.navigator.maxTouchPoints > 1;
  }
  function supportsPointerEvents() {
    return isBrowser && "onpointerdown" in window;
  }
  function supportsPointerLock() {
    return isBrowser && "exitPointerLock" in window.document;
  }
  function supportsGestureEvents() {
    try {
      return "constructor" in GestureEvent;
    } catch (e) {
      return false;
    }
  }
  const SUPPORT = {
    isBrowser,
    gesture: supportsGestureEvents(),
    touch: isTouchScreen(),
    touchscreen: isTouchScreen(),
    pointer: supportsPointerEvents(),
    pointerLock: supportsPointerLock()
  };
  const DEFAULT_PREVENT_SCROLL_DELAY = 250;
  const DEFAULT_DRAG_DELAY = 180;
  const DEFAULT_SWIPE_VELOCITY = 0.5;
  const DEFAULT_SWIPE_DISTANCE = 50;
  const DEFAULT_SWIPE_DURATION = 250;
  const DEFAULT_DRAG_AXIS_THRESHOLD = {
    mouse: 0,
    touch: 0,
    pen: 8
  };
  const dragConfigResolver = _objectSpread2(_objectSpread2({}, coordinatesConfigResolver), {}, {
    device(_v, _k, {
      pointer: {
        touch = false,
        lock = false,
        mouse = false
      } = {}
    }) {
      this.pointerLock = lock && SUPPORT.pointerLock;
      if (SUPPORT.touch && touch) return "touch";
      if (this.pointerLock) return "mouse";
      if (SUPPORT.pointer && !mouse) return "pointer";
      if (SUPPORT.touch) return "touch";
      return "mouse";
    },
    preventScrollAxis(value, _k, {
      preventScroll
    }) {
      this.preventScrollDelay = typeof preventScroll === "number" ? preventScroll : preventScroll || preventScroll === void 0 && value ? DEFAULT_PREVENT_SCROLL_DELAY : void 0;
      if (!SUPPORT.touchscreen || preventScroll === false) return void 0;
      return value ? value : preventScroll !== void 0 ? "y" : void 0;
    },
    pointerCapture(_v, _k, {
      pointer: {
        capture = true,
        buttons = 1
      } = {}
    }) {
      this.pointerButtons = buttons;
      return !this.pointerLock && this.device === "pointer" && capture;
    },
    keys(value = true) {
      return value;
    },
    threshold(value, _k, {
      filterTaps = false,
      tapsThreshold = 3,
      axis = void 0
    }) {
      const threshold = V.toVector(value, filterTaps ? tapsThreshold : axis ? 1 : 0);
      this.filterTaps = filterTaps;
      this.tapsThreshold = tapsThreshold;
      return threshold;
    },
    swipe({
      velocity = DEFAULT_SWIPE_VELOCITY,
      distance = DEFAULT_SWIPE_DISTANCE,
      duration = DEFAULT_SWIPE_DURATION
    } = {}) {
      return {
        velocity: this.transform(V.toVector(velocity)),
        distance: this.transform(V.toVector(distance)),
        duration
      };
    },
    delay(value = 0) {
      switch (value) {
        case true:
          return DEFAULT_DRAG_DELAY;
        case false:
          return 0;
        default:
          return value;
      }
    },
    axisThreshold(value) {
      if (!value) return DEFAULT_DRAG_AXIS_THRESHOLD;
      return _objectSpread2(_objectSpread2({}, DEFAULT_DRAG_AXIS_THRESHOLD), value);
    }
  });
  const SCALE_ANGLE_RATIO_INTENT_DEG = 30;
  const PINCH_WHEEL_RATIO = 100;
  class PinchEngine extends Engine {
    constructor(...args) {
      super(...args);
      _defineProperty(this, "ingKey", "pinching");
      _defineProperty(this, "aliasKey", "da");
    }
    init() {
      this.state.offset = [1, 0];
      this.state.lastOffset = [1, 0];
      this.state._pointerEvents = /* @__PURE__ */ new Map();
    }
    reset() {
      super.reset();
      const state = this.state;
      state._touchIds = [];
      state.canceled = false;
      state.cancel = this.cancel.bind(this);
      state.turns = 0;
    }
    computeOffset() {
      const {
        type,
        movement,
        lastOffset
      } = this.state;
      if (type === "wheel") {
        this.state.offset = V.add(movement, lastOffset);
      } else {
        this.state.offset = [(1 + movement[0]) * lastOffset[0], movement[1] + lastOffset[1]];
      }
    }
    computeMovement() {
      const {
        offset,
        lastOffset
      } = this.state;
      this.state.movement = [offset[0] / lastOffset[0], offset[1] - lastOffset[1]];
    }
    axisIntent() {
      const state = this.state;
      const [_m0, _m1] = state._movement;
      if (!state.axis) {
        const axisMovementDifference = Math.abs(_m0) * SCALE_ANGLE_RATIO_INTENT_DEG - Math.abs(_m1);
        if (axisMovementDifference < 0) state.axis = "angle";
        else if (axisMovementDifference > 0) state.axis = "scale";
      }
    }
    restrictToAxis(v) {
      if (this.config.lockDirection) {
        if (this.state.axis === "scale") v[1] = 0;
        else if (this.state.axis === "angle") v[0] = 0;
      }
    }
    cancel() {
      const state = this.state;
      if (state.canceled) return;
      setTimeout(() => {
        state.canceled = true;
        state._active = false;
        this.compute();
        this.emit();
      }, 0);
    }
    touchStart(event) {
      this.ctrl.setEventIds(event);
      const state = this.state;
      const ctrlTouchIds = this.ctrl.touchIds;
      if (state._active) {
        if (state._touchIds.every((id) => ctrlTouchIds.has(id))) return;
      }
      if (ctrlTouchIds.size < 2) return;
      this.start(event);
      state._touchIds = Array.from(ctrlTouchIds).slice(0, 2);
      const payload = touchDistanceAngle(event, state._touchIds);
      this.pinchStart(event, payload);
    }
    pointerStart(event) {
      if (event.buttons != null && event.buttons % 2 !== 1) return;
      this.ctrl.setEventIds(event);
      event.target.setPointerCapture(event.pointerId);
      const state = this.state;
      const _pointerEvents = state._pointerEvents;
      const ctrlPointerIds = this.ctrl.pointerIds;
      if (state._active) {
        if (Array.from(_pointerEvents.keys()).every((id) => ctrlPointerIds.has(id))) return;
      }
      if (_pointerEvents.size < 2) {
        _pointerEvents.set(event.pointerId, event);
      }
      if (state._pointerEvents.size < 2) return;
      this.start(event);
      const payload = distanceAngle(...Array.from(_pointerEvents.values()));
      this.pinchStart(event, payload);
    }
    pinchStart(event, payload) {
      const state = this.state;
      state.origin = payload.origin;
      this.computeValues([payload.distance, payload.angle]);
      this.computeInitial();
      this.compute(event);
      this.emit();
    }
    touchMove(event) {
      if (!this.state._active) return;
      const payload = touchDistanceAngle(event, this.state._touchIds);
      this.pinchMove(event, payload);
    }
    pointerMove(event) {
      const _pointerEvents = this.state._pointerEvents;
      if (_pointerEvents.has(event.pointerId)) {
        _pointerEvents.set(event.pointerId, event);
      }
      if (!this.state._active) return;
      const payload = distanceAngle(...Array.from(_pointerEvents.values()));
      this.pinchMove(event, payload);
    }
    pinchMove(event, payload) {
      const state = this.state;
      const prev_a = state._values[1];
      const delta_a = payload.angle - prev_a;
      let delta_turns = 0;
      if (Math.abs(delta_a) > 270) delta_turns += Math.sign(delta_a);
      this.computeValues([payload.distance, payload.angle - 360 * delta_turns]);
      state.origin = payload.origin;
      state.turns = delta_turns;
      state._movement = [state._values[0] / state._initial[0] - 1, state._values[1] - state._initial[1]];
      this.compute(event);
      this.emit();
    }
    touchEnd(event) {
      this.ctrl.setEventIds(event);
      if (!this.state._active) return;
      if (this.state._touchIds.some((id) => !this.ctrl.touchIds.has(id))) {
        this.state._active = false;
        this.compute(event);
        this.emit();
      }
    }
    pointerEnd(event) {
      const state = this.state;
      this.ctrl.setEventIds(event);
      try {
        event.target.releasePointerCapture(event.pointerId);
      } catch (_unused) {
      }
      if (state._pointerEvents.has(event.pointerId)) {
        state._pointerEvents.delete(event.pointerId);
      }
      if (!state._active) return;
      if (state._pointerEvents.size < 2) {
        state._active = false;
        this.compute(event);
        this.emit();
      }
    }
    gestureStart(event) {
      if (event.cancelable) event.preventDefault();
      const state = this.state;
      if (state._active) return;
      this.start(event);
      this.computeValues([event.scale, event.rotation]);
      state.origin = [event.clientX, event.clientY];
      this.compute(event);
      this.emit();
    }
    gestureMove(event) {
      if (event.cancelable) event.preventDefault();
      if (!this.state._active) return;
      const state = this.state;
      this.computeValues([event.scale, event.rotation]);
      state.origin = [event.clientX, event.clientY];
      const _previousMovement = state._movement;
      state._movement = [event.scale - 1, event.rotation];
      state._delta = V.sub(state._movement, _previousMovement);
      this.compute(event);
      this.emit();
    }
    gestureEnd(event) {
      if (!this.state._active) return;
      this.state._active = false;
      this.compute(event);
      this.emit();
    }
    wheel(event) {
      const modifierKey = this.config.modifierKey;
      if (modifierKey && !event[modifierKey]) return;
      if (!this.state._active) this.wheelStart(event);
      else this.wheelChange(event);
      this.timeoutStore.add("wheelEnd", this.wheelEnd.bind(this));
    }
    wheelStart(event) {
      this.start(event);
      this.wheelChange(event);
    }
    wheelChange(event) {
      const isR3f = "uv" in event;
      if (!isR3f) {
        if (event.cancelable) {
          event.preventDefault();
        }
      }
      const state = this.state;
      state._delta = [-wheelValues(event)[1] / PINCH_WHEEL_RATIO * state.offset[0], 0];
      V.addTo(state._movement, state._delta);
      this.state.origin = [event.clientX, event.clientY];
      this.compute(event);
      this.emit();
    }
    wheelEnd() {
      if (!this.state._active) return;
      this.state._active = false;
      this.compute();
      this.emit();
    }
    bind(bindFunction) {
      const device = this.config.device;
      if (!!device) {
        bindFunction(device, "start", this[device + "Start"].bind(this));
        bindFunction(device, "change", this[device + "Move"].bind(this));
        bindFunction(device, "end", this[device + "End"].bind(this));
        bindFunction(device, "cancel", this[device + "End"].bind(this));
      }
      bindFunction("wheel", "", this.wheel.bind(this), {
        passive: false
      });
    }
  }
  const pinchConfigResolver = _objectSpread2(_objectSpread2({}, commonConfigResolver), {}, {
    device(_v, _k, {
      shared,
      pointer: {
        touch = false
      } = {}
    }) {
      const sharedConfig = shared;
      if (sharedConfig.target && !SUPPORT.touch && SUPPORT.gesture) return "gesture";
      if (SUPPORT.touch && touch) return "touch";
      if (SUPPORT.touchscreen) {
        if (SUPPORT.pointer) return "pointer";
        if (SUPPORT.touch) return "touch";
      }
    },
    bounds(_v, _k, {
      scaleBounds = {},
      angleBounds = {}
    }) {
      const _scaleBounds = (state) => {
        const D = assignDefault(call$1(scaleBounds, state), {
          min: -Infinity,
          max: Infinity
        });
        return [D.min, D.max];
      };
      const _angleBounds = (state) => {
        const A = assignDefault(call$1(angleBounds, state), {
          min: -Infinity,
          max: Infinity
        });
        return [A.min, A.max];
      };
      if (typeof scaleBounds !== "function" && typeof angleBounds !== "function") return [_scaleBounds(), _angleBounds()];
      return (state) => [_scaleBounds(state), _angleBounds(state)];
    },
    threshold(value, _k, config2) {
      this.lockDirection = config2.axis === "lock";
      const threshold = V.toVector(value, this.lockDirection ? [0.1, 3] : 0);
      return threshold;
    },
    modifierKey(value) {
      if (value === void 0) return "ctrlKey";
      return value;
    }
  });
  class MoveEngine extends CoordinatesEngine {
    constructor(...args) {
      super(...args);
      _defineProperty(this, "ingKey", "moving");
    }
    move(event) {
      if (this.config.mouseOnly && event.pointerType !== "mouse") return;
      if (!this.state._active) this.moveStart(event);
      else this.moveChange(event);
      this.timeoutStore.add("moveEnd", this.moveEnd.bind(this));
    }
    moveStart(event) {
      this.start(event);
      this.computeValues(pointerValues(event));
      this.compute(event);
      this.computeInitial();
      this.emit();
    }
    moveChange(event) {
      if (!this.state._active) return;
      const values = pointerValues(event);
      const state = this.state;
      state._delta = V.sub(values, state._values);
      V.addTo(state._movement, state._delta);
      this.computeValues(values);
      this.compute(event);
      this.emit();
    }
    moveEnd(event) {
      if (!this.state._active) return;
      this.state._active = false;
      this.compute(event);
      this.emit();
    }
    bind(bindFunction) {
      bindFunction("pointer", "change", this.move.bind(this));
      bindFunction("pointer", "leave", this.moveEnd.bind(this));
    }
  }
  const moveConfigResolver = _objectSpread2(_objectSpread2({}, coordinatesConfigResolver), {}, {
    mouseOnly: (value = true) => value
  });
  class ScrollEngine extends CoordinatesEngine {
    constructor(...args) {
      super(...args);
      _defineProperty(this, "ingKey", "scrolling");
    }
    scroll(event) {
      if (!this.state._active) this.start(event);
      this.scrollChange(event);
      this.timeoutStore.add("scrollEnd", this.scrollEnd.bind(this));
    }
    scrollChange(event) {
      if (event.cancelable) event.preventDefault();
      const state = this.state;
      const values = scrollValues(event);
      state._delta = V.sub(values, state._values);
      V.addTo(state._movement, state._delta);
      this.computeValues(values);
      this.compute(event);
      this.emit();
    }
    scrollEnd() {
      if (!this.state._active) return;
      this.state._active = false;
      this.compute();
      this.emit();
    }
    bind(bindFunction) {
      bindFunction("scroll", "", this.scroll.bind(this));
    }
  }
  const scrollConfigResolver = coordinatesConfigResolver;
  class WheelEngine extends CoordinatesEngine {
    constructor(...args) {
      super(...args);
      _defineProperty(this, "ingKey", "wheeling");
    }
    wheel(event) {
      if (!this.state._active) this.start(event);
      this.wheelChange(event);
      this.timeoutStore.add("wheelEnd", this.wheelEnd.bind(this));
    }
    wheelChange(event) {
      const state = this.state;
      state._delta = wheelValues(event);
      V.addTo(state._movement, state._delta);
      const [ox, oy] = state.overflow;
      const [dx, dy] = state._delta;
      const [dirx, diry] = state._direction;
      if (ox < 0 && dx > 0 && dirx < 0 || ox > 0 && dx < 0 && dirx > 0) {
        state._movement[0] = state._movementBound[0];
      }
      if (oy < 0 && dy > 0 && diry < 0 || oy > 0 && dy < 0 && diry > 0) {
        state._movement[1] = state._movementBound[1];
      }
      this.compute(event);
      this.emit();
    }
    wheelEnd() {
      if (!this.state._active) return;
      this.state._active = false;
      this.compute();
      this.emit();
    }
    bind(bindFunction) {
      bindFunction("wheel", "", this.wheel.bind(this));
    }
  }
  const wheelConfigResolver = coordinatesConfigResolver;
  class HoverEngine extends CoordinatesEngine {
    constructor(...args) {
      super(...args);
      _defineProperty(this, "ingKey", "hovering");
    }
    enter(event) {
      if (this.config.mouseOnly && event.pointerType !== "mouse") return;
      this.start(event);
      this.computeValues(pointerValues(event));
      this.compute(event);
      this.emit();
    }
    leave(event) {
      if (this.config.mouseOnly && event.pointerType !== "mouse") return;
      const state = this.state;
      if (!state._active) return;
      state._active = false;
      const values = pointerValues(event);
      state._movement = state._delta = V.sub(values, state._values);
      this.computeValues(values);
      this.compute(event);
      state.delta = state.movement;
      this.emit();
    }
    bind(bindFunction) {
      bindFunction("pointer", "enter", this.enter.bind(this));
      bindFunction("pointer", "leave", this.leave.bind(this));
    }
  }
  const hoverConfigResolver = _objectSpread2(_objectSpread2({}, coordinatesConfigResolver), {}, {
    mouseOnly: (value = true) => value
  });
  const EngineMap = /* @__PURE__ */ new Map();
  const ConfigResolverMap = /* @__PURE__ */ new Map();
  function registerAction(action) {
    EngineMap.set(action.key, action.engine);
    ConfigResolverMap.set(action.key, action.resolver);
  }
  const dragAction = {
    key: "drag",
    engine: DragEngine,
    resolver: dragConfigResolver
  };
  const hoverAction = {
    key: "hover",
    engine: HoverEngine,
    resolver: hoverConfigResolver
  };
  const moveAction = {
    key: "move",
    engine: MoveEngine,
    resolver: moveConfigResolver
  };
  const pinchAction = {
    key: "pinch",
    engine: PinchEngine,
    resolver: pinchConfigResolver
  };
  const scrollAction = {
    key: "scroll",
    engine: ScrollEngine,
    resolver: scrollConfigResolver
  };
  const wheelAction = {
    key: "wheel",
    engine: WheelEngine,
    resolver: wheelConfigResolver
  };
  function _objectWithoutPropertiesLoose$2(source, excluded) {
    if (source == null) return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i2;
    for (i2 = 0; i2 < sourceKeys.length; i2++) {
      key = sourceKeys[i2];
      if (excluded.indexOf(key) >= 0) continue;
      target[key] = source[key];
    }
    return target;
  }
  function _objectWithoutProperties(source, excluded) {
    if (source == null) return {};
    var target = _objectWithoutPropertiesLoose$2(source, excluded);
    var key, i2;
    if (Object.getOwnPropertySymbols) {
      var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
      for (i2 = 0; i2 < sourceSymbolKeys.length; i2++) {
        key = sourceSymbolKeys[i2];
        if (excluded.indexOf(key) >= 0) continue;
        if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
        target[key] = source[key];
      }
    }
    return target;
  }
  const sharedConfigResolver = {
    target(value) {
      if (value) {
        return () => "current" in value ? value.current : value;
      }
      return void 0;
    },
    enabled(value = true) {
      return value;
    },
    window(value = SUPPORT.isBrowser ? window : void 0) {
      return value;
    },
    eventOptions({
      passive = true,
      capture = false
    } = {}) {
      return {
        passive,
        capture
      };
    },
    transform(value) {
      return value;
    }
  };
  const _excluded$3 = ["target", "eventOptions", "window", "enabled", "transform"];
  function resolveWith(config2 = {}, resolvers) {
    const result = {};
    for (const [key, resolver] of Object.entries(resolvers)) {
      switch (typeof resolver) {
        case "function":
          {
            result[key] = resolver.call(result, config2[key], key, config2);
          }
          break;
        case "object":
          result[key] = resolveWith(config2[key], resolver);
          break;
        case "boolean":
          if (resolver) result[key] = config2[key];
          break;
      }
    }
    return result;
  }
  function parse(newConfig, gestureKey, _config = {}) {
    const _ref = newConfig, {
      target,
      eventOptions,
      window: window2,
      enabled,
      transform
    } = _ref, rest = _objectWithoutProperties(_ref, _excluded$3);
    _config.shared = resolveWith({
      target,
      eventOptions,
      window: window2,
      enabled,
      transform
    }, sharedConfigResolver);
    if (gestureKey) {
      const resolver = ConfigResolverMap.get(gestureKey);
      _config[gestureKey] = resolveWith(_objectSpread2({
        shared: _config.shared
      }, rest), resolver);
    } else {
      for (const key in rest) {
        const resolver = ConfigResolverMap.get(key);
        if (resolver) {
          _config[key] = resolveWith(_objectSpread2({
            shared: _config.shared
          }, rest[key]), resolver);
        }
      }
    }
    return _config;
  }
  class EventStore {
    constructor(ctrl, gestureKey) {
      _defineProperty(this, "_listeners", /* @__PURE__ */ new Set());
      this._ctrl = ctrl;
      this._gestureKey = gestureKey;
    }
    add(element, device, action, handler, options2) {
      const listeners = this._listeners;
      const type = toDomEventType(device, action);
      const _options = this._gestureKey ? this._ctrl.config[this._gestureKey].eventOptions : {};
      const eventOptions = _objectSpread2(_objectSpread2({}, _options), options2);
      element.addEventListener(type, handler, eventOptions);
      const remove = () => {
        element.removeEventListener(type, handler, eventOptions);
        listeners.delete(remove);
      };
      listeners.add(remove);
      return remove;
    }
    clean() {
      this._listeners.forEach((remove) => remove());
      this._listeners.clear();
    }
  }
  class TimeoutStore {
    constructor() {
      _defineProperty(this, "_timeouts", /* @__PURE__ */ new Map());
    }
    add(key, callback, ms = 140, ...args) {
      this.remove(key);
      this._timeouts.set(key, window.setTimeout(callback, ms, ...args));
    }
    remove(key) {
      const timeout = this._timeouts.get(key);
      if (timeout) window.clearTimeout(timeout);
    }
    clean() {
      this._timeouts.forEach((timeout) => void window.clearTimeout(timeout));
      this._timeouts.clear();
    }
  }
  let Controller$1 = class Controller {
    constructor(handlers) {
      _defineProperty(this, "gestures", /* @__PURE__ */ new Set());
      _defineProperty(this, "_targetEventStore", new EventStore(this));
      _defineProperty(this, "gestureEventStores", {});
      _defineProperty(this, "gestureTimeoutStores", {});
      _defineProperty(this, "handlers", {});
      _defineProperty(this, "config", {});
      _defineProperty(this, "pointerIds", /* @__PURE__ */ new Set());
      _defineProperty(this, "touchIds", /* @__PURE__ */ new Set());
      _defineProperty(this, "state", {
        shared: {
          shiftKey: false,
          metaKey: false,
          ctrlKey: false,
          altKey: false
        }
      });
      resolveGestures(this, handlers);
    }
    setEventIds(event) {
      if (isTouch(event)) {
        this.touchIds = new Set(touchIds(event));
        return this.touchIds;
      } else if ("pointerId" in event) {
        if (event.type === "pointerup" || event.type === "pointercancel") this.pointerIds.delete(event.pointerId);
        else if (event.type === "pointerdown") this.pointerIds.add(event.pointerId);
        return this.pointerIds;
      }
    }
    applyHandlers(handlers, nativeHandlers) {
      this.handlers = handlers;
      this.nativeHandlers = nativeHandlers;
    }
    applyConfig(config2, gestureKey) {
      this.config = parse(config2, gestureKey, this.config);
    }
    clean() {
      this._targetEventStore.clean();
      for (const key of this.gestures) {
        this.gestureEventStores[key].clean();
        this.gestureTimeoutStores[key].clean();
      }
    }
    effect() {
      if (this.config.shared.target) this.bind();
      return () => this._targetEventStore.clean();
    }
    bind(...args) {
      const sharedConfig = this.config.shared;
      const props = {};
      let target;
      if (sharedConfig.target) {
        target = sharedConfig.target();
        if (!target) return;
      }
      if (sharedConfig.enabled) {
        for (const gestureKey of this.gestures) {
          const gestureConfig = this.config[gestureKey];
          const bindFunction = bindToProps(props, gestureConfig.eventOptions, !!target);
          if (gestureConfig.enabled) {
            const Engine2 = EngineMap.get(gestureKey);
            new Engine2(this, args, gestureKey).bind(bindFunction);
          }
        }
        const nativeBindFunction = bindToProps(props, sharedConfig.eventOptions, !!target);
        for (const eventKey in this.nativeHandlers) {
          nativeBindFunction(eventKey, "", (event) => this.nativeHandlers[eventKey](_objectSpread2(_objectSpread2({}, this.state.shared), {}, {
            event,
            args
          })), void 0, true);
        }
      }
      for (const handlerProp in props) {
        props[handlerProp] = chain(...props[handlerProp]);
      }
      if (!target) return props;
      for (const handlerProp in props) {
        const {
          device,
          capture,
          passive
        } = parseProp(handlerProp);
        this._targetEventStore.add(target, device, "", props[handlerProp], {
          capture,
          passive
        });
      }
    }
  };
  function setupGesture(ctrl, gestureKey) {
    ctrl.gestures.add(gestureKey);
    ctrl.gestureEventStores[gestureKey] = new EventStore(ctrl, gestureKey);
    ctrl.gestureTimeoutStores[gestureKey] = new TimeoutStore();
  }
  function resolveGestures(ctrl, internalHandlers) {
    if (internalHandlers.drag) setupGesture(ctrl, "drag");
    if (internalHandlers.wheel) setupGesture(ctrl, "wheel");
    if (internalHandlers.scroll) setupGesture(ctrl, "scroll");
    if (internalHandlers.move) setupGesture(ctrl, "move");
    if (internalHandlers.pinch) setupGesture(ctrl, "pinch");
    if (internalHandlers.hover) setupGesture(ctrl, "hover");
  }
  const bindToProps = (props, eventOptions, withPassiveOption) => (device, action, handler, options2 = {}, isNative = false) => {
    var _options$capture, _options$passive;
    const capture = (_options$capture = options2.capture) !== null && _options$capture !== void 0 ? _options$capture : eventOptions.capture;
    const passive = (_options$passive = options2.passive) !== null && _options$passive !== void 0 ? _options$passive : eventOptions.passive;
    let handlerProp = isNative ? device : toHandlerProp(device, action, capture);
    if (withPassiveOption && passive) handlerProp += "Passive";
    props[handlerProp] = props[handlerProp] || [];
    props[handlerProp].push(handler);
  };
  const RE_NOT_NATIVE = /^on(Drag|Wheel|Scroll|Move|Pinch|Hover)/;
  function sortHandlers(_handlers) {
    const native = {};
    const handlers = {};
    const actions = /* @__PURE__ */ new Set();
    for (let key in _handlers) {
      if (RE_NOT_NATIVE.test(key)) {
        actions.add(RegExp.lastMatch);
        handlers[key] = _handlers[key];
      } else {
        native[key] = _handlers[key];
      }
    }
    return [handlers, native, actions];
  }
  function registerGesture(actions, handlers, handlerKey, key, internalHandlers, config2) {
    if (!actions.has(handlerKey)) return;
    if (!EngineMap.has(key)) {
      return;
    }
    const startKey = handlerKey + "Start";
    const endKey = handlerKey + "End";
    const fn = (state) => {
      let memo = void 0;
      if (state.first && startKey in handlers) handlers[startKey](state);
      if (handlerKey in handlers) memo = handlers[handlerKey](state);
      if (state.last && endKey in handlers) handlers[endKey](state);
      return memo;
    };
    internalHandlers[key] = fn;
    config2[key] = config2[key] || {};
  }
  function parseMergedHandlers(mergedHandlers, mergedConfig) {
    const [handlers, nativeHandlers, actions] = sortHandlers(mergedHandlers);
    const internalHandlers = {};
    registerGesture(actions, handlers, "onDrag", "drag", internalHandlers, mergedConfig);
    registerGesture(actions, handlers, "onWheel", "wheel", internalHandlers, mergedConfig);
    registerGesture(actions, handlers, "onScroll", "scroll", internalHandlers, mergedConfig);
    registerGesture(actions, handlers, "onPinch", "pinch", internalHandlers, mergedConfig);
    registerGesture(actions, handlers, "onMove", "move", internalHandlers, mergedConfig);
    registerGesture(actions, handlers, "onHover", "hover", internalHandlers, mergedConfig);
    return {
      handlers: internalHandlers,
      config: mergedConfig,
      nativeHandlers
    };
  }
  function useRecognizers(handlers, config2 = {}, gestureKey, nativeHandlers) {
    const ctrl = React.useMemo(() => new Controller$1(handlers), []);
    ctrl.applyHandlers(handlers, nativeHandlers);
    ctrl.applyConfig(config2, gestureKey);
    React.useEffect(ctrl.effect.bind(ctrl));
    React.useEffect(() => {
      return ctrl.clean.bind(ctrl);
    }, []);
    if (config2.target === void 0) {
      return ctrl.bind.bind(ctrl);
    }
    return void 0;
  }
  function useDrag(handler, config2) {
    registerAction(dragAction);
    return useRecognizers({
      drag: handler
    }, config2 || {}, "drag");
  }
  function createUseGesture(actions) {
    actions.forEach(registerAction);
    return function useGesture2(_handlers, _config) {
      const {
        handlers,
        nativeHandlers,
        config: config2
      } = parseMergedHandlers(_handlers, _config || {});
      return useRecognizers(handlers, config2, void 0, nativeHandlers);
    };
  }
  function useGesture(handlers, config2) {
    const hook = createUseGesture([dragAction, pinchAction, scrollAction, wheelAction, moveAction, hoverAction]);
    return hook(handlers, {});
  }
  let updateQueue = makeQueue();
  const raf = (fn) => schedule(fn, updateQueue);
  let writeQueue = makeQueue();
  raf.write = (fn) => schedule(fn, writeQueue);
  let onStartQueue = makeQueue();
  raf.onStart = (fn) => schedule(fn, onStartQueue);
  let onFrameQueue = makeQueue();
  raf.onFrame = (fn) => schedule(fn, onFrameQueue);
  let onFinishQueue = makeQueue();
  raf.onFinish = (fn) => schedule(fn, onFinishQueue);
  let timeouts = [];
  raf.setTimeout = (handler, ms) => {
    let time = raf.now() + ms;
    let cancel = () => {
      let i2 = timeouts.findIndex((t) => t.cancel == cancel);
      if (~i2) timeouts.splice(i2, 1);
      pendingCount -= ~i2 ? 1 : 0;
    };
    let timeout = {
      time,
      handler,
      cancel
    };
    timeouts.splice(findTimeout(time), 0, timeout);
    pendingCount += 1;
    start();
    return timeout;
  };
  let findTimeout = (time) => ~(~timeouts.findIndex((t) => t.time > time) || ~timeouts.length);
  raf.cancel = (fn) => {
    onStartQueue.delete(fn);
    onFrameQueue.delete(fn);
    onFinishQueue.delete(fn);
    updateQueue.delete(fn);
    writeQueue.delete(fn);
  };
  raf.sync = (fn) => {
    sync = true;
    raf.batchedUpdates(fn);
    sync = false;
  };
  raf.throttle = (fn) => {
    let lastArgs;
    function queuedFn() {
      try {
        fn(...lastArgs);
      } finally {
        lastArgs = null;
      }
    }
    function throttled(...args) {
      lastArgs = args;
      raf.onStart(queuedFn);
    }
    throttled.handler = fn;
    throttled.cancel = () => {
      onStartQueue.delete(queuedFn);
      lastArgs = null;
    };
    return throttled;
  };
  let nativeRaf = typeof window != "undefined" ? window.requestAnimationFrame : () => {
  };
  raf.use = (impl) => nativeRaf = impl;
  raf.now = typeof performance != "undefined" ? () => performance.now() : Date.now;
  raf.batchedUpdates = (fn) => fn();
  raf.catch = console.error;
  raf.frameLoop = "always";
  raf.advance = () => {
    if (raf.frameLoop !== "demand") {
      console.warn("Cannot call the manual advancement of rafz whilst frameLoop is not set as demand");
    } else {
      update();
    }
  };
  let ts = -1;
  let pendingCount = 0;
  let sync = false;
  function schedule(fn, queue) {
    if (sync) {
      queue.delete(fn);
      fn(0);
    } else {
      queue.add(fn);
      start();
    }
  }
  function start() {
    if (ts < 0) {
      ts = 0;
      if (raf.frameLoop !== "demand") {
        nativeRaf(loop);
      }
    }
  }
  function stop() {
    ts = -1;
  }
  function loop() {
    if (~ts) {
      nativeRaf(loop);
      raf.batchedUpdates(update);
    }
  }
  function update() {
    let prevTs = ts;
    ts = raf.now();
    let count = findTimeout(ts);
    if (count) {
      eachSafely(timeouts.splice(0, count), (t) => t.handler());
      pendingCount -= count;
    }
    if (!pendingCount) {
      stop();
      return;
    }
    onStartQueue.flush();
    updateQueue.flush(prevTs ? Math.min(64, ts - prevTs) : 16.667);
    onFrameQueue.flush();
    writeQueue.flush();
    onFinishQueue.flush();
  }
  function makeQueue() {
    let next = /* @__PURE__ */ new Set();
    let current = next;
    return {
      add(fn) {
        pendingCount += current == next && !next.has(fn) ? 1 : 0;
        next.add(fn);
      },
      delete(fn) {
        pendingCount -= current == next && next.has(fn) ? 1 : 0;
        return next.delete(fn);
      },
      flush(arg) {
        if (current.size) {
          next = /* @__PURE__ */ new Set();
          pendingCount -= current.size;
          eachSafely(current, (fn) => fn(arg) && next.add(fn));
          pendingCount += next.size;
          current = next;
        }
      }
    };
  }
  function eachSafely(values, each2) {
    values.forEach((value) => {
      try {
        each2(value);
      } catch (e) {
        raf.catch(e);
      }
    });
  }
  function noop() {
  }
  const defineHidden = (obj, key, value) => Object.defineProperty(obj, key, {
    value,
    writable: true,
    configurable: true
  });
  const is = {
    arr: Array.isArray,
    obj: (a) => !!a && a.constructor.name === "Object",
    fun: (a) => typeof a === "function",
    str: (a) => typeof a === "string",
    num: (a) => typeof a === "number",
    und: (a) => a === void 0
  };
  function isEqual$1(a, b) {
    if (is.arr(a)) {
      if (!is.arr(b) || a.length !== b.length) return false;
      for (let i2 = 0; i2 < a.length; i2++) {
        if (a[i2] !== b[i2]) return false;
      }
      return true;
    }
    return a === b;
  }
  const each = (obj, fn) => obj.forEach(fn);
  function eachProp(obj, fn, ctx2) {
    if (is.arr(obj)) {
      for (let i2 = 0; i2 < obj.length; i2++) {
        fn.call(ctx2, obj[i2], `${i2}`);
      }
      return;
    }
    for (const key in obj) {
      if (obj.hasOwnProperty(key)) {
        fn.call(ctx2, obj[key], key);
      }
    }
  }
  const toArray$1 = (a) => is.und(a) ? [] : is.arr(a) ? a : [a];
  function flush(queue, iterator) {
    if (queue.size) {
      const items = Array.from(queue);
      queue.clear();
      each(items, iterator);
    }
  }
  const flushCalls = (queue, ...args) => flush(queue, (fn) => fn(...args));
  const isSSR = () => typeof window === "undefined" || !window.navigator || /ServerSideRendering|^Deno\//.test(window.navigator.userAgent);
  let createStringInterpolator$1;
  let to;
  let colors$1 = null;
  let skipAnimation = false;
  let willAdvance = noop;
  const assign = (globals2) => {
    if (globals2.to) to = globals2.to;
    if (globals2.now) raf.now = globals2.now;
    if (globals2.colors !== void 0) colors$1 = globals2.colors;
    if (globals2.skipAnimation != null) skipAnimation = globals2.skipAnimation;
    if (globals2.createStringInterpolator) createStringInterpolator$1 = globals2.createStringInterpolator;
    if (globals2.requestAnimationFrame) raf.use(globals2.requestAnimationFrame);
    if (globals2.batchedUpdates) raf.batchedUpdates = globals2.batchedUpdates;
    if (globals2.willAdvance) willAdvance = globals2.willAdvance;
    if (globals2.frameLoop) raf.frameLoop = globals2.frameLoop;
  };
  var globals = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    get createStringInterpolator() {
      return createStringInterpolator$1;
    },
    get to() {
      return to;
    },
    get colors() {
      return colors$1;
    },
    get skipAnimation() {
      return skipAnimation;
    },
    get willAdvance() {
      return willAdvance;
    },
    assign
  });
  const startQueue = /* @__PURE__ */ new Set();
  let currentFrame = [];
  let prevFrame = [];
  let priority = 0;
  const frameLoop = {
    get idle() {
      return !startQueue.size && !currentFrame.length;
    },
    start(animation) {
      if (priority > animation.priority) {
        startQueue.add(animation);
        raf.onStart(flushStartQueue);
      } else {
        startSafely(animation);
        raf(advance);
      }
    },
    advance,
    sort(animation) {
      if (priority) {
        raf.onFrame(() => frameLoop.sort(animation));
      } else {
        const prevIndex = currentFrame.indexOf(animation);
        if (~prevIndex) {
          currentFrame.splice(prevIndex, 1);
          startUnsafely(animation);
        }
      }
    },
    clear() {
      currentFrame = [];
      startQueue.clear();
    }
  };
  function flushStartQueue() {
    startQueue.forEach(startSafely);
    startQueue.clear();
    raf(advance);
  }
  function startSafely(animation) {
    if (!currentFrame.includes(animation)) startUnsafely(animation);
  }
  function startUnsafely(animation) {
    currentFrame.splice(findIndex(currentFrame, (other) => other.priority > animation.priority), 0, animation);
  }
  function advance(dt) {
    const nextFrame = prevFrame;
    for (let i2 = 0; i2 < currentFrame.length; i2++) {
      const animation = currentFrame[i2];
      priority = animation.priority;
      if (!animation.idle) {
        willAdvance(animation);
        animation.advance(dt);
        if (!animation.idle) {
          nextFrame.push(animation);
        }
      }
    }
    priority = 0;
    prevFrame = currentFrame;
    prevFrame.length = 0;
    currentFrame = nextFrame;
    return currentFrame.length > 0;
  }
  function findIndex(arr, test) {
    const index = arr.findIndex(test);
    return index < 0 ? arr.length : index;
  }
  const clamp$1 = (min, max, v) => Math.min(Math.max(v, min), max);
  const colors = {
    transparent: 0,
    aliceblue: 4042850303,
    antiquewhite: 4209760255,
    aqua: 16777215,
    aquamarine: 2147472639,
    azure: 4043309055,
    beige: 4126530815,
    bisque: 4293182719,
    black: 255,
    blanchedalmond: 4293643775,
    blue: 65535,
    blueviolet: 2318131967,
    brown: 2771004159,
    burlywood: 3736635391,
    burntsienna: 3934150143,
    cadetblue: 1604231423,
    chartreuse: 2147418367,
    chocolate: 3530104575,
    coral: 4286533887,
    cornflowerblue: 1687547391,
    cornsilk: 4294499583,
    crimson: 3692313855,
    cyan: 16777215,
    darkblue: 35839,
    darkcyan: 9145343,
    darkgoldenrod: 3095792639,
    darkgray: 2846468607,
    darkgreen: 6553855,
    darkgrey: 2846468607,
    darkkhaki: 3182914559,
    darkmagenta: 2332068863,
    darkolivegreen: 1433087999,
    darkorange: 4287365375,
    darkorchid: 2570243327,
    darkred: 2332033279,
    darksalmon: 3918953215,
    darkseagreen: 2411499519,
    darkslateblue: 1211993087,
    darkslategray: 793726975,
    darkslategrey: 793726975,
    darkturquoise: 13554175,
    darkviolet: 2483082239,
    deeppink: 4279538687,
    deepskyblue: 12582911,
    dimgray: 1768516095,
    dimgrey: 1768516095,
    dodgerblue: 512819199,
    firebrick: 2988581631,
    floralwhite: 4294635775,
    forestgreen: 579543807,
    fuchsia: 4278255615,
    gainsboro: 3705462015,
    ghostwhite: 4177068031,
    gold: 4292280575,
    goldenrod: 3668254975,
    gray: 2155905279,
    green: 8388863,
    greenyellow: 2919182335,
    grey: 2155905279,
    honeydew: 4043305215,
    hotpink: 4285117695,
    indianred: 3445382399,
    indigo: 1258324735,
    ivory: 4294963455,
    khaki: 4041641215,
    lavender: 3873897215,
    lavenderblush: 4293981695,
    lawngreen: 2096890111,
    lemonchiffon: 4294626815,
    lightblue: 2916673279,
    lightcoral: 4034953471,
    lightcyan: 3774873599,
    lightgoldenrodyellow: 4210742015,
    lightgray: 3553874943,
    lightgreen: 2431553791,
    lightgrey: 3553874943,
    lightpink: 4290167295,
    lightsalmon: 4288707327,
    lightseagreen: 548580095,
    lightskyblue: 2278488831,
    lightslategray: 2005441023,
    lightslategrey: 2005441023,
    lightsteelblue: 2965692159,
    lightyellow: 4294959359,
    lime: 16711935,
    limegreen: 852308735,
    linen: 4210091775,
    magenta: 4278255615,
    maroon: 2147483903,
    mediumaquamarine: 1724754687,
    mediumblue: 52735,
    mediumorchid: 3126187007,
    mediumpurple: 2473647103,
    mediumseagreen: 1018393087,
    mediumslateblue: 2070474495,
    mediumspringgreen: 16423679,
    mediumturquoise: 1221709055,
    mediumvioletred: 3340076543,
    midnightblue: 421097727,
    mintcream: 4127193855,
    mistyrose: 4293190143,
    moccasin: 4293178879,
    navajowhite: 4292783615,
    navy: 33023,
    oldlace: 4260751103,
    olive: 2155872511,
    olivedrab: 1804477439,
    orange: 4289003775,
    orangered: 4282712319,
    orchid: 3664828159,
    palegoldenrod: 4008225535,
    palegreen: 2566625535,
    paleturquoise: 2951671551,
    palevioletred: 3681588223,
    papayawhip: 4293907967,
    peachpuff: 4292524543,
    peru: 3448061951,
    pink: 4290825215,
    plum: 3718307327,
    powderblue: 2967529215,
    purple: 2147516671,
    rebeccapurple: 1714657791,
    red: 4278190335,
    rosybrown: 3163525119,
    royalblue: 1097458175,
    saddlebrown: 2336560127,
    salmon: 4202722047,
    sandybrown: 4104413439,
    seagreen: 780883967,
    seashell: 4294307583,
    sienna: 2689740287,
    silver: 3233857791,
    skyblue: 2278484991,
    slateblue: 1784335871,
    slategray: 1887473919,
    slategrey: 1887473919,
    snow: 4294638335,
    springgreen: 16744447,
    steelblue: 1182971135,
    tan: 3535047935,
    teal: 8421631,
    thistle: 3636451583,
    tomato: 4284696575,
    turquoise: 1088475391,
    violet: 4001558271,
    wheat: 4125012991,
    white: 4294967295,
    whitesmoke: 4126537215,
    yellow: 4294902015,
    yellowgreen: 2597139199
  };
  const NUMBER = "[-+]?\\d*\\.?\\d+";
  const PERCENTAGE = NUMBER + "%";
  function call(...parts) {
    return "\\(\\s*(" + parts.join(")\\s*,\\s*(") + ")\\s*\\)";
  }
  const rgb = new RegExp("rgb" + call(NUMBER, NUMBER, NUMBER));
  const rgba = new RegExp("rgba" + call(NUMBER, NUMBER, NUMBER, NUMBER));
  const hsl = new RegExp("hsl" + call(NUMBER, PERCENTAGE, PERCENTAGE));
  const hsla = new RegExp("hsla" + call(NUMBER, PERCENTAGE, PERCENTAGE, NUMBER));
  const hex3 = /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/;
  const hex4 = /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/;
  const hex6 = /^#([0-9a-fA-F]{6})$/;
  const hex8 = /^#([0-9a-fA-F]{8})$/;
  function normalizeColor(color) {
    let match;
    if (typeof color === "number") {
      return color >>> 0 === color && color >= 0 && color <= 4294967295 ? color : null;
    }
    if (match = hex6.exec(color)) return parseInt(match[1] + "ff", 16) >>> 0;
    if (colors$1 && colors$1[color] !== void 0) {
      return colors$1[color];
    }
    if (match = rgb.exec(color)) {
      return (parse255(match[1]) << 24 | parse255(match[2]) << 16 | parse255(match[3]) << 8 | 255) >>> 0;
    }
    if (match = rgba.exec(color)) {
      return (parse255(match[1]) << 24 | parse255(match[2]) << 16 | parse255(match[3]) << 8 | parse1(match[4])) >>> 0;
    }
    if (match = hex3.exec(color)) {
      return parseInt(match[1] + match[1] + match[2] + match[2] + match[3] + match[3] + "ff", 16) >>> 0;
    }
    if (match = hex8.exec(color)) return parseInt(match[1], 16) >>> 0;
    if (match = hex4.exec(color)) {
      return parseInt(match[1] + match[1] + match[2] + match[2] + match[3] + match[3] + match[4] + match[4], 16) >>> 0;
    }
    if (match = hsl.exec(color)) {
      return (hslToRgb(parse360(match[1]), parsePercentage(match[2]), parsePercentage(match[3])) | 255) >>> 0;
    }
    if (match = hsla.exec(color)) {
      return (hslToRgb(parse360(match[1]), parsePercentage(match[2]), parsePercentage(match[3])) | parse1(match[4])) >>> 0;
    }
    return null;
  }
  function hue2rgb(p2, q, t) {
    if (t < 0) t += 1;
    if (t > 1) t -= 1;
    if (t < 1 / 6) return p2 + (q - p2) * 6 * t;
    if (t < 1 / 2) return q;
    if (t < 2 / 3) return p2 + (q - p2) * (2 / 3 - t) * 6;
    return p2;
  }
  function hslToRgb(h, s2, l) {
    const q = l < 0.5 ? l * (1 + s2) : l + s2 - l * s2;
    const p2 = 2 * l - q;
    const r = hue2rgb(p2, q, h + 1 / 3);
    const g = hue2rgb(p2, q, h);
    const b = hue2rgb(p2, q, h - 1 / 3);
    return Math.round(r * 255) << 24 | Math.round(g * 255) << 16 | Math.round(b * 255) << 8;
  }
  function parse255(str) {
    const int = parseInt(str, 10);
    if (int < 0) return 0;
    if (int > 255) return 255;
    return int;
  }
  function parse360(str) {
    const int = parseFloat(str);
    return (int % 360 + 360) % 360 / 360;
  }
  function parse1(str) {
    const num = parseFloat(str);
    if (num < 0) return 0;
    if (num > 1) return 255;
    return Math.round(num * 255);
  }
  function parsePercentage(str) {
    const int = parseFloat(str);
    if (int < 0) return 0;
    if (int > 100) return 1;
    return int / 100;
  }
  function colorToRgba(input) {
    let int32Color = normalizeColor(input);
    if (int32Color === null) return input;
    int32Color = int32Color || 0;
    let r = (int32Color & 4278190080) >>> 24;
    let g = (int32Color & 16711680) >>> 16;
    let b = (int32Color & 65280) >>> 8;
    let a = (int32Color & 255) / 255;
    return `rgba(${r}, ${g}, ${b}, ${a})`;
  }
  const createInterpolator = (range2, output, extrapolate) => {
    if (is.fun(range2)) {
      return range2;
    }
    if (is.arr(range2)) {
      return createInterpolator({
        range: range2,
        output,
        extrapolate
      });
    }
    if (is.str(range2.output[0])) {
      return createStringInterpolator$1(range2);
    }
    const config2 = range2;
    const outputRange = config2.output;
    const inputRange = config2.range || [0, 1];
    const extrapolateLeft = config2.extrapolateLeft || config2.extrapolate || "extend";
    const extrapolateRight = config2.extrapolateRight || config2.extrapolate || "extend";
    const easing = config2.easing || ((t) => t);
    return (input) => {
      const range3 = findRange(input, inputRange);
      return interpolate(input, inputRange[range3], inputRange[range3 + 1], outputRange[range3], outputRange[range3 + 1], easing, extrapolateLeft, extrapolateRight, config2.map);
    };
  };
  function interpolate(input, inputMin, inputMax, outputMin, outputMax, easing, extrapolateLeft, extrapolateRight, map) {
    let result = map ? map(input) : input;
    if (result < inputMin) {
      if (extrapolateLeft === "identity") return result;
      else if (extrapolateLeft === "clamp") result = inputMin;
    }
    if (result > inputMax) {
      if (extrapolateRight === "identity") return result;
      else if (extrapolateRight === "clamp") result = inputMax;
    }
    if (outputMin === outputMax) return outputMin;
    if (inputMin === inputMax) return input <= inputMin ? outputMin : outputMax;
    if (inputMin === -Infinity) result = -result;
    else if (inputMax === Infinity) result = result - inputMin;
    else result = (result - inputMin) / (inputMax - inputMin);
    result = easing(result);
    if (outputMin === -Infinity) result = -result;
    else if (outputMax === Infinity) result = result + outputMin;
    else result = result * (outputMax - outputMin) + outputMin;
    return result;
  }
  function findRange(input, inputRange) {
    for (var i2 = 1; i2 < inputRange.length - 1; ++i2) if (inputRange[i2] >= input) break;
    return i2 - 1;
  }
  const steps = (steps2, direction = "end") => (progress) => {
    progress = direction === "end" ? Math.min(progress, 0.999) : Math.max(progress, 1e-3);
    const expanded = progress * steps2;
    const rounded = direction === "end" ? Math.floor(expanded) : Math.ceil(expanded);
    return clamp$1(0, 1, rounded / steps2);
  };
  const c1 = 1.70158;
  const c2 = c1 * 1.525;
  const c3 = c1 + 1;
  const c4 = 2 * Math.PI / 3;
  const c5 = 2 * Math.PI / 4.5;
  const bounceOut = (x) => {
    const n1 = 7.5625;
    const d1 = 2.75;
    if (x < 1 / d1) {
      return n1 * x * x;
    } else if (x < 2 / d1) {
      return n1 * (x -= 1.5 / d1) * x + 0.75;
    } else if (x < 2.5 / d1) {
      return n1 * (x -= 2.25 / d1) * x + 0.9375;
    } else {
      return n1 * (x -= 2.625 / d1) * x + 0.984375;
    }
  };
  const easings = {
    linear: (x) => x,
    easeInQuad: (x) => x * x,
    easeOutQuad: (x) => 1 - (1 - x) * (1 - x),
    easeInOutQuad: (x) => x < 0.5 ? 2 * x * x : 1 - Math.pow(-2 * x + 2, 2) / 2,
    easeInCubic: (x) => x * x * x,
    easeOutCubic: (x) => 1 - Math.pow(1 - x, 3),
    easeInOutCubic: (x) => x < 0.5 ? 4 * x * x * x : 1 - Math.pow(-2 * x + 2, 3) / 2,
    easeInQuart: (x) => x * x * x * x,
    easeOutQuart: (x) => 1 - Math.pow(1 - x, 4),
    easeInOutQuart: (x) => x < 0.5 ? 8 * x * x * x * x : 1 - Math.pow(-2 * x + 2, 4) / 2,
    easeInQuint: (x) => x * x * x * x * x,
    easeOutQuint: (x) => 1 - Math.pow(1 - x, 5),
    easeInOutQuint: (x) => x < 0.5 ? 16 * x * x * x * x * x : 1 - Math.pow(-2 * x + 2, 5) / 2,
    easeInSine: (x) => 1 - Math.cos(x * Math.PI / 2),
    easeOutSine: (x) => Math.sin(x * Math.PI / 2),
    easeInOutSine: (x) => -(Math.cos(Math.PI * x) - 1) / 2,
    easeInExpo: (x) => x === 0 ? 0 : Math.pow(2, 10 * x - 10),
    easeOutExpo: (x) => x === 1 ? 1 : 1 - Math.pow(2, -10 * x),
    easeInOutExpo: (x) => x === 0 ? 0 : x === 1 ? 1 : x < 0.5 ? Math.pow(2, 20 * x - 10) / 2 : (2 - Math.pow(2, -20 * x + 10)) / 2,
    easeInCirc: (x) => 1 - Math.sqrt(1 - Math.pow(x, 2)),
    easeOutCirc: (x) => Math.sqrt(1 - Math.pow(x - 1, 2)),
    easeInOutCirc: (x) => x < 0.5 ? (1 - Math.sqrt(1 - Math.pow(2 * x, 2))) / 2 : (Math.sqrt(1 - Math.pow(-2 * x + 2, 2)) + 1) / 2,
    easeInBack: (x) => c3 * x * x * x - c1 * x * x,
    easeOutBack: (x) => 1 + c3 * Math.pow(x - 1, 3) + c1 * Math.pow(x - 1, 2),
    easeInOutBack: (x) => x < 0.5 ? Math.pow(2 * x, 2) * ((c2 + 1) * 2 * x - c2) / 2 : (Math.pow(2 * x - 2, 2) * ((c2 + 1) * (x * 2 - 2) + c2) + 2) / 2,
    easeInElastic: (x) => x === 0 ? 0 : x === 1 ? 1 : -Math.pow(2, 10 * x - 10) * Math.sin((x * 10 - 10.75) * c4),
    easeOutElastic: (x) => x === 0 ? 0 : x === 1 ? 1 : Math.pow(2, -10 * x) * Math.sin((x * 10 - 0.75) * c4) + 1,
    easeInOutElastic: (x) => x === 0 ? 0 : x === 1 ? 1 : x < 0.5 ? -(Math.pow(2, 20 * x - 10) * Math.sin((20 * x - 11.125) * c5)) / 2 : Math.pow(2, -20 * x + 10) * Math.sin((20 * x - 11.125) * c5) / 2 + 1,
    easeInBounce: (x) => 1 - bounceOut(1 - x),
    easeOutBounce: bounceOut,
    easeInOutBounce: (x) => x < 0.5 ? (1 - bounceOut(1 - 2 * x)) / 2 : (1 + bounceOut(2 * x - 1)) / 2,
    steps
  };
  function _extends$3() {
    _extends$3 = Object.assign ? Object.assign.bind() : function(target) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        var source = arguments[i2];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends$3.apply(this, arguments);
  }
  const $get = Symbol.for("FluidValue.get");
  const $observers = Symbol.for("FluidValue.observers");
  const hasFluidValue = (arg) => Boolean(arg && arg[$get]);
  const getFluidValue = (arg) => arg && arg[$get] ? arg[$get]() : arg;
  const getFluidObservers = (target) => target[$observers] || null;
  function callFluidObserver(observer, event) {
    if (observer.eventObserved) {
      observer.eventObserved(event);
    } else {
      observer(event);
    }
  }
  function callFluidObservers(target, event) {
    let observers = target[$observers];
    if (observers) {
      observers.forEach((observer) => {
        callFluidObserver(observer, event);
      });
    }
  }
  class FluidValue {
    constructor(get) {
      this[$get] = void 0;
      this[$observers] = void 0;
      if (!get && !(get = this.get)) {
        throw Error("Unknown getter");
      }
      setFluidGetter(this, get);
    }
  }
  const setFluidGetter = (target, get) => setHidden(target, $get, get);
  function addFluidObserver(target, observer) {
    if (target[$get]) {
      let observers = target[$observers];
      if (!observers) {
        setHidden(target, $observers, observers = /* @__PURE__ */ new Set());
      }
      if (!observers.has(observer)) {
        observers.add(observer);
        if (target.observerAdded) {
          target.observerAdded(observers.size, observer);
        }
      }
    }
    return observer;
  }
  function removeFluidObserver(target, observer) {
    let observers = target[$observers];
    if (observers && observers.has(observer)) {
      const count = observers.size - 1;
      if (count) {
        observers.delete(observer);
      } else {
        target[$observers] = null;
      }
      if (target.observerRemoved) {
        target.observerRemoved(count, observer);
      }
    }
  }
  const setHidden = (target, key, value) => Object.defineProperty(target, key, {
    value,
    writable: true,
    configurable: true
  });
  const numberRegex = /[+\-]?(?:0|[1-9]\d*)(?:\.\d*)?(?:[eE][+\-]?\d+)?/g;
  const colorRegex = /(#(?:[0-9a-f]{2}){2,4}|(#[0-9a-f]{3})|(rgb|hsl)a?\((-?\d+%?[,\s]+){2,3}\s*[\d\.]+%?\))/gi;
  const unitRegex = new RegExp(`(${numberRegex.source})(%|[a-z]+)`, "i");
  const rgbaRegex = /rgba\(([0-9\.-]+), ([0-9\.-]+), ([0-9\.-]+), ([0-9\.-]+)\)/gi;
  const cssVariableRegex = /var\((--[a-zA-Z0-9-_]+),? ?([a-zA-Z0-9 ()%#.,-]+)?\)/;
  const variableToRgba = (input) => {
    const [token, fallback] = parseCSSVariable(input);
    if (!token || isSSR()) {
      return input;
    }
    const value = window.getComputedStyle(document.documentElement).getPropertyValue(token);
    if (value) {
      return value.trim();
    } else if (fallback && fallback.startsWith("--")) {
      const _value = window.getComputedStyle(document.documentElement).getPropertyValue(fallback);
      if (_value) {
        return _value;
      } else {
        return input;
      }
    } else if (fallback && cssVariableRegex.test(fallback)) {
      return variableToRgba(fallback);
    } else if (fallback) {
      return fallback;
    }
    return input;
  };
  const parseCSSVariable = (current) => {
    const match = cssVariableRegex.exec(current);
    if (!match) return [,];
    const [, token, fallback] = match;
    return [token, fallback];
  };
  let namedColorRegex;
  const rgbaRound = (_, p1, p2, p3, p4) => `rgba(${Math.round(p1)}, ${Math.round(p2)}, ${Math.round(p3)}, ${p4})`;
  const createStringInterpolator = (config2) => {
    if (!namedColorRegex) namedColorRegex = colors$1 ? new RegExp(`(${Object.keys(colors$1).join("|")})(?!\\w)`, "g") : /^\b$/;
    const output = config2.output.map((value) => {
      return getFluidValue(value).replace(cssVariableRegex, variableToRgba).replace(colorRegex, colorToRgba).replace(namedColorRegex, colorToRgba);
    });
    const keyframes = output.map((value) => value.match(numberRegex).map(Number));
    const outputRanges = keyframes[0].map((_, i2) => keyframes.map((values) => {
      if (!(i2 in values)) {
        throw Error('The arity of each "output" value must be equal');
      }
      return values[i2];
    }));
    const interpolators = outputRanges.map((output2) => createInterpolator(_extends$3({}, config2, {
      output: output2
    })));
    return (input) => {
      var _output$find;
      const missingUnit = !unitRegex.test(output[0]) && ((_output$find = output.find((value) => unitRegex.test(value))) == null ? void 0 : _output$find.replace(numberRegex, ""));
      let i2 = 0;
      return output[0].replace(numberRegex, () => `${interpolators[i2++](input)}${missingUnit || ""}`).replace(rgbaRegex, rgbaRound);
    };
  };
  const prefix = "react-spring: ";
  const once = (fn) => {
    const func = fn;
    let called = false;
    if (typeof func != "function") {
      throw new TypeError(`${prefix}once requires a function parameter`);
    }
    return (...args) => {
      if (!called) {
        func(...args);
        called = true;
      }
    };
  };
  const warnInterpolate = once(console.warn);
  function deprecateInterpolate() {
    warnInterpolate(`${prefix}The "interpolate" function is deprecated in v9 (use "to" instead)`);
  }
  const warnDirectCall = once(console.warn);
  function deprecateDirectCall() {
    warnDirectCall(`${prefix}Directly calling start instead of using the api object is deprecated in v9 (use ".start" instead), this will be removed in later 0.X.0 versions`);
  }
  function isAnimatedString(value) {
    return is.str(value) && (value[0] == "#" || /\d/.test(value) || !isSSR() && cssVariableRegex.test(value) || value in (colors$1 || {}));
  }
  const useIsomorphicLayoutEffect$1 = isSSR() ? React.useEffect : React.useLayoutEffect;
  const useIsMounted = () => {
    const isMounted = React.useRef(false);
    useIsomorphicLayoutEffect$1(() => {
      isMounted.current = true;
      return () => {
        isMounted.current = false;
      };
    }, []);
    return isMounted;
  };
  function useForceUpdate$1() {
    const update2 = React.useState()[1];
    const isMounted = useIsMounted();
    return () => {
      if (isMounted.current) {
        update2(Math.random());
      }
    };
  }
  function useMemoOne(getResult, inputs) {
    const [initial] = React.useState(() => ({
      inputs,
      result: getResult()
    }));
    const committed = React.useRef();
    const prevCache = committed.current;
    let cache = prevCache;
    if (cache) {
      const useCache = Boolean(inputs && cache.inputs && areInputsEqual(inputs, cache.inputs));
      if (!useCache) {
        cache = {
          inputs,
          result: getResult()
        };
      }
    } else {
      cache = initial;
    }
    React.useEffect(() => {
      committed.current = cache;
      if (prevCache == initial) {
        initial.inputs = initial.result = void 0;
      }
    }, [cache]);
    return cache.result;
  }
  function areInputsEqual(next, prev) {
    if (next.length !== prev.length) {
      return false;
    }
    for (let i2 = 0; i2 < next.length; i2++) {
      if (next[i2] !== prev[i2]) {
        return false;
      }
    }
    return true;
  }
  const useOnce = (effect) => React.useEffect(effect, emptyDeps);
  const emptyDeps = [];
  function usePrev(value) {
    const prevRef = React.useRef();
    React.useEffect(() => {
      prevRef.current = value;
    });
    return prevRef.current;
  }
  const $node = Symbol.for("Animated:node");
  const isAnimated = (value) => !!value && value[$node] === value;
  const getAnimated = (owner) => owner && owner[$node];
  const setAnimated = (owner, node) => defineHidden(owner, $node, node);
  const getPayload = (owner) => owner && owner[$node] && owner[$node].getPayload();
  class Animated {
    constructor() {
      this.payload = void 0;
      setAnimated(this, this);
    }
    getPayload() {
      return this.payload || [];
    }
  }
  class AnimatedValue extends Animated {
    constructor(_value) {
      super();
      this.done = true;
      this.elapsedTime = void 0;
      this.lastPosition = void 0;
      this.lastVelocity = void 0;
      this.v0 = void 0;
      this.durationProgress = 0;
      this._value = _value;
      if (is.num(this._value)) {
        this.lastPosition = this._value;
      }
    }
    static create(value) {
      return new AnimatedValue(value);
    }
    getPayload() {
      return [this];
    }
    getValue() {
      return this._value;
    }
    setValue(value, step) {
      if (is.num(value)) {
        this.lastPosition = value;
        if (step) {
          value = Math.round(value / step) * step;
          if (this.done) {
            this.lastPosition = value;
          }
        }
      }
      if (this._value === value) {
        return false;
      }
      this._value = value;
      return true;
    }
    reset() {
      const {
        done
      } = this;
      this.done = false;
      if (is.num(this._value)) {
        this.elapsedTime = 0;
        this.durationProgress = 0;
        this.lastPosition = this._value;
        if (done) this.lastVelocity = null;
        this.v0 = null;
      }
    }
  }
  class AnimatedString extends AnimatedValue {
    constructor(value) {
      super(0);
      this._string = null;
      this._toString = void 0;
      this._toString = createInterpolator({
        output: [value, value]
      });
    }
    static create(value) {
      return new AnimatedString(value);
    }
    getValue() {
      let value = this._string;
      return value == null ? this._string = this._toString(this._value) : value;
    }
    setValue(value) {
      if (is.str(value)) {
        if (value == this._string) {
          return false;
        }
        this._string = value;
        this._value = 1;
      } else if (super.setValue(value)) {
        this._string = null;
      } else {
        return false;
      }
      return true;
    }
    reset(goal) {
      if (goal) {
        this._toString = createInterpolator({
          output: [this.getValue(), goal]
        });
      }
      this._value = 0;
      super.reset();
    }
  }
  const TreeContext = {
    dependencies: null
  };
  class AnimatedObject extends Animated {
    constructor(source) {
      super();
      this.source = source;
      this.setValue(source);
    }
    getValue(animated2) {
      const values = {};
      eachProp(this.source, (source, key) => {
        if (isAnimated(source)) {
          values[key] = source.getValue(animated2);
        } else if (hasFluidValue(source)) {
          values[key] = getFluidValue(source);
        } else if (!animated2) {
          values[key] = source;
        }
      });
      return values;
    }
    setValue(source) {
      this.source = source;
      this.payload = this._makePayload(source);
    }
    reset() {
      if (this.payload) {
        each(this.payload, (node) => node.reset());
      }
    }
    _makePayload(source) {
      if (source) {
        const payload = /* @__PURE__ */ new Set();
        eachProp(source, this._addToPayload, payload);
        return Array.from(payload);
      }
    }
    _addToPayload(source) {
      if (TreeContext.dependencies && hasFluidValue(source)) {
        TreeContext.dependencies.add(source);
      }
      const payload = getPayload(source);
      if (payload) {
        each(payload, (node) => this.add(node));
      }
    }
  }
  class AnimatedArray extends AnimatedObject {
    constructor(source) {
      super(source);
    }
    static create(source) {
      return new AnimatedArray(source);
    }
    getValue() {
      return this.source.map((node) => node.getValue());
    }
    setValue(source) {
      const payload = this.getPayload();
      if (source.length == payload.length) {
        return payload.map((node, i2) => node.setValue(source[i2])).some(Boolean);
      }
      super.setValue(source.map(makeAnimated));
      return true;
    }
  }
  function makeAnimated(value) {
    const nodeType = isAnimatedString(value) ? AnimatedString : AnimatedValue;
    return nodeType.create(value);
  }
  function getAnimatedType(value) {
    const parentNode = getAnimated(value);
    return parentNode ? parentNode.constructor : is.arr(value) ? AnimatedArray : isAnimatedString(value) ? AnimatedString : AnimatedValue;
  }
  function _extends$2() {
    _extends$2 = Object.assign ? Object.assign.bind() : function(target) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        var source = arguments[i2];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends$2.apply(this, arguments);
  }
  const withAnimated = (Component, host2) => {
    const hasInstance = !is.fun(Component) || Component.prototype && Component.prototype.isReactComponent;
    return React.forwardRef((givenProps, givenRef) => {
      const instanceRef = React.useRef(null);
      const ref = hasInstance && React.useCallback((value) => {
        instanceRef.current = updateRef(givenRef, value);
      }, [givenRef]);
      const [props, deps] = getAnimatedState(givenProps, host2);
      const forceUpdate = useForceUpdate$1();
      const callback = () => {
        const instance = instanceRef.current;
        if (hasInstance && !instance) {
          return;
        }
        const didUpdate = instance ? host2.applyAnimatedValues(instance, props.getValue(true)) : false;
        if (didUpdate === false) {
          forceUpdate();
        }
      };
      const observer = new PropsObserver(callback, deps);
      const observerRef = React.useRef();
      useIsomorphicLayoutEffect$1(() => {
        observerRef.current = observer;
        each(deps, (dep) => addFluidObserver(dep, observer));
        return () => {
          if (observerRef.current) {
            each(observerRef.current.deps, (dep) => removeFluidObserver(dep, observerRef.current));
            raf.cancel(observerRef.current.update);
          }
        };
      });
      React.useEffect(callback, []);
      useOnce(() => () => {
        const observer2 = observerRef.current;
        each(observer2.deps, (dep) => removeFluidObserver(dep, observer2));
      });
      const usedProps = host2.getComponentProps(props.getValue());
      return React__namespace.createElement(Component, _extends$2({}, usedProps, {
        ref
      }));
    });
  };
  class PropsObserver {
    constructor(update2, deps) {
      this.update = update2;
      this.deps = deps;
    }
    eventObserved(event) {
      if (event.type == "change") {
        raf.write(this.update);
      }
    }
  }
  function getAnimatedState(props, host2) {
    const dependencies = /* @__PURE__ */ new Set();
    TreeContext.dependencies = dependencies;
    if (props.style) props = _extends$2({}, props, {
      style: host2.createAnimatedStyle(props.style)
    });
    props = new AnimatedObject(props);
    TreeContext.dependencies = null;
    return [props, dependencies];
  }
  function updateRef(ref, value) {
    if (ref) {
      if (is.fun(ref)) ref(value);
      else ref.current = value;
    }
    return value;
  }
  const cacheKey = Symbol.for("AnimatedComponent");
  const createHost = (components, {
    applyAnimatedValues: _applyAnimatedValues = () => false,
    createAnimatedStyle: _createAnimatedStyle = (style) => new AnimatedObject(style),
    getComponentProps: _getComponentProps = (props) => props
  } = {}) => {
    const hostConfig = {
      applyAnimatedValues: _applyAnimatedValues,
      createAnimatedStyle: _createAnimatedStyle,
      getComponentProps: _getComponentProps
    };
    const animated2 = (Component) => {
      const displayName = getDisplayName(Component) || "Anonymous";
      if (is.str(Component)) {
        Component = animated2[Component] || (animated2[Component] = withAnimated(Component, hostConfig));
      } else {
        Component = Component[cacheKey] || (Component[cacheKey] = withAnimated(Component, hostConfig));
      }
      Component.displayName = `Animated(${displayName})`;
      return Component;
    };
    eachProp(components, (Component, key) => {
      if (is.arr(components)) {
        key = getDisplayName(Component);
      }
      animated2[key] = animated2(Component);
    });
    return {
      animated: animated2
    };
  };
  const getDisplayName = (arg) => is.str(arg) ? arg : arg && is.str(arg.displayName) ? arg.displayName : is.fun(arg) && arg.name || null;
  function _extends$1() {
    _extends$1 = Object.assign ? Object.assign.bind() : function(target) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        var source = arguments[i2];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends$1.apply(this, arguments);
  }
  function callProp(value, ...args) {
    return is.fun(value) ? value(...args) : value;
  }
  const matchProp = (value, key) => value === true || !!(key && value && (is.fun(value) ? value(key) : toArray$1(value).includes(key)));
  const resolveProp = (prop, key) => is.obj(prop) ? key && prop[key] : prop;
  const getDefaultProp = (props, key) => props.default === true ? props[key] : props.default ? props.default[key] : void 0;
  const noopTransform = (value) => value;
  const getDefaultProps = (props, transform = noopTransform) => {
    let keys = DEFAULT_PROPS;
    if (props.default && props.default !== true) {
      props = props.default;
      keys = Object.keys(props);
    }
    const defaults2 = {};
    for (const key of keys) {
      const value = transform(props[key], key);
      if (!is.und(value)) {
        defaults2[key] = value;
      }
    }
    return defaults2;
  };
  const DEFAULT_PROPS = ["config", "onProps", "onStart", "onChange", "onPause", "onResume", "onRest"];
  const RESERVED_PROPS = {
    config: 1,
    from: 1,
    to: 1,
    ref: 1,
    loop: 1,
    reset: 1,
    pause: 1,
    cancel: 1,
    reverse: 1,
    immediate: 1,
    default: 1,
    delay: 1,
    onProps: 1,
    onStart: 1,
    onChange: 1,
    onPause: 1,
    onResume: 1,
    onRest: 1,
    onResolve: 1,
    items: 1,
    trail: 1,
    sort: 1,
    expires: 1,
    initial: 1,
    enter: 1,
    update: 1,
    leave: 1,
    children: 1,
    onDestroyed: 1,
    keys: 1,
    callId: 1,
    parentId: 1
  };
  function getForwardProps(props) {
    const forward = {};
    let count = 0;
    eachProp(props, (value, prop) => {
      if (!RESERVED_PROPS[prop]) {
        forward[prop] = value;
        count++;
      }
    });
    if (count) {
      return forward;
    }
  }
  function inferTo(props) {
    const to2 = getForwardProps(props);
    if (to2) {
      const out = {
        to: to2
      };
      eachProp(props, (val, key) => key in to2 || (out[key] = val));
      return out;
    }
    return _extends$1({}, props);
  }
  function computeGoal(value) {
    value = getFluidValue(value);
    return is.arr(value) ? value.map(computeGoal) : isAnimatedString(value) ? globals.createStringInterpolator({
      range: [0, 1],
      output: [value, value]
    })(1) : value;
  }
  function hasProps(props) {
    for (const _ in props) return true;
    return false;
  }
  function isAsyncTo(to2) {
    return is.fun(to2) || is.arr(to2) && is.obj(to2[0]);
  }
  function detachRefs(ctrl, ref) {
    var _ctrl$ref;
    (_ctrl$ref = ctrl.ref) == null ? void 0 : _ctrl$ref.delete(ctrl);
    ref == null ? void 0 : ref.delete(ctrl);
  }
  function replaceRef(ctrl, ref) {
    if (ref && ctrl.ref !== ref) {
      var _ctrl$ref2;
      (_ctrl$ref2 = ctrl.ref) == null ? void 0 : _ctrl$ref2.delete(ctrl);
      ref.add(ctrl);
      ctrl.ref = ref;
    }
  }
  const config$1 = {
    default: {
      tension: 170,
      friction: 26
    },
    gentle: {
      tension: 120,
      friction: 14
    },
    wobbly: {
      tension: 180,
      friction: 12
    },
    stiff: {
      tension: 210,
      friction: 20
    },
    slow: {
      tension: 280,
      friction: 60
    },
    molasses: {
      tension: 280,
      friction: 120
    }
  };
  const defaults = _extends$1({}, config$1.default, {
    mass: 1,
    damping: 1,
    easing: easings.linear,
    clamp: false
  });
  class AnimationConfig {
    constructor() {
      this.tension = void 0;
      this.friction = void 0;
      this.frequency = void 0;
      this.damping = void 0;
      this.mass = void 0;
      this.velocity = 0;
      this.restVelocity = void 0;
      this.precision = void 0;
      this.progress = void 0;
      this.duration = void 0;
      this.easing = void 0;
      this.clamp = void 0;
      this.bounce = void 0;
      this.decay = void 0;
      this.round = void 0;
      Object.assign(this, defaults);
    }
  }
  function mergeConfig(config2, newConfig, defaultConfig) {
    if (defaultConfig) {
      defaultConfig = _extends$1({}, defaultConfig);
      sanitizeConfig(defaultConfig, newConfig);
      newConfig = _extends$1({}, defaultConfig, newConfig);
    }
    sanitizeConfig(config2, newConfig);
    Object.assign(config2, newConfig);
    for (const key in defaults) {
      if (config2[key] == null) {
        config2[key] = defaults[key];
      }
    }
    let {
      mass,
      frequency,
      damping
    } = config2;
    if (!is.und(frequency)) {
      if (frequency < 0.01) frequency = 0.01;
      if (damping < 0) damping = 0;
      config2.tension = Math.pow(2 * Math.PI / frequency, 2) * mass;
      config2.friction = 4 * Math.PI * damping * mass / frequency;
    }
    return config2;
  }
  function sanitizeConfig(config2, props) {
    if (!is.und(props.decay)) {
      config2.duration = void 0;
    } else {
      const isTensionConfig = !is.und(props.tension) || !is.und(props.friction);
      if (isTensionConfig || !is.und(props.frequency) || !is.und(props.damping) || !is.und(props.mass)) {
        config2.duration = void 0;
        config2.decay = void 0;
      }
      if (isTensionConfig) {
        config2.frequency = void 0;
      }
    }
  }
  const emptyArray = [];
  class Animation {
    constructor() {
      this.changed = false;
      this.values = emptyArray;
      this.toValues = null;
      this.fromValues = emptyArray;
      this.to = void 0;
      this.from = void 0;
      this.config = new AnimationConfig();
      this.immediate = false;
    }
  }
  function scheduleProps(callId, {
    key,
    props,
    defaultProps: defaultProps2,
    state,
    actions
  }) {
    return new Promise((resolve, reject) => {
      var _props$cancel;
      let delay;
      let timeout;
      let cancel = matchProp((_props$cancel = props.cancel) != null ? _props$cancel : defaultProps2 == null ? void 0 : defaultProps2.cancel, key);
      if (cancel) {
        onStart();
      } else {
        if (!is.und(props.pause)) {
          state.paused = matchProp(props.pause, key);
        }
        let pause = defaultProps2 == null ? void 0 : defaultProps2.pause;
        if (pause !== true) {
          pause = state.paused || matchProp(pause, key);
        }
        delay = callProp(props.delay || 0, key);
        if (pause) {
          state.resumeQueue.add(onResume);
          actions.pause();
        } else {
          actions.resume();
          onResume();
        }
      }
      function onPause() {
        state.resumeQueue.add(onResume);
        state.timeouts.delete(timeout);
        timeout.cancel();
        delay = timeout.time - raf.now();
      }
      function onResume() {
        if (delay > 0 && !globals.skipAnimation) {
          state.delayed = true;
          timeout = raf.setTimeout(onStart, delay);
          state.pauseQueue.add(onPause);
          state.timeouts.add(timeout);
        } else {
          onStart();
        }
      }
      function onStart() {
        if (state.delayed) {
          state.delayed = false;
        }
        state.pauseQueue.delete(onPause);
        state.timeouts.delete(timeout);
        if (callId <= (state.cancelId || 0)) {
          cancel = true;
        }
        try {
          actions.start(_extends$1({}, props, {
            callId,
            cancel
          }), resolve);
        } catch (err) {
          reject(err);
        }
      }
    });
  }
  const getCombinedResult = (target, results) => results.length == 1 ? results[0] : results.some((result) => result.cancelled) ? getCancelledResult(target.get()) : results.every((result) => result.noop) ? getNoopResult(target.get()) : getFinishedResult(target.get(), results.every((result) => result.finished));
  const getNoopResult = (value) => ({
    value,
    noop: true,
    finished: true,
    cancelled: false
  });
  const getFinishedResult = (value, finished, cancelled = false) => ({
    value,
    finished,
    cancelled
  });
  const getCancelledResult = (value) => ({
    value,
    cancelled: true,
    finished: false
  });
  function runAsync(to2, props, state, target) {
    const {
      callId,
      parentId,
      onRest
    } = props;
    const {
      asyncTo: prevTo,
      promise: prevPromise
    } = state;
    if (!parentId && to2 === prevTo && !props.reset) {
      return prevPromise;
    }
    return state.promise = (async () => {
      state.asyncId = callId;
      state.asyncTo = to2;
      const defaultProps2 = getDefaultProps(props, (value, key) => key === "onRest" ? void 0 : value);
      let preventBail;
      let bail;
      const bailPromise = new Promise((resolve, reject) => (preventBail = resolve, bail = reject));
      const bailIfEnded = (bailSignal) => {
        const bailResult = callId <= (state.cancelId || 0) && getCancelledResult(target) || callId !== state.asyncId && getFinishedResult(target, false);
        if (bailResult) {
          bailSignal.result = bailResult;
          bail(bailSignal);
          throw bailSignal;
        }
      };
      const animate = (arg1, arg2) => {
        const bailSignal = new BailSignal();
        const skipAnimationSignal = new SkipAnimationSignal();
        return (async () => {
          if (globals.skipAnimation) {
            stopAsync(state);
            skipAnimationSignal.result = getFinishedResult(target, false);
            bail(skipAnimationSignal);
            throw skipAnimationSignal;
          }
          bailIfEnded(bailSignal);
          const props2 = is.obj(arg1) ? _extends$1({}, arg1) : _extends$1({}, arg2, {
            to: arg1
          });
          props2.parentId = callId;
          eachProp(defaultProps2, (value, key) => {
            if (is.und(props2[key])) {
              props2[key] = value;
            }
          });
          const result2 = await target.start(props2);
          bailIfEnded(bailSignal);
          if (state.paused) {
            await new Promise((resume) => {
              state.resumeQueue.add(resume);
            });
          }
          return result2;
        })();
      };
      let result;
      if (globals.skipAnimation) {
        stopAsync(state);
        return getFinishedResult(target, false);
      }
      try {
        let animating;
        if (is.arr(to2)) {
          animating = (async (queue) => {
            for (const props2 of queue) {
              await animate(props2);
            }
          })(to2);
        } else {
          animating = Promise.resolve(to2(animate, target.stop.bind(target)));
        }
        await Promise.all([animating.then(preventBail), bailPromise]);
        result = getFinishedResult(target.get(), true, false);
      } catch (err) {
        if (err instanceof BailSignal) {
          result = err.result;
        } else if (err instanceof SkipAnimationSignal) {
          result = err.result;
        } else {
          throw err;
        }
      } finally {
        if (callId == state.asyncId) {
          state.asyncId = parentId;
          state.asyncTo = parentId ? prevTo : void 0;
          state.promise = parentId ? prevPromise : void 0;
        }
      }
      if (is.fun(onRest)) {
        raf.batchedUpdates(() => {
          onRest(result, target, target.item);
        });
      }
      return result;
    })();
  }
  function stopAsync(state, cancelId) {
    flush(state.timeouts, (t) => t.cancel());
    state.pauseQueue.clear();
    state.resumeQueue.clear();
    state.asyncId = state.asyncTo = state.promise = void 0;
    if (cancelId) state.cancelId = cancelId;
  }
  class BailSignal extends Error {
    constructor() {
      super("An async animation has been interrupted. You see this error because you forgot to use `await` or `.catch(...)` on its returned promise.");
      this.result = void 0;
    }
  }
  class SkipAnimationSignal extends Error {
    constructor() {
      super("SkipAnimationSignal");
      this.result = void 0;
    }
  }
  const isFrameValue = (value) => value instanceof FrameValue;
  let nextId$1 = 1;
  class FrameValue extends FluidValue {
    constructor(...args) {
      super(...args);
      this.id = nextId$1++;
      this.key = void 0;
      this._priority = 0;
    }
    get priority() {
      return this._priority;
    }
    set priority(priority2) {
      if (this._priority != priority2) {
        this._priority = priority2;
        this._onPriorityChange(priority2);
      }
    }
    get() {
      const node = getAnimated(this);
      return node && node.getValue();
    }
    to(...args) {
      return globals.to(this, args);
    }
    interpolate(...args) {
      deprecateInterpolate();
      return globals.to(this, args);
    }
    toJSON() {
      return this.get();
    }
    observerAdded(count) {
      if (count == 1) this._attach();
    }
    observerRemoved(count) {
      if (count == 0) this._detach();
    }
    _attach() {
    }
    _detach() {
    }
    _onChange(value, idle = false) {
      callFluidObservers(this, {
        type: "change",
        parent: this,
        value,
        idle
      });
    }
    _onPriorityChange(priority2) {
      if (!this.idle) {
        frameLoop.sort(this);
      }
      callFluidObservers(this, {
        type: "priority",
        parent: this,
        priority: priority2
      });
    }
  }
  const $P = Symbol.for("SpringPhase");
  const HAS_ANIMATED = 1;
  const IS_ANIMATING = 2;
  const IS_PAUSED = 4;
  const hasAnimated = (target) => (target[$P] & HAS_ANIMATED) > 0;
  const isAnimating = (target) => (target[$P] & IS_ANIMATING) > 0;
  const isPaused = (target) => (target[$P] & IS_PAUSED) > 0;
  const setActiveBit = (target, active) => active ? target[$P] |= IS_ANIMATING | HAS_ANIMATED : target[$P] &= ~IS_ANIMATING;
  const setPausedBit = (target, paused) => paused ? target[$P] |= IS_PAUSED : target[$P] &= ~IS_PAUSED;
  class SpringValue extends FrameValue {
    constructor(arg1, arg2) {
      super();
      this.key = void 0;
      this.animation = new Animation();
      this.queue = void 0;
      this.defaultProps = {};
      this._state = {
        paused: false,
        delayed: false,
        pauseQueue: /* @__PURE__ */ new Set(),
        resumeQueue: /* @__PURE__ */ new Set(),
        timeouts: /* @__PURE__ */ new Set()
      };
      this._pendingCalls = /* @__PURE__ */ new Set();
      this._lastCallId = 0;
      this._lastToId = 0;
      this._memoizedDuration = 0;
      if (!is.und(arg1) || !is.und(arg2)) {
        const props = is.obj(arg1) ? _extends$1({}, arg1) : _extends$1({}, arg2, {
          from: arg1
        });
        if (is.und(props.default)) {
          props.default = true;
        }
        this.start(props);
      }
    }
    get idle() {
      return !(isAnimating(this) || this._state.asyncTo) || isPaused(this);
    }
    get goal() {
      return getFluidValue(this.animation.to);
    }
    get velocity() {
      const node = getAnimated(this);
      return node instanceof AnimatedValue ? node.lastVelocity || 0 : node.getPayload().map((node2) => node2.lastVelocity || 0);
    }
    get hasAnimated() {
      return hasAnimated(this);
    }
    get isAnimating() {
      return isAnimating(this);
    }
    get isPaused() {
      return isPaused(this);
    }
    get isDelayed() {
      return this._state.delayed;
    }
    advance(dt) {
      let idle = true;
      let changed = false;
      const anim = this.animation;
      let {
        config: config2,
        toValues
      } = anim;
      const payload = getPayload(anim.to);
      if (!payload && hasFluidValue(anim.to)) {
        toValues = toArray$1(getFluidValue(anim.to));
      }
      anim.values.forEach((node2, i2) => {
        if (node2.done) return;
        const to2 = node2.constructor == AnimatedString ? 1 : payload ? payload[i2].lastPosition : toValues[i2];
        let finished = anim.immediate;
        let position = to2;
        if (!finished) {
          position = node2.lastPosition;
          if (config2.tension <= 0) {
            node2.done = true;
            return;
          }
          let elapsed = node2.elapsedTime += dt;
          const from = anim.fromValues[i2];
          const v0 = node2.v0 != null ? node2.v0 : node2.v0 = is.arr(config2.velocity) ? config2.velocity[i2] : config2.velocity;
          let velocity;
          const precision = config2.precision || (from == to2 ? 5e-3 : Math.min(1, Math.abs(to2 - from) * 1e-3));
          if (!is.und(config2.duration)) {
            let p2 = 1;
            if (config2.duration > 0) {
              if (this._memoizedDuration !== config2.duration) {
                this._memoizedDuration = config2.duration;
                if (node2.durationProgress > 0) {
                  node2.elapsedTime = config2.duration * node2.durationProgress;
                  elapsed = node2.elapsedTime += dt;
                }
              }
              p2 = (config2.progress || 0) + elapsed / this._memoizedDuration;
              p2 = p2 > 1 ? 1 : p2 < 0 ? 0 : p2;
              node2.durationProgress = p2;
            }
            position = from + config2.easing(p2) * (to2 - from);
            velocity = (position - node2.lastPosition) / dt;
            finished = p2 == 1;
          } else if (config2.decay) {
            const decay = config2.decay === true ? 0.998 : config2.decay;
            const e = Math.exp(-(1 - decay) * elapsed);
            position = from + v0 / (1 - decay) * (1 - e);
            finished = Math.abs(node2.lastPosition - position) <= precision;
            velocity = v0 * e;
          } else {
            velocity = node2.lastVelocity == null ? v0 : node2.lastVelocity;
            const restVelocity = config2.restVelocity || precision / 10;
            const bounceFactor = config2.clamp ? 0 : config2.bounce;
            const canBounce = !is.und(bounceFactor);
            const isGrowing = from == to2 ? node2.v0 > 0 : from < to2;
            let isMoving;
            let isBouncing = false;
            const step = 1;
            const numSteps = Math.ceil(dt / step);
            for (let n2 = 0; n2 < numSteps; ++n2) {
              isMoving = Math.abs(velocity) > restVelocity;
              if (!isMoving) {
                finished = Math.abs(to2 - position) <= precision;
                if (finished) {
                  break;
                }
              }
              if (canBounce) {
                isBouncing = position == to2 || position > to2 == isGrowing;
                if (isBouncing) {
                  velocity = -velocity * bounceFactor;
                  position = to2;
                }
              }
              const springForce = -config2.tension * 1e-6 * (position - to2);
              const dampingForce = -config2.friction * 1e-3 * velocity;
              const acceleration = (springForce + dampingForce) / config2.mass;
              velocity = velocity + acceleration * step;
              position = position + velocity * step;
            }
          }
          node2.lastVelocity = velocity;
          if (Number.isNaN(position)) {
            console.warn(`Got NaN while animating:`, this);
            finished = true;
          }
        }
        if (payload && !payload[i2].done) {
          finished = false;
        }
        if (finished) {
          node2.done = true;
        } else {
          idle = false;
        }
        if (node2.setValue(position, config2.round)) {
          changed = true;
        }
      });
      const node = getAnimated(this);
      const currVal = node.getValue();
      if (idle) {
        const finalVal = getFluidValue(anim.to);
        if ((currVal !== finalVal || changed) && !config2.decay) {
          node.setValue(finalVal);
          this._onChange(finalVal);
        } else if (changed && config2.decay) {
          this._onChange(currVal);
        }
        this._stop();
      } else if (changed) {
        this._onChange(currVal);
      }
    }
    set(value) {
      raf.batchedUpdates(() => {
        this._stop();
        this._focus(value);
        this._set(value);
      });
      return this;
    }
    pause() {
      this._update({
        pause: true
      });
    }
    resume() {
      this._update({
        pause: false
      });
    }
    finish() {
      if (isAnimating(this)) {
        const {
          to: to2,
          config: config2
        } = this.animation;
        raf.batchedUpdates(() => {
          this._onStart();
          if (!config2.decay) {
            this._set(to2, false);
          }
          this._stop();
        });
      }
      return this;
    }
    update(props) {
      const queue = this.queue || (this.queue = []);
      queue.push(props);
      return this;
    }
    start(to2, arg2) {
      let queue;
      if (!is.und(to2)) {
        queue = [is.obj(to2) ? to2 : _extends$1({}, arg2, {
          to: to2
        })];
      } else {
        queue = this.queue || [];
        this.queue = [];
      }
      return Promise.all(queue.map((props) => {
        const up = this._update(props);
        return up;
      })).then((results) => getCombinedResult(this, results));
    }
    stop(cancel) {
      const {
        to: to2
      } = this.animation;
      this._focus(this.get());
      stopAsync(this._state, cancel && this._lastCallId);
      raf.batchedUpdates(() => this._stop(to2, cancel));
      return this;
    }
    reset() {
      this._update({
        reset: true
      });
    }
    eventObserved(event) {
      if (event.type == "change") {
        this._start();
      } else if (event.type == "priority") {
        this.priority = event.priority + 1;
      }
    }
    _prepareNode(props) {
      const key = this.key || "";
      let {
        to: to2,
        from
      } = props;
      to2 = is.obj(to2) ? to2[key] : to2;
      if (to2 == null || isAsyncTo(to2)) {
        to2 = void 0;
      }
      from = is.obj(from) ? from[key] : from;
      if (from == null) {
        from = void 0;
      }
      const range2 = {
        to: to2,
        from
      };
      if (!hasAnimated(this)) {
        if (props.reverse) [to2, from] = [from, to2];
        from = getFluidValue(from);
        if (!is.und(from)) {
          this._set(from);
        } else if (!getAnimated(this)) {
          this._set(to2);
        }
      }
      return range2;
    }
    _update(_ref, isLoop) {
      let props = _extends$1({}, _ref);
      const {
        key,
        defaultProps: defaultProps2
      } = this;
      if (props.default) Object.assign(defaultProps2, getDefaultProps(props, (value, prop) => /^on/.test(prop) ? resolveProp(value, key) : value));
      mergeActiveFn(this, props, "onProps");
      sendEvent(this, "onProps", props, this);
      const range2 = this._prepareNode(props);
      if (Object.isFrozen(this)) {
        throw Error("Cannot animate a `SpringValue` object that is frozen. Did you forget to pass your component to `animated(...)` before animating its props?");
      }
      const state = this._state;
      return scheduleProps(++this._lastCallId, {
        key,
        props,
        defaultProps: defaultProps2,
        state,
        actions: {
          pause: () => {
            if (!isPaused(this)) {
              setPausedBit(this, true);
              flushCalls(state.pauseQueue);
              sendEvent(this, "onPause", getFinishedResult(this, checkFinished(this, this.animation.to)), this);
            }
          },
          resume: () => {
            if (isPaused(this)) {
              setPausedBit(this, false);
              if (isAnimating(this)) {
                this._resume();
              }
              flushCalls(state.resumeQueue);
              sendEvent(this, "onResume", getFinishedResult(this, checkFinished(this, this.animation.to)), this);
            }
          },
          start: this._merge.bind(this, range2)
        }
      }).then((result) => {
        if (props.loop && result.finished && !(isLoop && result.noop)) {
          const nextProps = createLoopUpdate(props);
          if (nextProps) {
            return this._update(nextProps, true);
          }
        }
        return result;
      });
    }
    _merge(range2, props, resolve) {
      if (props.cancel) {
        this.stop(true);
        return resolve(getCancelledResult(this));
      }
      const hasToProp = !is.und(range2.to);
      const hasFromProp = !is.und(range2.from);
      if (hasToProp || hasFromProp) {
        if (props.callId > this._lastToId) {
          this._lastToId = props.callId;
        } else {
          return resolve(getCancelledResult(this));
        }
      }
      const {
        key,
        defaultProps: defaultProps2,
        animation: anim
      } = this;
      const {
        to: prevTo,
        from: prevFrom
      } = anim;
      let {
        to: to2 = prevTo,
        from = prevFrom
      } = range2;
      if (hasFromProp && !hasToProp && (!props.default || is.und(to2))) {
        to2 = from;
      }
      if (props.reverse) [to2, from] = [from, to2];
      const hasFromChanged = !isEqual$1(from, prevFrom);
      if (hasFromChanged) {
        anim.from = from;
      }
      from = getFluidValue(from);
      const hasToChanged = !isEqual$1(to2, prevTo);
      if (hasToChanged) {
        this._focus(to2);
      }
      const hasAsyncTo = isAsyncTo(props.to);
      const {
        config: config2
      } = anim;
      const {
        decay,
        velocity
      } = config2;
      if (hasToProp || hasFromProp) {
        config2.velocity = 0;
      }
      if (props.config && !hasAsyncTo) {
        mergeConfig(config2, callProp(props.config, key), props.config !== defaultProps2.config ? callProp(defaultProps2.config, key) : void 0);
      }
      let node = getAnimated(this);
      if (!node || is.und(to2)) {
        return resolve(getFinishedResult(this, true));
      }
      const reset = is.und(props.reset) ? hasFromProp && !props.default : !is.und(from) && matchProp(props.reset, key);
      const value = reset ? from : this.get();
      const goal = computeGoal(to2);
      const isAnimatable = is.num(goal) || is.arr(goal) || isAnimatedString(goal);
      const immediate = !hasAsyncTo && (!isAnimatable || matchProp(defaultProps2.immediate || props.immediate, key));
      if (hasToChanged) {
        const nodeType = getAnimatedType(to2);
        if (nodeType !== node.constructor) {
          if (immediate) {
            node = this._set(goal);
          } else throw Error(`Cannot animate between ${node.constructor.name} and ${nodeType.name}, as the "to" prop suggests`);
        }
      }
      const goalType = node.constructor;
      let started = hasFluidValue(to2);
      let finished = false;
      if (!started) {
        const hasValueChanged = reset || !hasAnimated(this) && hasFromChanged;
        if (hasToChanged || hasValueChanged) {
          finished = isEqual$1(computeGoal(value), goal);
          started = !finished;
        }
        if (!isEqual$1(anim.immediate, immediate) && !immediate || !isEqual$1(config2.decay, decay) || !isEqual$1(config2.velocity, velocity)) {
          started = true;
        }
      }
      if (finished && isAnimating(this)) {
        if (anim.changed && !reset) {
          started = true;
        } else if (!started) {
          this._stop(prevTo);
        }
      }
      if (!hasAsyncTo) {
        if (started || hasFluidValue(prevTo)) {
          anim.values = node.getPayload();
          anim.toValues = hasFluidValue(to2) ? null : goalType == AnimatedString ? [1] : toArray$1(goal);
        }
        if (anim.immediate != immediate) {
          anim.immediate = immediate;
          if (!immediate && !reset) {
            this._set(prevTo);
          }
        }
        if (started) {
          const {
            onRest
          } = anim;
          each(ACTIVE_EVENTS, (type) => mergeActiveFn(this, props, type));
          const result = getFinishedResult(this, checkFinished(this, prevTo));
          flushCalls(this._pendingCalls, result);
          this._pendingCalls.add(resolve);
          if (anim.changed) raf.batchedUpdates(() => {
            anim.changed = !reset;
            onRest == null ? void 0 : onRest(result, this);
            if (reset) {
              callProp(defaultProps2.onRest, result);
            } else {
              anim.onStart == null ? void 0 : anim.onStart(result, this);
            }
          });
        }
      }
      if (reset) {
        this._set(value);
      }
      if (hasAsyncTo) {
        resolve(runAsync(props.to, props, this._state, this));
      } else if (started) {
        this._start();
      } else if (isAnimating(this) && !hasToChanged) {
        this._pendingCalls.add(resolve);
      } else {
        resolve(getNoopResult(value));
      }
    }
    _focus(value) {
      const anim = this.animation;
      if (value !== anim.to) {
        if (getFluidObservers(this)) {
          this._detach();
        }
        anim.to = value;
        if (getFluidObservers(this)) {
          this._attach();
        }
      }
    }
    _attach() {
      let priority2 = 0;
      const {
        to: to2
      } = this.animation;
      if (hasFluidValue(to2)) {
        addFluidObserver(to2, this);
        if (isFrameValue(to2)) {
          priority2 = to2.priority + 1;
        }
      }
      this.priority = priority2;
    }
    _detach() {
      const {
        to: to2
      } = this.animation;
      if (hasFluidValue(to2)) {
        removeFluidObserver(to2, this);
      }
    }
    _set(arg, idle = true) {
      const value = getFluidValue(arg);
      if (!is.und(value)) {
        const oldNode = getAnimated(this);
        if (!oldNode || !isEqual$1(value, oldNode.getValue())) {
          const nodeType = getAnimatedType(value);
          if (!oldNode || oldNode.constructor != nodeType) {
            setAnimated(this, nodeType.create(value));
          } else {
            oldNode.setValue(value);
          }
          if (oldNode) {
            raf.batchedUpdates(() => {
              this._onChange(value, idle);
            });
          }
        }
      }
      return getAnimated(this);
    }
    _onStart() {
      const anim = this.animation;
      if (!anim.changed) {
        anim.changed = true;
        sendEvent(this, "onStart", getFinishedResult(this, checkFinished(this, anim.to)), this);
      }
    }
    _onChange(value, idle) {
      if (!idle) {
        this._onStart();
        callProp(this.animation.onChange, value, this);
      }
      callProp(this.defaultProps.onChange, value, this);
      super._onChange(value, idle);
    }
    _start() {
      const anim = this.animation;
      getAnimated(this).reset(getFluidValue(anim.to));
      if (!anim.immediate) {
        anim.fromValues = anim.values.map((node) => node.lastPosition);
      }
      if (!isAnimating(this)) {
        setActiveBit(this, true);
        if (!isPaused(this)) {
          this._resume();
        }
      }
    }
    _resume() {
      if (globals.skipAnimation) {
        this.finish();
      } else {
        frameLoop.start(this);
      }
    }
    _stop(goal, cancel) {
      if (isAnimating(this)) {
        setActiveBit(this, false);
        const anim = this.animation;
        each(anim.values, (node) => {
          node.done = true;
        });
        if (anim.toValues) {
          anim.onChange = anim.onPause = anim.onResume = void 0;
        }
        callFluidObservers(this, {
          type: "idle",
          parent: this
        });
        const result = cancel ? getCancelledResult(this.get()) : getFinishedResult(this.get(), checkFinished(this, goal != null ? goal : anim.to));
        flushCalls(this._pendingCalls, result);
        if (anim.changed) {
          anim.changed = false;
          sendEvent(this, "onRest", result, this);
        }
      }
    }
  }
  function checkFinished(target, to2) {
    const goal = computeGoal(to2);
    const value = computeGoal(target.get());
    return isEqual$1(value, goal);
  }
  function createLoopUpdate(props, loop2 = props.loop, to2 = props.to) {
    let loopRet = callProp(loop2);
    if (loopRet) {
      const overrides = loopRet !== true && inferTo(loopRet);
      const reverse = (overrides || props).reverse;
      const reset = !overrides || overrides.reset;
      return createUpdate(_extends$1({}, props, {
        loop: loop2,
        default: false,
        pause: void 0,
        to: !reverse || isAsyncTo(to2) ? to2 : void 0,
        from: reset ? props.from : void 0,
        reset
      }, overrides));
    }
  }
  function createUpdate(props) {
    const {
      to: to2,
      from
    } = props = inferTo(props);
    const keys = /* @__PURE__ */ new Set();
    if (is.obj(to2)) findDefined(to2, keys);
    if (is.obj(from)) findDefined(from, keys);
    props.keys = keys.size ? Array.from(keys) : null;
    return props;
  }
  function declareUpdate(props) {
    const update2 = createUpdate(props);
    if (is.und(update2.default)) {
      update2.default = getDefaultProps(update2);
    }
    return update2;
  }
  function findDefined(values, keys) {
    eachProp(values, (value, key) => value != null && keys.add(key));
  }
  const ACTIVE_EVENTS = ["onStart", "onRest", "onChange", "onPause", "onResume"];
  function mergeActiveFn(target, props, type) {
    target.animation[type] = props[type] !== getDefaultProp(props, type) ? resolveProp(props[type], target.key) : void 0;
  }
  function sendEvent(target, type, ...args) {
    var _target$animation$typ, _target$animation, _target$defaultProps$, _target$defaultProps;
    (_target$animation$typ = (_target$animation = target.animation)[type]) == null ? void 0 : _target$animation$typ.call(_target$animation, ...args);
    (_target$defaultProps$ = (_target$defaultProps = target.defaultProps)[type]) == null ? void 0 : _target$defaultProps$.call(_target$defaultProps, ...args);
  }
  const BATCHED_EVENTS = ["onStart", "onChange", "onRest"];
  let nextId = 1;
  class Controller {
    constructor(props, flush2) {
      this.id = nextId++;
      this.springs = {};
      this.queue = [];
      this.ref = void 0;
      this._flush = void 0;
      this._initialProps = void 0;
      this._lastAsyncId = 0;
      this._active = /* @__PURE__ */ new Set();
      this._changed = /* @__PURE__ */ new Set();
      this._started = false;
      this._item = void 0;
      this._state = {
        paused: false,
        pauseQueue: /* @__PURE__ */ new Set(),
        resumeQueue: /* @__PURE__ */ new Set(),
        timeouts: /* @__PURE__ */ new Set()
      };
      this._events = {
        onStart: /* @__PURE__ */ new Map(),
        onChange: /* @__PURE__ */ new Map(),
        onRest: /* @__PURE__ */ new Map()
      };
      this._onFrame = this._onFrame.bind(this);
      if (flush2) {
        this._flush = flush2;
      }
      if (props) {
        this.start(_extends$1({
          default: true
        }, props));
      }
    }
    get idle() {
      return !this._state.asyncTo && Object.values(this.springs).every((spring) => {
        return spring.idle && !spring.isDelayed && !spring.isPaused;
      });
    }
    get item() {
      return this._item;
    }
    set item(item) {
      this._item = item;
    }
    get() {
      const values = {};
      this.each((spring, key) => values[key] = spring.get());
      return values;
    }
    set(values) {
      for (const key in values) {
        const value = values[key];
        if (!is.und(value)) {
          this.springs[key].set(value);
        }
      }
    }
    update(props) {
      if (props) {
        this.queue.push(createUpdate(props));
      }
      return this;
    }
    start(props) {
      let {
        queue
      } = this;
      if (props) {
        queue = toArray$1(props).map(createUpdate);
      } else {
        this.queue = [];
      }
      if (this._flush) {
        return this._flush(this, queue);
      }
      prepareKeys(this, queue);
      return flushUpdateQueue(this, queue);
    }
    stop(arg, keys) {
      if (arg !== !!arg) {
        keys = arg;
      }
      if (keys) {
        const springs = this.springs;
        each(toArray$1(keys), (key) => springs[key].stop(!!arg));
      } else {
        stopAsync(this._state, this._lastAsyncId);
        this.each((spring) => spring.stop(!!arg));
      }
      return this;
    }
    pause(keys) {
      if (is.und(keys)) {
        this.start({
          pause: true
        });
      } else {
        const springs = this.springs;
        each(toArray$1(keys), (key) => springs[key].pause());
      }
      return this;
    }
    resume(keys) {
      if (is.und(keys)) {
        this.start({
          pause: false
        });
      } else {
        const springs = this.springs;
        each(toArray$1(keys), (key) => springs[key].resume());
      }
      return this;
    }
    each(iterator) {
      eachProp(this.springs, iterator);
    }
    _onFrame() {
      const {
        onStart,
        onChange,
        onRest
      } = this._events;
      const active = this._active.size > 0;
      const changed = this._changed.size > 0;
      if (active && !this._started || changed && !this._started) {
        this._started = true;
        flush(onStart, ([onStart2, result]) => {
          result.value = this.get();
          onStart2(result, this, this._item);
        });
      }
      const idle = !active && this._started;
      const values = changed || idle && onRest.size ? this.get() : null;
      if (changed && onChange.size) {
        flush(onChange, ([onChange2, result]) => {
          result.value = values;
          onChange2(result, this, this._item);
        });
      }
      if (idle) {
        this._started = false;
        flush(onRest, ([onRest2, result]) => {
          result.value = values;
          onRest2(result, this, this._item);
        });
      }
    }
    eventObserved(event) {
      if (event.type == "change") {
        this._changed.add(event.parent);
        if (!event.idle) {
          this._active.add(event.parent);
        }
      } else if (event.type == "idle") {
        this._active.delete(event.parent);
      } else return;
      raf.onFrame(this._onFrame);
    }
  }
  function flushUpdateQueue(ctrl, queue) {
    return Promise.all(queue.map((props) => flushUpdate(ctrl, props))).then((results) => getCombinedResult(ctrl, results));
  }
  async function flushUpdate(ctrl, props, isLoop) {
    const {
      keys,
      to: to2,
      from,
      loop: loop2,
      onRest,
      onResolve
    } = props;
    const defaults2 = is.obj(props.default) && props.default;
    if (loop2) {
      props.loop = false;
    }
    if (to2 === false) props.to = null;
    if (from === false) props.from = null;
    const asyncTo = is.arr(to2) || is.fun(to2) ? to2 : void 0;
    if (asyncTo) {
      props.to = void 0;
      props.onRest = void 0;
      if (defaults2) {
        defaults2.onRest = void 0;
      }
    } else {
      each(BATCHED_EVENTS, (key) => {
        const handler = props[key];
        if (is.fun(handler)) {
          const queue = ctrl["_events"][key];
          props[key] = ({
            finished,
            cancelled
          }) => {
            const result2 = queue.get(handler);
            if (result2) {
              if (!finished) result2.finished = false;
              if (cancelled) result2.cancelled = true;
            } else {
              queue.set(handler, {
                value: null,
                finished: finished || false,
                cancelled: cancelled || false
              });
            }
          };
          if (defaults2) {
            defaults2[key] = props[key];
          }
        }
      });
    }
    const state = ctrl["_state"];
    if (props.pause === !state.paused) {
      state.paused = props.pause;
      flushCalls(props.pause ? state.pauseQueue : state.resumeQueue);
    } else if (state.paused) {
      props.pause = true;
    }
    const promises = (keys || Object.keys(ctrl.springs)).map((key) => ctrl.springs[key].start(props));
    const cancel = props.cancel === true || getDefaultProp(props, "cancel") === true;
    if (asyncTo || cancel && state.asyncId) {
      promises.push(scheduleProps(++ctrl["_lastAsyncId"], {
        props,
        state,
        actions: {
          pause: noop,
          resume: noop,
          start(props2, resolve) {
            if (cancel) {
              stopAsync(state, ctrl["_lastAsyncId"]);
              resolve(getCancelledResult(ctrl));
            } else {
              props2.onRest = onRest;
              resolve(runAsync(asyncTo, props2, state, ctrl));
            }
          }
        }
      }));
    }
    if (state.paused) {
      await new Promise((resume) => {
        state.resumeQueue.add(resume);
      });
    }
    const result = getCombinedResult(ctrl, await Promise.all(promises));
    if (loop2 && result.finished && !(isLoop && result.noop)) {
      const nextProps = createLoopUpdate(props, loop2, to2);
      if (nextProps) {
        prepareKeys(ctrl, [nextProps]);
        return flushUpdate(ctrl, nextProps, true);
      }
    }
    if (onResolve) {
      raf.batchedUpdates(() => onResolve(result, ctrl, ctrl.item));
    }
    return result;
  }
  function getSprings(ctrl, props) {
    const springs = _extends$1({}, ctrl.springs);
    if (props) {
      each(toArray$1(props), (props2) => {
        if (is.und(props2.keys)) {
          props2 = createUpdate(props2);
        }
        if (!is.obj(props2.to)) {
          props2 = _extends$1({}, props2, {
            to: void 0
          });
        }
        prepareSprings(springs, props2, (key) => {
          return createSpring(key);
        });
      });
    }
    setSprings(ctrl, springs);
    return springs;
  }
  function setSprings(ctrl, springs) {
    eachProp(springs, (spring, key) => {
      if (!ctrl.springs[key]) {
        ctrl.springs[key] = spring;
        addFluidObserver(spring, ctrl);
      }
    });
  }
  function createSpring(key, observer) {
    const spring = new SpringValue();
    spring.key = key;
    if (observer) {
      addFluidObserver(spring, observer);
    }
    return spring;
  }
  function prepareSprings(springs, props, create) {
    if (props.keys) {
      each(props.keys, (key) => {
        const spring = springs[key] || (springs[key] = create(key));
        spring["_prepareNode"](props);
      });
    }
  }
  function prepareKeys(ctrl, queue) {
    each(queue, (props) => {
      prepareSprings(ctrl.springs, props, (key) => {
        return createSpring(key, ctrl);
      });
    });
  }
  function _objectWithoutPropertiesLoose$1(source, excluded) {
    if (source == null) return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i2;
    for (i2 = 0; i2 < sourceKeys.length; i2++) {
      key = sourceKeys[i2];
      if (excluded.indexOf(key) >= 0) continue;
      target[key] = source[key];
    }
    return target;
  }
  const _excluded$6 = ["children"];
  const SpringContext = (_ref) => {
    let {
      children
    } = _ref, props = _objectWithoutPropertiesLoose$1(_ref, _excluded$6);
    const inherited = React.useContext(ctx);
    const pause = props.pause || !!inherited.pause, immediate = props.immediate || !!inherited.immediate;
    props = useMemoOne(() => ({
      pause,
      immediate
    }), [pause, immediate]);
    const {
      Provider
    } = ctx;
    return React__namespace.createElement(Provider, {
      value: props
    }, children);
  };
  const ctx = makeContext(SpringContext, {});
  SpringContext.Provider = ctx.Provider;
  SpringContext.Consumer = ctx.Consumer;
  function makeContext(target, init) {
    Object.assign(target, React__namespace.createContext(init));
    target.Provider._context = target;
    target.Consumer._context = target;
    return target;
  }
  const SpringRef = () => {
    const current = [];
    const SpringRef2 = function SpringRef3(props) {
      deprecateDirectCall();
      const results = [];
      each(current, (ctrl, i2) => {
        if (is.und(props)) {
          results.push(ctrl.start());
        } else {
          const update2 = _getProps(props, ctrl, i2);
          if (update2) {
            results.push(ctrl.start(update2));
          }
        }
      });
      return results;
    };
    SpringRef2.current = current;
    SpringRef2.add = function(ctrl) {
      if (!current.includes(ctrl)) {
        current.push(ctrl);
      }
    };
    SpringRef2.delete = function(ctrl) {
      const i2 = current.indexOf(ctrl);
      if (~i2) current.splice(i2, 1);
    };
    SpringRef2.pause = function() {
      each(current, (ctrl) => ctrl.pause(...arguments));
      return this;
    };
    SpringRef2.resume = function() {
      each(current, (ctrl) => ctrl.resume(...arguments));
      return this;
    };
    SpringRef2.set = function(values) {
      each(current, (ctrl) => ctrl.set(values));
    };
    SpringRef2.start = function(props) {
      const results = [];
      each(current, (ctrl, i2) => {
        if (is.und(props)) {
          results.push(ctrl.start());
        } else {
          const update2 = this._getProps(props, ctrl, i2);
          if (update2) {
            results.push(ctrl.start(update2));
          }
        }
      });
      return results;
    };
    SpringRef2.stop = function() {
      each(current, (ctrl) => ctrl.stop(...arguments));
      return this;
    };
    SpringRef2.update = function(props) {
      each(current, (ctrl, i2) => ctrl.update(this._getProps(props, ctrl, i2)));
      return this;
    };
    const _getProps = function _getProps2(arg, ctrl, index) {
      return is.fun(arg) ? arg(index, ctrl) : arg;
    };
    SpringRef2._getProps = _getProps;
    return SpringRef2;
  };
  function useSprings(length, props, deps) {
    const propsFn = is.fun(props) && props;
    if (propsFn && !deps) deps = [];
    const ref = React.useMemo(() => propsFn || arguments.length == 3 ? SpringRef() : void 0, []);
    const layoutId = React.useRef(0);
    const forceUpdate = useForceUpdate$1();
    const state = React.useMemo(() => ({
      ctrls: [],
      queue: [],
      flush(ctrl, updates2) {
        const springs2 = getSprings(ctrl, updates2);
        const canFlushSync = layoutId.current > 0 && !state.queue.length && !Object.keys(springs2).some((key) => !ctrl.springs[key]);
        return canFlushSync ? flushUpdateQueue(ctrl, updates2) : new Promise((resolve) => {
          setSprings(ctrl, springs2);
          state.queue.push(() => {
            resolve(flushUpdateQueue(ctrl, updates2));
          });
          forceUpdate();
        });
      }
    }), []);
    const ctrls = React.useRef([...state.ctrls]);
    const updates = [];
    const prevLength = usePrev(length) || 0;
    React.useMemo(() => {
      each(ctrls.current.slice(length, prevLength), (ctrl) => {
        detachRefs(ctrl, ref);
        ctrl.stop(true);
      });
      ctrls.current.length = length;
      declareUpdates(prevLength, length);
    }, [length]);
    React.useMemo(() => {
      declareUpdates(0, Math.min(prevLength, length));
    }, deps);
    function declareUpdates(startIndex, endIndex) {
      for (let i2 = startIndex; i2 < endIndex; i2++) {
        const ctrl = ctrls.current[i2] || (ctrls.current[i2] = new Controller(null, state.flush));
        const update2 = propsFn ? propsFn(i2, ctrl) : props[i2];
        if (update2) {
          updates[i2] = declareUpdate(update2);
        }
      }
    }
    const springs = ctrls.current.map((ctrl, i2) => getSprings(ctrl, updates[i2]));
    const context = React.useContext(SpringContext);
    const prevContext = usePrev(context);
    const hasContext = context !== prevContext && hasProps(context);
    useIsomorphicLayoutEffect$1(() => {
      layoutId.current++;
      state.ctrls = ctrls.current;
      const {
        queue
      } = state;
      if (queue.length) {
        state.queue = [];
        each(queue, (cb) => cb());
      }
      each(ctrls.current, (ctrl, i2) => {
        ref == null ? void 0 : ref.add(ctrl);
        if (hasContext) {
          ctrl.start({
            default: context
          });
        }
        const update2 = updates[i2];
        if (update2) {
          replaceRef(ctrl, update2.ref);
          if (ctrl.ref) {
            ctrl.queue.push(update2);
          } else {
            ctrl.start(update2);
          }
        }
      });
    });
    useOnce(() => () => {
      each(state.ctrls, (ctrl) => ctrl.stop(true));
    });
    const values = springs.map((x) => _extends$1({}, x));
    return ref ? [values, ref] : values;
  }
  function useSpring(props, deps) {
    const isFn = is.fun(props);
    const [[values], ref] = useSprings(1, isFn ? props : [props], isFn ? [] : deps);
    return isFn || arguments.length == 2 ? [values, ref] : values;
  }
  let TransitionPhase;
  (function(TransitionPhase2) {
    TransitionPhase2["MOUNT"] = "mount";
    TransitionPhase2["ENTER"] = "enter";
    TransitionPhase2["UPDATE"] = "update";
    TransitionPhase2["LEAVE"] = "leave";
  })(TransitionPhase || (TransitionPhase = {}));
  class Interpolation extends FrameValue {
    constructor(source, args) {
      super();
      this.key = void 0;
      this.idle = true;
      this.calc = void 0;
      this._active = /* @__PURE__ */ new Set();
      this.source = source;
      this.calc = createInterpolator(...args);
      const value = this._get();
      const nodeType = getAnimatedType(value);
      setAnimated(this, nodeType.create(value));
    }
    advance(_dt) {
      const value = this._get();
      const oldValue = this.get();
      if (!isEqual$1(value, oldValue)) {
        getAnimated(this).setValue(value);
        this._onChange(value, this.idle);
      }
      if (!this.idle && checkIdle(this._active)) {
        becomeIdle(this);
      }
    }
    _get() {
      const inputs = is.arr(this.source) ? this.source.map(getFluidValue) : toArray$1(getFluidValue(this.source));
      return this.calc(...inputs);
    }
    _start() {
      if (this.idle && !checkIdle(this._active)) {
        this.idle = false;
        each(getPayload(this), (node) => {
          node.done = false;
        });
        if (globals.skipAnimation) {
          raf.batchedUpdates(() => this.advance());
          becomeIdle(this);
        } else {
          frameLoop.start(this);
        }
      }
    }
    _attach() {
      let priority2 = 1;
      each(toArray$1(this.source), (source) => {
        if (hasFluidValue(source)) {
          addFluidObserver(source, this);
        }
        if (isFrameValue(source)) {
          if (!source.idle) {
            this._active.add(source);
          }
          priority2 = Math.max(priority2, source.priority + 1);
        }
      });
      this.priority = priority2;
      this._start();
    }
    _detach() {
      each(toArray$1(this.source), (source) => {
        if (hasFluidValue(source)) {
          removeFluidObserver(source, this);
        }
      });
      this._active.clear();
      becomeIdle(this);
    }
    eventObserved(event) {
      if (event.type == "change") {
        if (event.idle) {
          this.advance();
        } else {
          this._active.add(event.parent);
          this._start();
        }
      } else if (event.type == "idle") {
        this._active.delete(event.parent);
      } else if (event.type == "priority") {
        this.priority = toArray$1(this.source).reduce((highest, parent) => Math.max(highest, (isFrameValue(parent) ? parent.priority : 0) + 1), 0);
      }
    }
  }
  function isIdle(source) {
    return source.idle !== false;
  }
  function checkIdle(active) {
    return !active.size || Array.from(active).every(isIdle);
  }
  function becomeIdle(self2) {
    if (!self2.idle) {
      self2.idle = true;
      each(getPayload(self2), (node) => {
        node.done = true;
      });
      callFluidObservers(self2, {
        type: "idle",
        parent: self2
      });
    }
  }
  globals.assign({
    createStringInterpolator,
    to: (source, args) => new Interpolation(source, args)
  });
  function _objectWithoutPropertiesLoose(source, excluded) {
    if (source == null) return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i2;
    for (i2 = 0; i2 < sourceKeys.length; i2++) {
      key = sourceKeys[i2];
      if (excluded.indexOf(key) >= 0) continue;
      target[key] = source[key];
    }
    return target;
  }
  const _excluded$2 = ["style", "children", "scrollTop", "scrollLeft", "viewBox"];
  const isCustomPropRE = /^--/;
  function dangerousStyleValue(name, value) {
    if (value == null || typeof value === "boolean" || value === "") return "";
    if (typeof value === "number" && value !== 0 && !isCustomPropRE.test(name) && !(isUnitlessNumber.hasOwnProperty(name) && isUnitlessNumber[name])) return value + "px";
    return ("" + value).trim();
  }
  const attributeCache = {};
  function applyAnimatedValues(instance, props) {
    if (!instance.nodeType || !instance.setAttribute) {
      return false;
    }
    const isFilterElement = instance.nodeName === "filter" || instance.parentNode && instance.parentNode.nodeName === "filter";
    const _ref = props, {
      style,
      children,
      scrollTop,
      scrollLeft,
      viewBox
    } = _ref, attributes = _objectWithoutPropertiesLoose(_ref, _excluded$2);
    const values = Object.values(attributes);
    const names = Object.keys(attributes).map((name) => isFilterElement || instance.hasAttribute(name) ? name : attributeCache[name] || (attributeCache[name] = name.replace(/([A-Z])/g, (n2) => "-" + n2.toLowerCase())));
    if (children !== void 0) {
      instance.textContent = children;
    }
    for (let name in style) {
      if (style.hasOwnProperty(name)) {
        const value = dangerousStyleValue(name, style[name]);
        if (isCustomPropRE.test(name)) {
          instance.style.setProperty(name, value);
        } else {
          instance.style[name] = value;
        }
      }
    }
    names.forEach((name, i2) => {
      instance.setAttribute(name, values[i2]);
    });
    if (scrollTop !== void 0) {
      instance.scrollTop = scrollTop;
    }
    if (scrollLeft !== void 0) {
      instance.scrollLeft = scrollLeft;
    }
    if (viewBox !== void 0) {
      instance.setAttribute("viewBox", viewBox);
    }
  }
  let isUnitlessNumber = {
    animationIterationCount: true,
    borderImageOutset: true,
    borderImageSlice: true,
    borderImageWidth: true,
    boxFlex: true,
    boxFlexGroup: true,
    boxOrdinalGroup: true,
    columnCount: true,
    columns: true,
    flex: true,
    flexGrow: true,
    flexPositive: true,
    flexShrink: true,
    flexNegative: true,
    flexOrder: true,
    gridRow: true,
    gridRowEnd: true,
    gridRowSpan: true,
    gridRowStart: true,
    gridColumn: true,
    gridColumnEnd: true,
    gridColumnSpan: true,
    gridColumnStart: true,
    fontWeight: true,
    lineClamp: true,
    lineHeight: true,
    opacity: true,
    order: true,
    orphans: true,
    tabSize: true,
    widows: true,
    zIndex: true,
    zoom: true,
    fillOpacity: true,
    floodOpacity: true,
    stopOpacity: true,
    strokeDasharray: true,
    strokeDashoffset: true,
    strokeMiterlimit: true,
    strokeOpacity: true,
    strokeWidth: true
  };
  const prefixKey = (prefix2, key) => prefix2 + key.charAt(0).toUpperCase() + key.substring(1);
  const prefixes = ["Webkit", "Ms", "Moz", "O"];
  isUnitlessNumber = Object.keys(isUnitlessNumber).reduce((acc, prop) => {
    prefixes.forEach((prefix2) => acc[prefixKey(prefix2, prop)] = acc[prop]);
    return acc;
  }, isUnitlessNumber);
  const _excluded$1 = ["x", "y", "z"];
  const domTransforms = /^(matrix|translate|scale|rotate|skew)/;
  const pxTransforms = /^(translate)/;
  const degTransforms = /^(rotate|skew)/;
  const addUnit = (value, unit) => is.num(value) && value !== 0 ? value + unit : value;
  const isValueIdentity = (value, id) => is.arr(value) ? value.every((v) => isValueIdentity(v, id)) : is.num(value) ? value === id : parseFloat(value) === id;
  class AnimatedStyle extends AnimatedObject {
    constructor(_ref) {
      let {
        x,
        y,
        z
      } = _ref, style = _objectWithoutPropertiesLoose(_ref, _excluded$1);
      const inputs = [];
      const transforms = [];
      if (x || y || z) {
        inputs.push([x || 0, y || 0, z || 0]);
        transforms.push((xyz) => [`translate3d(${xyz.map((v) => addUnit(v, "px")).join(",")})`, isValueIdentity(xyz, 0)]);
      }
      eachProp(style, (value, key) => {
        if (key === "transform") {
          inputs.push([value || ""]);
          transforms.push((transform) => [transform, transform === ""]);
        } else if (domTransforms.test(key)) {
          delete style[key];
          if (is.und(value)) return;
          const unit = pxTransforms.test(key) ? "px" : degTransforms.test(key) ? "deg" : "";
          inputs.push(toArray$1(value));
          transforms.push(key === "rotate3d" ? ([x2, y2, z2, deg]) => [`rotate3d(${x2},${y2},${z2},${addUnit(deg, unit)})`, isValueIdentity(deg, 0)] : (input) => [`${key}(${input.map((v) => addUnit(v, unit)).join(",")})`, isValueIdentity(input, key.startsWith("scale") ? 1 : 0)]);
        }
      });
      if (inputs.length) {
        style.transform = new FluidTransform(inputs, transforms);
      }
      super(style);
    }
  }
  class FluidTransform extends FluidValue {
    constructor(inputs, transforms) {
      super();
      this._value = null;
      this.inputs = inputs;
      this.transforms = transforms;
    }
    get() {
      return this._value || (this._value = this._get());
    }
    _get() {
      let transform = "";
      let identity2 = true;
      each(this.inputs, (input, i2) => {
        const arg1 = getFluidValue(input[0]);
        const [t, id] = this.transforms[i2](is.arr(arg1) ? arg1 : input.map(getFluidValue));
        transform += " " + t;
        identity2 = identity2 && id;
      });
      return identity2 ? "none" : transform;
    }
    observerAdded(count) {
      if (count == 1) each(this.inputs, (input) => each(input, (value) => hasFluidValue(value) && addFluidObserver(value, this)));
    }
    observerRemoved(count) {
      if (count == 0) each(this.inputs, (input) => each(input, (value) => hasFluidValue(value) && removeFluidObserver(value, this)));
    }
    eventObserved(event) {
      if (event.type == "change") {
        this._value = null;
      }
      callFluidObservers(this, event);
    }
  }
  const primitives = ["a", "abbr", "address", "area", "article", "aside", "audio", "b", "base", "bdi", "bdo", "big", "blockquote", "body", "br", "button", "canvas", "caption", "cite", "code", "col", "colgroup", "data", "datalist", "dd", "del", "details", "dfn", "dialog", "div", "dl", "dt", "em", "embed", "fieldset", "figcaption", "figure", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "iframe", "img", "input", "ins", "kbd", "keygen", "label", "legend", "li", "link", "main", "map", "mark", "menu", "menuitem", "meta", "meter", "nav", "noscript", "object", "ol", "optgroup", "option", "output", "p", "param", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "script", "section", "select", "small", "source", "span", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "textarea", "tfoot", "th", "thead", "time", "title", "tr", "track", "u", "ul", "var", "video", "wbr", "circle", "clipPath", "defs", "ellipse", "foreignObject", "g", "image", "line", "linearGradient", "mask", "path", "pattern", "polygon", "polyline", "radialGradient", "rect", "stop", "svg", "text", "tspan"];
  const _excluded = ["scrollTop", "scrollLeft"];
  globals.assign({
    batchedUpdates: ReactDOM.unstable_batchedUpdates,
    createStringInterpolator,
    colors
  });
  const host = createHost(primitives, {
    applyAnimatedValues,
    createAnimatedStyle: (style) => new AnimatedStyle(style),
    getComponentProps: (_ref) => {
      let props = _objectWithoutPropertiesLoose(_ref, _excluded);
      return props;
    }
  });
  const animated = host.animated;
  const elevatorContext = React.createContext({});
  const defaultProps$1i = {
    ...ComponentDefaults,
    height: "200px",
    floorKey: "title",
    list: [],
    sticky: false,
    spaceHeight: 23,
    titleHeight: 35,
    showKeys: true
  };
  const Elevator = (props) => {
    const {
      height,
      floorKey,
      list,
      sticky,
      spaceHeight,
      titleHeight,
      showKeys,
      className,
      style,
      onItemClick,
      onIndexClick,
      children,
      ...rest
    } = {
      ...defaultProps$1i,
      ...props
    };
    const classPrefix2 = "nut-elevator";
    const listview = React.useRef(null);
    const initData = {
      anchorIndex: 0,
      listHeight: [],
      listGroup: [],
      scrollY: 0
    };
    const touchState = React.useRef({
      y1: 0,
      y2: 0
    });
    const [scrollY, setScrollY] = React.useState(0);
    const [currentData, setCurrentData] = React.useState(
      {}
    );
    const [currentKey, setCurrentKey] = React.useState("");
    const [currentIndex, setCurrentIndex] = React.useState(0);
    const [codeIndex, setCodeIndex] = React.useState(0);
    const [scrollStart, setScrollStart] = React.useState(false);
    const state = React.useRef(initData);
    const resetScrollState = () => {
      setScrollStart(false);
    };
    const getData = (el, name) => {
      const prefix2 = "data-";
      return el.getAttribute(prefix2 + name);
    };
    const calculateHeight = () => {
      let height2 = 0;
      state.current.listHeight.push(height2);
      for (let i2 = 0; i2 < state.current.listGroup.length; i2++) {
        const item = state.current.listGroup[i2];
        height2 += item.clientHeight;
        state.current.listHeight.push(height2);
      }
    };
    const scrollTo = (index) => {
      if (!index && index !== 0) {
        return;
      }
      if (!state.current.listHeight.length) {
        calculateHeight();
      }
      let cacheIndex = index;
      if (index < 0) {
        cacheIndex = 0;
      }
      if (index > state.current.listHeight.length - 2) {
        cacheIndex = Math.max(0, state.current.listHeight.length - 2);
      }
      setCodeIndex(cacheIndex);
      if (listview.current) {
        listview.current.scrollTo(0, state.current.listHeight[cacheIndex]);
      }
    };
    const bind = useGesture({
      onDragStart: ({ target, offset }) => {
        setScrollStart(true);
        const index = Number(getData(target, "index"));
        touchState.current.y1 = offset[1];
        state.current.anchorIndex = +index;
        setCodeIndex((codeIndex2) => codeIndex2 + index);
        scrollTo(index);
      },
      onDragEnd: ({ offset }) => {
        touchState.current.y2 = offset[1];
        const delta = (touchState.current.y2 - touchState.current.y1) / spaceHeight || 0;
        const cacheIndex = state.current.anchorIndex + Math.round(delta);
        setCodeIndex(cacheIndex);
        scrollTo(cacheIndex);
        resetScrollState();
      }
    });
    const handleClickItem = (key, item) => {
      onItemClick && onItemClick(key, item);
      setCurrentData(item);
      setCurrentKey(key);
    };
    const handleClickIndex = (key) => {
      onIndexClick && onIndexClick(key);
    };
    const setListGroup = () => {
      if (listview.current) {
        const els = listview.current.querySelectorAll(".nut-elevator-list-item");
        els.forEach((el) => {
          if (el != null && !state.current.listGroup.includes(el)) {
            state.current.listGroup.push(el);
          }
        });
      }
    };
    const listViewScroll = (e) => {
      const { listHeight } = state.current;
      if (!listHeight.length) {
        calculateHeight();
      }
      const target = e.target;
      let { scrollTop } = target;
      scrollTop = Math.ceil(scrollTop);
      state.current.scrollY = scrollTop;
      setScrollY(scrollTop);
      for (let i2 = 0; i2 < listHeight.length - 1; i2++) {
        const height1 = listHeight[i2];
        const height2 = listHeight[i2 + 1];
        if (state.current.scrollY >= height1 && state.current.scrollY < height2) {
          setCurrentIndex(i2);
          return;
        }
      }
      setCurrentIndex(listHeight.length - 2);
    };
    React.useEffect(() => {
      if (listview.current) {
        setListGroup();
        listview.current.addEventListener("scroll", listViewScroll);
      }
    }, [listview]);
    return /* @__PURE__ */ React.createElement("div", { className: `${classPrefix2} ${className}`, style, ...rest }, sticky && scrollY > 0 ? /* @__PURE__ */ React.createElement("div", { className: `${classPrefix2}-list-fixed` }, /* @__PURE__ */ React.createElement("span", { className: `${classPrefix2}-list-fixed-title` }, list[currentIndex][floorKey])) : null, /* @__PURE__ */ React.createElement(
      "div",
      {
        className: `${classPrefix2}-list`,
        style: { height: Number.isNaN(+height) ? height : `${height}px` }
      },
      /* @__PURE__ */ React.createElement("div", { className: `${classPrefix2}-list-inner`, ref: listview }, list.map((item, idx) => {
        return /* @__PURE__ */ React.createElement("div", { className: `${classPrefix2}-list-item`, key: idx }, /* @__PURE__ */ React.createElement("div", { className: `${classPrefix2}-list-item-code` }, item[floorKey]), /* @__PURE__ */ React.createElement(React.Fragment, null, item.list.map((subitem) => {
          return /* @__PURE__ */ React.createElement(
            "div",
            {
              className: classNames({
                [`${classPrefix2}-list-item-name`]: true,
                [`${classPrefix2}-list-item-name-highcolor`]: currentData.id === subitem.id && currentKey === item[floorKey]
              }),
              key: subitem.id,
              onClick: () => handleClickItem(item[floorKey], subitem)
            },
            children ? /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(elevatorContext.Provider, { value: subitem }, children)) : subitem.name
          );
        })));
      }))
    ), showKeys ? /* @__PURE__ */ React.createElement(React.Fragment, null, list.length && scrollStart ? /* @__PURE__ */ React.createElement(
      "div",
      {
        className: classNames({
          [`${classPrefix2}-code-current`]: true,
          [`${classPrefix2}-code-current-current`]: true
        })
      },
      list[codeIndex][floorKey]
    ) : null, /* @__PURE__ */ React.createElement("div", { className: `${classPrefix2}-bars` }, /* @__PURE__ */ React.createElement(
      animated.div,
      {
        className: `${classPrefix2}-bars-inner`,
        ...bind(),
        style: { touchAction: "pan-y" }
      },
      list.map((item, index) => {
        return /* @__PURE__ */ React.createElement(
          "div",
          {
            className: classNames({
              [`${classPrefix2}-bars-inner-item`]: true,
              [`${classPrefix2}-bars-inner-item-active`]: item[floorKey] === list[currentIndex][floorKey]
            }),
            "data-index": index,
            key: index,
            onClick: () => handleClickIndex(item[floorKey])
          },
          item[floorKey]
        );
      })
    ))) : null);
  };
  Elevator.displayName = "NutElevator";
  Elevator.Context = elevatorContext;
  const defaultProps$1h = {
    ...ComponentDefaults,
    activeText: "",
    inactiveText: "",
    type: "right",
    position: {
      top: "auto",
      bottom: "auto"
    }
  };
  const FixedNav = (props) => {
    const { locale } = useConfig();
    const {
      className,
      overlay,
      visible,
      list,
      activeText,
      inactiveText,
      position,
      onChange,
      onSelect,
      type,
      children,
      style,
      content,
      ...rest
    } = {
      ...defaultProps$1h,
      ...props
    };
    const classPrefix2 = "nut-fixednav";
    const classes = classNames(
      classPrefix2,
      {
        active: visible
      },
      type,
      className
    );
    const handleClick2 = (item, event) => {
      onSelect(item, event);
    };
    const onUpdateValue = (value = !visible) => {
      onChange(value);
    };
    return /* @__PURE__ */ React.createElement(
      "div",
      {
        className: classes,
        style: {
          ...position,
          ...style
        },
        ...rest
      },
      overlay && /* @__PURE__ */ React.createElement(
        Overlay,
        {
          visible,
          style: { "--nutui-overlay-zIndex": 200 },
          onClick: () => onUpdateValue(false)
        }
      ),
      /* @__PURE__ */ React.createElement("div", { className: "list" }, children || /* @__PURE__ */ React.createElement("div", { className: `${classPrefix2}-list` }, list.map((item, index) => {
        return /* @__PURE__ */ React.createElement(
          "div",
          {
            className: `${classPrefix2}-list-item`,
            onClick: (event) => handleClick2(item, event),
            key: item.id || index
          },
          React.isValidElement(item.icon) ? item.icon : /* @__PURE__ */ React.createElement("img", { src: item.icon, alt: "" }),
          /* @__PURE__ */ React.createElement("div", { className: `${classPrefix2}-list-text` }, item.text),
          item.num && /* @__PURE__ */ React.createElement("div", { className: "b" }, item.num)
        );
      }))),
      /* @__PURE__ */ React.createElement("div", { className: `${classPrefix2}-btn`, onClick: () => onUpdateValue() }, content || /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(n$6, { color: "#fff" }), /* @__PURE__ */ React.createElement("div", { className: "text" }, visible ? activeText || locale.fixednav.activeText : inactiveText || locale.fixednav.inactiveText)))
    );
  };
  FixedNav.displayName = "NutFixedNav";
  const defaultProps$1g = {
    ...ComponentDefaults,
    left: "",
    right: "",
    titleAlign: "center",
    back: "",
    fixed: false,
    safeAreaInsetTop: false,
    placeholder: false,
    zIndex: 10
  };
  const NavBar = (props) => {
    const {
      right,
      left,
      titleAlign,
      className,
      style,
      back,
      fixed,
      safeAreaInsetTop,
      placeholder,
      zIndex,
      onBackClick
    } = {
      ...defaultProps$1g,
      ...props
    };
    const classPrefix2 = "nut-navbar";
    const children = Array.isArray(props.children) ? props.children : [props.children];
    const styles = () => {
      return {
        ...style,
        zIndex
      };
    };
    const leftRef = React.useRef(null);
    const rightRef = React.useRef(null);
    const wrapperRef = React.useRef(null);
    const [contentWidth, setContentWidth] = React.useState("50%");
    const getNodeWidth = (node) => {
      if (node) {
        const ele = getRect(node);
        return ele.width;
      }
      return 0;
    };
    React.useEffect(() => {
      if (titleAlign === "left") {
        return;
      }
      if (!(back || left || right)) {
        setContentWidth("100%");
        return;
      }
      const leftRectWidth = getNodeWidth(leftRef == null ? void 0 : leftRef.current);
      const rightRectWidth = getNodeWidth(rightRef == null ? void 0 : rightRef.current);
      const wrapperWidth = getNodeWidth(wrapperRef == null ? void 0 : wrapperRef.current);
      let centerWidth = wrapperWidth / 2;
      if (leftRectWidth && rightRectWidth) {
        centerWidth = wrapperWidth - (leftRectWidth > rightRectWidth ? leftRectWidth * 2 : rightRectWidth * 2);
      } else {
        centerWidth = wrapperWidth - leftRectWidth * 2 - rightRectWidth * 2;
      }
      setContentWidth(centerWidth.toFixed(2));
    }, [left, right, back]);
    const renderLeft = () => {
      return back || left ? /* @__PURE__ */ React.createElement("div", { className: `${classPrefix2}-left`, ref: leftRef }, back && /* @__PURE__ */ React.createElement(
        "div",
        {
          className: `${classPrefix2}-left-back`,
          onClick: (e) => onBackClick(e)
        },
        back
      ), left) : null;
    };
    const renderContent = () => {
      let titleStyle = {};
      if (titleAlign === "center") {
        const contentRealWidth = `${contentWidth}${/%$/i.test(contentWidth) ? "" : "px"}`;
        titleStyle = {
          minWidth: contentRealWidth,
          width: contentRealWidth
        };
      }
      return /* @__PURE__ */ React.createElement("div", { className: `${classPrefix2}-title`, style: titleStyle }, children);
    };
    const renderRight = () => {
      return /* @__PURE__ */ React.createElement("div", { className: `${classPrefix2}-right`, ref: rightRef }, right);
    };
    const renderWrapper = () => {
      return /* @__PURE__ */ React.createElement("div", { className: cls, style: styles(), ref: wrapperRef }, renderLeft(), renderContent(), renderRight());
    };
    const classes = classNames({
      [`${classPrefix2}-fixed`]: fixed,
      [`${classPrefix2}-title-align-${titleAlign}`]: true
    });
    const cls = classNames(classPrefix2, classes, className);
    return /* @__PURE__ */ React.createElement(React.Fragment, null, safeAreaInsetTop && /* @__PURE__ */ React.createElement(SafeArea, { position: "top" }), fixed && placeholder ? /* @__PURE__ */ React.createElement("div", { className: `${classPrefix2}-placeholder` }, renderWrapper()) : renderWrapper());
  };
  NavBar.displayName = "NutNavBar";
  const defaultProps$1f = {
    ...ComponentDefaults,
    position: "center",
    transition: "",
    overlayStyle: {},
    overlayClassName: "",
    closeable: false,
    closeIconPosition: "top-right",
    closeIcon: "close",
    destroyOnClose: false,
    portal: null,
    overlay: true,
    round: false,
    onOpen: () => {
    },
    onClose: () => {
    },
    onOverlayClick: (e) => true,
    onCloseIconClick: (e) => true,
    ...defaultOverlayProps
  };
  const _zIndex = 1100;
  const Popup = (props) => {
    const {
      children,
      visible,
      overlay,
      closeOnOverlayClick,
      overlayStyle,
      overlayClassName,
      zIndex,
      lockScroll,
      duration,
      closeable,
      closeIconPosition,
      closeIcon,
      left,
      title,
      description,
      style,
      transition,
      round,
      position,
      className,
      destroyOnClose,
      portal,
      onOpen,
      onClose,
      onOverlayClick,
      onCloseIconClick,
      afterShow,
      afterClose,
      onClick
    } = { ...defaultProps$1f, ...props };
    const nodeRef = React.useRef(null);
    let innerIndex = zIndex || _zIndex;
    const [index, setIndex] = React.useState(innerIndex);
    const [innerVisible, setInnerVisible] = React.useState(visible);
    const [showChildren, setShowChildren] = React.useState(true);
    const [transitionName, setTransitionName] = React.useState("");
    const shouldLockScroll = !innerVisible ? false : lockScroll;
    useLockScroll(nodeRef, shouldLockScroll);
    const classPrefix2 = "nut-popup";
    const baseStyle = {
      zIndex: index
    };
    const overlayStyles = {
      ...overlayStyle,
      "--nutui-overlay-zIndex": index
    };
    const popStyles = {
      ...style,
      ...baseStyle
    };
    const popClassName = classNames(
      {
        [`${classPrefix2}`]: true,
        [`${classPrefix2}-round`]: round || position === "bottom",
        [`${classPrefix2}-${position}`]: true
      },
      className
    );
    const closeClasses = classNames({
      [`${classPrefix2}-title-right`]: true,
      [`${classPrefix2}-title-right-${closeIconPosition}`]: true
    });
    const open = () => {
      if (!innerVisible) {
        setInnerVisible(true);
        setIndex(++innerIndex);
      }
      if (destroyOnClose) {
        setShowChildren(true);
      }
      onOpen && onOpen();
    };
    const close = () => {
      if (innerVisible) {
        setInnerVisible(false);
        if (destroyOnClose) {
          setTimeout(() => {
            setShowChildren(false);
          }, Number(duration));
        }
        onClose && onClose();
      }
    };
    const onHandleClickOverlay = (e) => {
      e.stopPropagation();
      if (closeOnOverlayClick) {
        const closed = onOverlayClick && onOverlayClick(e);
        closed && close();
      }
    };
    const onHandleClick = (e) => {
      onClick && onClick(e);
    };
    const onHandleClickCloseIcon = (e) => {
      const closed = onCloseIconClick && onCloseIconClick(e);
      closed && close();
    };
    const onHandleOpened = (e) => {
      afterShow && afterShow();
    };
    const onHandleClosed = (e) => {
      afterClose && afterClose();
    };
    const resolveContainer = (getContainer) => {
      const container = typeof getContainer === "function" ? getContainer() : getContainer;
      return container || document.body;
    };
    const renderToContainer = (getContainer, node) => {
      if (getContainer) {
        const container = resolveContainer(getContainer);
        return ReactDOM.createPortal(node, container);
      }
      return node;
    };
    const renderTitle = () => {
      if (left || title || description) {
        return /* @__PURE__ */ React.createElement("div", { className: `${classPrefix2}-title` }, position === "bottom" && /* @__PURE__ */ React.createElement(React.Fragment, null, left && /* @__PURE__ */ React.createElement("div", { className: `${classPrefix2}-title-left` }, left), (title || description) && /* @__PURE__ */ React.createElement("div", { className: `${classPrefix2}-title-title` }, title, description && /* @__PURE__ */ React.createElement("div", { className: `${classPrefix2}-title-description` }, description))), closeable && /* @__PURE__ */ React.createElement("div", { className: closeClasses, onClick: onHandleClickCloseIcon }, React.isValidElement(closeIcon) ? closeIcon : /* @__PURE__ */ React.createElement(n$5, null)));
      }
      if (closeable) {
        return /* @__PURE__ */ React.createElement(React.Fragment, null, closeable && /* @__PURE__ */ React.createElement("div", { className: closeClasses, onClick: onHandleClickCloseIcon }, React.isValidElement(closeIcon) ? closeIcon : /* @__PURE__ */ React.createElement(n$5, null)));
      }
    };
    const renderPop = () => {
      return /* @__PURE__ */ React.createElement(
        CSSTransition,
        {
          nodeRef,
          classNames: transitionName,
          mountOnEnter: true,
          unmountOnExit: destroyOnClose,
          timeout: duration,
          in: innerVisible,
          onEntered: onHandleOpened,
          onExited: onHandleClosed
        },
        /* @__PURE__ */ React.createElement(
          "div",
          {
            ref: nodeRef,
            style: popStyles,
            className: popClassName,
            onClick: onHandleClick
          },
          renderTitle(),
          showChildren ? children : ""
        )
      );
    };
    const renderNode = () => {
      return /* @__PURE__ */ React.createElement(React.Fragment, null, overlay ? /* @__PURE__ */ React.createElement(
        Overlay,
        {
          style: overlayStyles,
          className: overlayClassName,
          visible: innerVisible,
          closeOnOverlayClick,
          lockScroll,
          duration,
          onClick: onHandleClickOverlay
        }
      ) : null, /* @__PURE__ */ React.createElement(React.Fragment, null, renderPop()));
    };
    React.useEffect(() => {
      visible && open();
      !visible && close();
    }, [visible]);
    React.useEffect(() => {
      setTransitionName(transition || `${classPrefix2}-slide-${position}`);
    }, [position, transition]);
    return /* @__PURE__ */ React.createElement(React.Fragment, null, renderToContainer(portal, renderNode()));
  };
  Popup.displayName = "NutPopup";
  const handleClick = (e) => {
    e.stopPropagation();
    const isIcon = e.target.className.includes("arrow-icon");
    const isTitle = e.target.className.includes("-title") || isIcon;
    const currentClass = e.currentTarget.className;
    const isShow = currentClass.includes("sidenavbar-show");
    const arrowIcon = e.currentTarget.querySelector(".arrow-icon");
    const iconClass = arrowIcon.className;
    if (isTitle) {
      e.currentTarget.className = isShow ? currentClass.replace("sidenavbar-show", "sidenavbar-hide") : currentClass.replace("sidenavbar-hide", "sidenavbar-show");
      arrowIcon.className = isShow ? iconClass.replace("arrow-down", "arrow-up") : iconClass.replace("arrow-up", "arrow-down");
    }
  };
  const OffsetContext = React.createContext(20);
  const defaultProps$1e = {
    ...ComponentDefaults,
    position: "left",
    width: "80%"
  };
  const SideNavBar = (props) => {
    const classPrefix2 = "nut-sidenavbar";
    const {
      title,
      visible,
      width,
      position,
      children,
      className,
      onClose,
      indent,
      ...rest
    } = {
      ...defaultProps$1e,
      ...props
    };
    const innerIndent = indent ? Number(indent) : 20;
    return /* @__PURE__ */ React.createElement(
      Popup,
      {
        visible,
        style: { width, height: "100%" },
        position,
        onClose
      },
      /* @__PURE__ */ React.createElement("div", { className: classNames(classPrefix2, className), ...rest }, /* @__PURE__ */ React.createElement("div", { className: `${classPrefix2}-content` }, /* @__PURE__ */ React.createElement(
        "div",
        {
          className: `${classPrefix2}-list sidenavbar-show`,
          onClick: handleClick
        },
        /* @__PURE__ */ React.createElement(
          "div",
          {
            className: `${classPrefix2}-title ${classPrefix2}-border-bt`,
            style: { paddingLeft: `${innerIndent}px` }
          },
          title,
          " ",
          /* @__PURE__ */ React.createElement("i", { className: "arrow-icon arrow-down" })
        ),
        /* @__PURE__ */ React.createElement(OffsetContext.Provider, { value: innerIndent }, /* @__PURE__ */ React.createElement("div", { className: `${classPrefix2}-content` }, children))
      )))
    );
  };
  SideNavBar.displayName = "NutSideNavBar";
  const SideNavBarItem = (props) => {
    const classPrefix2 = "nut-subsidenavbar";
    const { title, value, children, onClick, ...rest } = props;
    const clickFn = (e) => {
      e.stopPropagation();
      onClick && onClick({ title, value });
    };
    return /* @__PURE__ */ React.createElement(
      "div",
      {
        className: `${classPrefix2}-item ${classPrefix2}-border-bt`,
        onClick: clickFn,
        ...rest
      },
      title
    );
  };
  const defaultProps$1d = {
    open: true
  };
  const SubSideNavBar = (props) => {
    const classPrefix2 = "nut-subsidenavbar";
    const { title, value, children, onClick, open, ...rest } = {
      ...defaultProps$1d,
      ...props
    };
    const offset = React.useContext(OffsetContext);
    const listRef = React.useRef(null);
    const setListLevel = React.useCallback(
      (nodeList, level = 1) => {
        const titleClass = nodeList[0].className;
        if (titleClass.includes(`${classPrefix2}-title`)) {
          const left = offset * (level + 1);
          nodeList[0].style.paddingLeft = `${left}px`;
        }
        const childNodes = nodeList[1] && nodeList[1].children && Array.from(nodeList[1].children).filter(
          (item) => item.nodeType !== 3 && item.nodeType !== 8
        );
        childNodes.forEach((item) => {
          const itemClass = item.className;
          if (itemClass.includes(`${classPrefix2}-item`)) {
            const left = offset * (level + 2);
            item.style.paddingLeft = `${left}px`;
          }
          if (itemClass.includes(`${classPrefix2}-list`)) {
            let level2 = item.getAttribute("level") ? Number(item.getAttribute("level")) : 1;
            level2 += 1;
            item.setAttribute("level", level2.toString());
            item.children && setListLevel(item.children, level2);
          }
        });
      },
      [offset]
    );
    const clickFn = (e) => {
      handleClick(e);
      const currentClass = e.currentTarget.className;
      const isShow = currentClass.includes("sidenavbar-show");
      onClick && onClick({ title, value, isShow });
    };
    React.useEffect(() => {
      var _a, _b;
      const childNodes = (_a = listRef.current) == null ? void 0 : _a.children;
      (_b = listRef.current) == null ? void 0 : _b.setAttribute("level", "1");
      childNodes && setListLevel(childNodes);
    }, [setListLevel]);
    const divClass = open ? `${classPrefix2}-list sidenavbar-show` : `${classPrefix2}-list sidenavbar-hide`;
    const iconClass = open ? "arrow-icon arrow-down" : "arrow-icon arrow-up";
    return /* @__PURE__ */ React.createElement("div", { className: divClass, ref: listRef, onClick: clickFn, ...rest }, /* @__PURE__ */ React.createElement("div", { className: `${classPrefix2}-title ${classPrefix2}-border-bt` }, title, " ", /* @__PURE__ */ React.createElement("i", { className: iconClass })), /* @__PURE__ */ React.createElement("div", { className: `${classPrefix2}-content` }, children));
  };
  function useForceUpdate() {
    const [, updateState] = React.useState();
    return React.useCallback(() => updateState({}), []);
  }
  function usePropsValue({
    value,
    defaultValue,
    finalValue,
    onChange = (value2) => {
    }
  }) {
    const forceUpdate = useForceUpdate();
    const dfValue = defaultValue !== void 0 ? defaultValue : finalValue;
    const stateRef = React.useRef(value !== void 0 ? value : dfValue);
    if (value !== void 0) {
      stateRef.current = value;
    }
    const setState = React.useCallback(
      (v, forceTrigger = false) => {
        const prevState = stateRef.current;
        stateRef.current = v;
        if (prevState !== stateRef.current || forceTrigger) {
          forceUpdate();
          onChange == null ? void 0 : onChange(v);
        }
      },
      [value, onChange]
    );
    return [stateRef.current, setState];
  }
  const defaultProps$1c = {
    ...ComponentDefaults,
    value: "",
    dot: false,
    max: 99,
    top: "4",
    right: "8",
    color: "",
    fill: "solid"
  };
  const Badge = (props) => {
    var _a;
    const rtl = useRtl();
    const {
      className,
      style,
      value,
      max,
      children,
      dot,
      top,
      right,
      color,
      fill
    } = {
      ...defaultProps$1c,
      ...props
    };
    const classPrefix2 = "nut-badge";
    const classes = classNames(classPrefix2, className, {
      [`${classPrefix2}-${fill}`]: fill === "outline"
    });
    function content() {
      if (dot || typeof value === "object" || value === 0) return null;
      if (typeof value === "number" && typeof max === "number") {
        return max < value ? `${max}+` : `${value}`;
      }
      return value;
    }
    function isIcon() {
      if (typeof value === "object" && value) return value;
    }
    function isNumber() {
      if (typeof value === "number" && value) return value;
    }
    function isString() {
      if (typeof value === "string" && value) return value;
    }
    const contentClasses = classNames(
      { [`${classPrefix2}-dot`]: dot },
      `${classPrefix2}-content`,
      { [`${classPrefix2}-sup`]: isNumber() || isString() || dot },
      {
        [`${classPrefix2}-one`]: typeof content() === "string" && ((_a = `${content()}`) == null ? void 0 : _a.length) === 1
      }
    );
    const getStyle = () => {
      const style2 = {};
      style2.top = `${Number(top) || parseFloat(String(top)) || 0}px`;
      const dir = rtl ? "left" : "right";
      style2[dir] = `${Number(right) || parseFloat(String(right)) || 0}px`;
      if (color) {
        if (fill === "outline") {
          style2.color = color;
          style2.background = "#fff";
          if (!(color == null ? void 0 : color.includes("gradient"))) {
            style2.border = `1px solid ${color}`;
          }
        } else {
          style2.color = "#fff";
          style2.background = color;
        }
      }
      return style2;
    };
    return /* @__PURE__ */ React.createElement("div", { className: classes, style }, isIcon() && /* @__PURE__ */ React.createElement("div", { className: `${classPrefix2}-icon` }, value), children, !isIcon() && /* @__PURE__ */ React.createElement("div", { className: contentClasses, style: getStyle() }, content()));
  };
  Badge.displayName = "NutBadge";
  const TabbarContext = React.createContext(null);
  const defaultProps$1b = {
    ...ComponentDefaults,
    title: "",
    icon: null,
    value: "",
    dot: false,
    max: 99,
    top: "0",
    right: "5"
  };
  const TabbarItem = (props) => {
    const ctx2 = React.useContext(TabbarContext);
    const {
      className,
      style,
      title,
      icon,
      value,
      dot,
      max,
      top,
      right,
      // @ts-ignore
      index,
      ...rest
    } = {
      ...defaultProps$1b,
      ...props
    };
    const active = index === (ctx2 == null ? void 0 : ctx2.selectIndex);
    const classPrefix2 = "nut-tabbar-item";
    const tabbarItemClass = classNames(
      classPrefix2,
      {
        [`${classPrefix2}-active`]: active
      },
      className
    );
    const boxPrefix = `${classPrefix2}-icon-box`;
    const titleClass = classNames(boxPrefix, `${boxPrefix}-nav`, {
      [`${boxPrefix}-large`]: !icon
    });
    const badgeProps = {
      value,
      dot,
      max,
      top,
      right,
      color: ctx2 == null ? void 0 : ctx2.activeColor
    };
    return /* @__PURE__ */ React.createElement(
      "div",
      {
        className: tabbarItemClass,
        style: {
          color: active ? ctx2 == null ? void 0 : ctx2.activeColor : ctx2 == null ? void 0 : ctx2.inactiveColor,
          ...style
        },
        onClick: () => ctx2 == null ? void 0 : ctx2.handleClick(index),
        ...rest
      },
      icon ? /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(Badge, { ...badgeProps }, /* @__PURE__ */ React.createElement("div", { className: boxPrefix }, icon)), /* @__PURE__ */ React.createElement("div", { className: titleClass }, title)) : /* @__PURE__ */ React.createElement(Badge, { ...badgeProps }, /* @__PURE__ */ React.createElement("div", { className: titleClass }, title))
    );
  };
  const defaultProps$1a = {
    ...ComponentDefaults,
    defaultValue: 0,
    fixed: false,
    inactiveColor: "",
    activeColor: "",
    safeArea: false,
    onSwitch: (value) => {
    }
  };
  const Tabbar = (props) => {
    const {
      children,
      defaultValue,
      value,
      fixed,
      activeColor,
      inactiveColor,
      safeArea,
      className,
      style,
      onSwitch
    } = {
      ...defaultProps$1a,
      ...props
    };
    const classPrefix2 = "nut-tabbar";
    const [selectIndex, setSelectIndex] = usePropsValue({
      value,
      defaultValue,
      finalValue: 0,
      onChange: onSwitch
    });
    return /* @__PURE__ */ React.createElement(
      "div",
      {
        className: classNames(
          classPrefix2,
          {
            [`${classPrefix2}-fixed`]: fixed
          },
          className
        ),
        style
      },
      /* @__PURE__ */ React.createElement("div", { className: `${classPrefix2}-wrap` }, /* @__PURE__ */ React.createElement(
        TabbarContext.Provider,
        {
          value: {
            selectIndex,
            activeColor,
            inactiveColor,
            handleClick: setSelectIndex
          }
        },
        React.Children.map(children, (child, index) => {
          if (!React.isValidElement(child)) return null;
          return React.cloneElement(child, { ...child.props, index });
        })
      )),
      (fixed || safeArea) && /* @__PURE__ */ React.createElement("div", { className: `${classPrefix2}-safe-area` })
    );
  };
  Tabbar.displayName = "NutTabbar";
  Tabbar.Item = TabbarItem;
  const defaultProps$19 = {
    title: "",
    value: "",
    disabled: false
  };
  const TabPane = (props) => {
    const { children, autoHeightClassName, className, disabled } = {
      ...defaultProps$19,
      ...props
    };
    const classPrefix2 = "nut-tabpane";
    const classes = classNames(
      classPrefix2,
      {
        active: !disabled && props.active
      },
      autoHeightClassName,
      className
    );
    return children ? /* @__PURE__ */ React.createElement("div", { className: classes }, !disabled && children) : null;
  };
  const defaultProps$18 = {
    ...ComponentDefaults,
    tabStyle: {},
    activeColor: "",
    direction: "horizontal",
    activeType: "line",
    duration: 300,
    autoHeight: false
  };
  const classPrefix$j = "nut-tabs";
  const Tabs = (props) => {
    const rtl = useRtl();
    const {
      activeColor,
      tabStyle,
      direction,
      activeType,
      duration,
      align,
      title,
      children,
      onClick,
      onChange,
      className,
      autoHeight,
      value: outerValue,
      defaultValue: outerDefaultValue,
      ...rest
    } = { ...defaultProps$18, ...props };
    const [value, setValue] = usePropsValue({
      value: outerValue,
      defaultValue: outerDefaultValue,
      onChange
    });
    const titleItemsRef = React.useRef([]);
    const navRef = React.useRef(null);
    const scrollDirection = (nav, to2, duration2) => {
      const from = direction === "horizontal" ? nav.scrollLeft : nav.scrollTop;
      const frames = Math.round(duration2 * 1e3 / 16);
      let count = 0;
      const animate = () => {
        if (direction === "horizontal") nav.scrollLeft += (to2 - from) / frames;
        else nav.scrollTop += (to2 - from) / frames;
        if (++count < frames) requestAniFrame$1(animate);
      };
      animate();
    };
    const scrollIntoView = (index, immediate) => {
      const nav = navRef.current;
      const titleItem = titleItemsRef.current;
      const titlesLength = titles.current.length;
      const itemLength = titleItem.length;
      if (!nav || !titleItem || !titleItem[itemLength - titlesLength + index]) {
        return;
      }
      const title2 = titleItem[itemLength - titlesLength + index];
      let to2 = 0;
      if (direction === "vertical") {
        const runTop = title2.offsetTop - nav.offsetTop + 10;
        to2 = runTop - (nav.offsetHeight - title2.offsetHeight) / 2;
      } else {
        to2 = title2.offsetLeft - (nav.offsetWidth - title2.offsetWidth) / 2;
      }
      scrollDirection(nav, to2, 0.3);
    };
    const getTitles = () => {
      const titles2 = [];
      React.Children.forEach(children, (child, idx) => {
        if (React.isValidElement(child)) {
          const { props: props2 } = child;
          if ((props2 == null ? void 0 : props2.title) || (props2 == null ? void 0 : props2.value)) {
            titles2.push({
              title: props2.title,
              value: props2.value || idx,
              disabled: props2.disabled
            });
          }
        }
      });
      return titles2;
    };
    const titles = React.useRef(getTitles());
    const forceUpdate = useForceUpdate();
    React.useEffect(() => {
      titles.current = getTitles();
      let current = "";
      titles.current.forEach((title2) => {
        if (title2.value === value) {
          current = value;
        }
      });
      if (current !== "" && current !== value) {
        setValue(current);
      } else {
        forceUpdate();
      }
    }, [children]);
    const classes = classNames(
      classPrefix$j,
      `${classPrefix$j}-${direction}`,
      className
    );
    const classesTitle = classNames(`${classPrefix$j}-titles`, {
      [`${classPrefix$j}-titles-${activeType}`]: activeType,
      [`${classPrefix$j}-titles-${align}`]: align
    });
    const getContentStyle = () => {
      let index = titles.current.findIndex((t) => t.value === value);
      index = index < 0 ? 0 : index;
      return {
        transform: direction === "horizontal" ? `translate3d(${rtl ? "" : "-"}${index * 100}%, 0, 0)` : `translate3d( 0, -${index * 100}%, 0)`,
        transitionDuration: `${duration}ms`
      };
    };
    React.useEffect(() => {
      let index = titles.current.findIndex((t) => t.value === value);
      index = index < 0 ? 0 : index;
      setTimeout(() => {
        scrollIntoView(index);
      });
    }, [value]);
    const tabChange = (item) => {
      onClick && onClick(item.value);
      if (!item.disabled) {
        setValue(item.value);
      }
    };
    return /* @__PURE__ */ React.createElement("div", { className: classes, ...rest }, /* @__PURE__ */ React.createElement("div", { className: classesTitle, style: tabStyle, ref: navRef }, !!title && typeof title === "function" ? title() : titles.current.map((item) => {
      return /* @__PURE__ */ React.createElement(
        "div",
        {
          key: item.value,
          ref: (ref) => titleItemsRef.current.push(ref),
          onClick: () => tabChange(item),
          className: classNames(`${classPrefix$j}-titles-item`, {
            [`nut-tabs-titles-item-active`]: !item.disabled && String(item.value) === String(value),
            [`nut-tabs-titles-item-disabled`]: item.disabled,
            [`nut-tabs-titles-item-${align}`]: align
          })
        },
        activeType === "line" && /* @__PURE__ */ React.createElement(
          "div",
          {
            className: classNames(
              `${classPrefix$j}-titles-item-line`,
              `${classPrefix$j}-titles-item-line-${direction}`
            ),
            style: { background: activeColor }
          }
        ),
        activeType === "smile" && /* @__PURE__ */ React.createElement("div", { className: `${classPrefix$j}-titles-item-smile` }, /* @__PURE__ */ React.createElement(c$3, { color: activeColor, width: 40, height: 20 })),
        /* @__PURE__ */ React.createElement(
          "div",
          {
            className: classNames(
              {
                [`${classPrefix$j}-ellipsis`]: direction === "vertical"
              },
              `${classPrefix$j}-titles-item-text`
            ),
            style: { color: activeColor }
          },
          item.title
        )
      );
    })), /* @__PURE__ */ React.createElement("div", { className: `${classPrefix$j}-content-wrap` }, /* @__PURE__ */ React.createElement("div", { className: `${classPrefix$j}-content`, style: getContentStyle() }, React.Children.map(children, (child, idx) => {
      if (!React.isValidElement(child)) return null;
      return React.cloneElement(child, {
        ...child.props,
        active: value === child.props.value,
        autoHeightClassName: autoHeight && String(value) !== String(child.props.value || idx) ? "inactive" : void 0
      });
    }))));
  };
  Tabs.displayName = "NutTabs";
  Tabs.TabPane = TabPane;
  const formatTree = (tree, parent, config2) => tree.map((node) => {
    const {
      value: valueKey = "value",
      text: textKey = "text",
      children: childrenKey = "children"
    } = config2;
    const {
      [valueKey]: value,
      [textKey]: text,
      [childrenKey]: children,
      ...others
    } = node;
    const newNode = {
      loading: false,
      ...others,
      level: parent ? (parent && parent.level || 0) + 1 : 0,
      value,
      text,
      children,
      _parent: parent
    };
    if (newNode.children && newNode.children.length) {
      newNode.children = formatTree(newNode.children, newNode, config2);
    }
    return newNode;
  });
  const eachTree = (tree, cb) => {
    let i2 = 0;
    let node;
    while (node = tree[i2++]) {
      if (cb(node) === true) {
        break;
      }
      if (node.children && node.children.length) {
        eachTree(node.children, cb);
      }
    }
  };
  const defaultConvertConfig = {
    topId: null,
    idKey: "id",
    pidKey: "pid",
    sortKey: ""
  };
  const convertListToOptions = (list, options2) => {
    const mergedOptions = {
      ...defaultConvertConfig,
      ...options2 || {}
    };
    const { topId, idKey, pidKey, sortKey } = mergedOptions;
    let result = [];
    let map = {};
    list.forEach((node) => {
      node = { ...node };
      const { [idKey]: id, [pidKey]: pid } = node;
      const children = map[pid] = map[pid] || [];
      if (!result.length && pid === topId) {
        result = children;
      }
      children.push(node);
      node.children = map[id] || (map[id] = []);
    });
    if (sortKey) {
      Object.keys(map).forEach((i2) => {
        if (map[i2].length > 1) {
          map[i2].sort((a, b) => a[sortKey] - b[sortKey]);
        }
      });
    }
    map = null;
    return result;
  };
  class Tree {
    constructor(nodes, config2) {
      this.isLeaf = (node, lazy) => {
        const { leaf, children } = node;
        const hasChildren = Array.isArray(children) && Boolean(children.length);
        return leaf || !hasChildren && !lazy;
      };
      this.hasChildren = (node, lazy) => {
        const isLeaf = this.isLeaf(node, lazy);
        if (isLeaf) {
          return false;
        }
        const { children } = node;
        return Array.isArray(children) && Boolean(children.length);
      };
      this.config = {
        value: "value",
        text: "text",
        children: "children",
        ...config2 || {}
      };
      this.nodes = formatTree(nodes, null, this.config);
    }
    updateChildren(nodes, parent) {
      if (!parent) {
        this.nodes = formatTree(nodes, null, this.config);
      } else {
        parent.children = formatTree(nodes, parent, this.config);
      }
    }
    // for test
    getNodeByValue(value) {
      let foundNode;
      eachTree(this.nodes, (node) => {
        if (node.value === value) {
          foundNode = node;
          return true;
        }
        return null;
      });
      return foundNode;
    }
    getPathNodesByValue(value) {
      if (!value.length) {
        return [];
      }
      const pathNodes = [];
      let currentNodes = this.nodes;
      while (currentNodes && currentNodes.length) {
        const foundNode = currentNodes.find(
          (node) => node.value === value[node.level]
        );
        if (!foundNode) {
          break;
        }
        pathNodes.push(foundNode);
        currentNodes = foundNode.children;
      }
      return pathNodes;
    }
  }
  const defaultProps$17 = {
    ...ComponentDefaults,
    activeColor: "",
    activeIcon: "checklist",
    popup: true,
    options: [],
    optionKey: { textKey: "text", valueKey: "value", childrenKey: "children" },
    format: {},
    closeable: false,
    closeIconPosition: "top-right",
    closeIcon: "close",
    lazy: false,
    onLoad: () => {
    },
    onClose: () => {
    },
    onChange: () => {
    },
    onPathChange: () => {
    }
  };
  const InternalCascader = (props, ref) => {
    const { locale } = useConfig();
    const {
      className,
      style,
      activeColor,
      activeIcon,
      popup,
      popupProps = {},
      visible,
      options: options2,
      value,
      defaultValue,
      optionKey,
      format: format2,
      closeable,
      closeIconPosition,
      closeIcon,
      lazy,
      title,
      left,
      onLoad,
      onClose,
      onChange,
      onPathChange
    } = { ...defaultProps$17, ...props };
    const [tabvalue, setTabvalue] = React.useState("c1");
    const [optionsData, setOptionsData] = React.useState([]);
    const isLazy = () => state.configs.lazy && Boolean(state.configs.onLoad);
    const [innerValue, setInnerValue] = usePropsValue({
      value,
      defaultValue,
      finalValue: defaultValue
    });
    const [innerVisible, setInnerVisible] = usePropsValue({
      value: visible,
      defaultValue: void 0,
      finalValue: false
    });
    const actions = {
      open: () => {
        setInnerVisible(true);
      },
      close: () => {
        setInnerVisible(false);
      }
    };
    React.useImperativeHandle(ref, () => actions);
    const [state] = React.useState({
      optionsData: [],
      panes: [
        {
          nodes: [],
          selectedNode: [],
          paneKey: ""
        }
      ],
      tree: new Tree([], {}),
      tabsCursor: 0,
      // 选中的tab项
      initLoading: false,
      currentProcessNode: [],
      configs: {
        lazy,
        onLoad,
        optionKey,
        format: format2
      },
      lazyLoadMap: /* @__PURE__ */ new Map()
    });
    const classPrefix2 = classNames(`nut-cascader`);
    const classesPane = classNames({
      [`${classPrefix2}-pane`]: true
    });
    React.useEffect(() => {
      initData();
    }, [options2, format2]);
    React.useEffect(() => {
      syncValue();
    }, [value]);
    const initData = async () => {
      state.lazyLoadMap.clear();
      if (format2 && Object.keys(format2).length > 0) {
        state.optionsData = convertListToOptions(
          options2,
          format2
        );
      } else {
        state.optionsData = options2;
      }
      state.tree = new Tree(state.optionsData, {
        value: state.configs.optionKey.valueKey,
        text: state.configs.optionKey.textKey,
        children: state.configs.optionKey.childrenKey
      });
      if (isLazy() && !state.tree.nodes.length) {
        await invokeLazyLoad({
          root: true,
          loading: true,
          text: "",
          value: ""
        });
      }
      state.panes = [
        {
          nodes: state.tree.nodes,
          selectedNode: null,
          paneKey: "c1"
        }
      ];
      syncValue();
      setOptionsData(state.panes);
    };
    const syncValue = async () => {
      const currentValue = innerValue;
      if (currentValue === void 0 || ![defaultValue, value].includes(currentValue) || !state.tree.nodes.length) {
        return;
      }
      if (currentValue.length === 0) {
        state.tabsCursor = 0;
        return;
      }
      let needToSync = currentValue;
      if (isLazy() && Array.isArray(currentValue) && currentValue.length) {
        needToSync = [];
        const parent = state.tree.nodes.find(
          (node) => node.value === currentValue[0]
        );
        if (parent) {
          needToSync = [parent.value];
          state.initLoading = true;
          const last = await currentValue.slice(1).reduce(async (p2, value2) => {
            var _a;
            const parent2 = await p2;
            await invokeLazyLoad(parent2);
            const node = (_a = parent2 == null ? void 0 : parent2.children) == null ? void 0 : _a.find(
              (item) => item.value === value2
            );
            if (node) {
              needToSync.push(value2);
            }
            return Promise.resolve(node);
          }, Promise.resolve(parent));
          await invokeLazyLoad(last);
          state.initLoading = false;
        }
      }
      if (needToSync.length && [defaultValue, value].includes(currentValue)) {
        const pathNodes = state.tree.getPathNodesByValue(needToSync);
        pathNodes.forEach((node, index) => {
          state.tabsCursor = index;
          chooseItem(node, true);
        });
      }
    };
    const invokeLazyLoad = async (node) => {
      if (!node) {
        return;
      }
      if (!state.configs.onLoad) {
        node.leaf = true;
        return;
      }
      if (state.tree.isLeaf(node, isLazy()) || state.tree.hasChildren(node, isLazy())) {
        return;
      }
      node.loading = true;
      const parent = node.root ? null : node;
      let lazyLoadPromise = state.lazyLoadMap.get(node);
      if (!lazyLoadPromise) {
        lazyLoadPromise = new Promise((resolve) => {
          var _a, _b;
          (_b = (_a = state.configs).onLoad) == null ? void 0 : _b.call(_a, node, resolve);
        });
        state.lazyLoadMap.set(node, lazyLoadPromise);
      }
      const nodes = await lazyLoadPromise;
      if (Array.isArray(nodes) && nodes.length > 0) {
        state.tree.updateChildren(nodes, parent);
      } else {
        node.leaf = true;
      }
      node.loading = false;
      state.lazyLoadMap.delete(node);
    };
    const close = () => {
      setInnerVisible(false);
      onClose && onClose();
    };
    const closePopup = () => {
      close();
    };
    const chooseItem = async (node, type) => {
      if (!type && node.disabled || !state.panes[state.tabsCursor]) {
        return;
      }
      if (state.tree.isLeaf(node, isLazy())) {
        node.leaf = true;
        state.panes[state.tabsCursor].selectedNode = node;
        state.panes = state.panes.slice(0, node.level + 1);
        if (!type) {
          const pathNodes = state.panes.map((item) => item.selectedNode);
          const optionParams = pathNodes.map((item) => item.value);
          onChange(optionParams, pathNodes);
          onPathChange == null ? void 0 : onPathChange(optionParams, pathNodes);
          setInnerValue(optionParams);
        }
        setOptionsData(state.panes);
        close();
        return;
      }
      if (state.tree.hasChildren(node, isLazy())) {
        const level = node.level + 1;
        state.panes[state.tabsCursor].selectedNode = node;
        state.panes = state.panes.slice(0, level);
        state.tabsCursor = level;
        state.panes.push({
          nodes: node.children || [],
          selectedNode: null,
          paneKey: `c${state.tabsCursor + 1}`
        });
        setOptionsData(state.panes);
        setTabvalue(`c${state.tabsCursor + 1}`);
        if (!type) {
          const pathNodes = state.panes.map((item) => item.selectedNode);
          const optionParams = pathNodes.map((item) => item == null ? void 0 : item.value);
          onPathChange == null ? void 0 : onPathChange(optionParams, pathNodes);
        }
        return;
      }
      state.currentProcessNode = node;
      if (node.loading) {
        return;
      }
      await invokeLazyLoad(node);
      if (state.currentProcessNode === node) {
        state.panes[state.tabsCursor].selectedNode = node;
        chooseItem(node, type);
      }
      setOptionsData(state.panes);
    };
    const renderItem = (pane, node, index) => {
      var _a;
      const classPrefix22 = "nut-cascader-item";
      const checked = ((_a = pane.selectedNode) == null ? void 0 : _a.value) === node.value;
      const classes = classNames(
        {
          active: checked,
          disabled: node.disabled
        },
        classPrefix22
      );
      const classesTitle = classNames({
        [`${classPrefix22}-title`]: true
      });
      const renderIcon = () => {
        if (checked) {
          if (React.isValidElement(activeIcon)) {
            return activeIcon;
          }
          return /* @__PURE__ */ React.createElement(
            i$4,
            {
              className: `${checked ? `${classPrefix2}-icon-check` : ""}`
            }
          );
        }
        return null;
      };
      return /* @__PURE__ */ React.createElement(
        "div",
        {
          style: { color: checked ? activeColor : "" },
          className: classes,
          key: index,
          onClick: () => {
            chooseItem(node, false);
          }
        },
        /* @__PURE__ */ React.createElement("div", { className: classesTitle }, node.text),
        node.loading ? /* @__PURE__ */ React.createElement(n$4, { color: "#969799", className: "nut-cascader-item-icon-loading" }) : renderIcon()
      );
    };
    const renderTabs = () => {
      return /* @__PURE__ */ React.createElement("div", { className: `${classPrefix2} ${className}`, style }, /* @__PURE__ */ React.createElement(
        Tabs,
        {
          value: tabvalue,
          title: () => {
            return optionsData.map((pane, index) => {
              var _a, _b;
              return /* @__PURE__ */ React.createElement(
                "div",
                {
                  onClick: () => {
                    setTabvalue(pane.paneKey);
                    state.tabsCursor = index;
                  },
                  className: `nut-tabs-titles-item ${tabvalue === pane.paneKey ? "nut-tabs-titles-item-active" : ""}`,
                  key: pane.paneKey
                },
                /* @__PURE__ */ React.createElement("span", { className: "nut-tabs-titles-item-text" }, !state.initLoading && state.panes.length && ((_a = pane == null ? void 0 : pane.selectedNode) == null ? void 0 : _a.text), !state.initLoading && state.panes.length && !((_b = pane == null ? void 0 : pane.selectedNode) == null ? void 0 : _b.text) && `${locale.select}`, !(!state.initLoading && state.panes.length) && "Loading..."),
                /* @__PURE__ */ React.createElement("span", { className: "nut-tabs-titles-item-line" })
              );
            });
          }
        },
        !state.initLoading && state.panes.length ? optionsData.map((pane) => {
          var _a;
          return /* @__PURE__ */ React.createElement(Tabs.TabPane, { key: pane.paneKey, value: pane.paneKey }, /* @__PURE__ */ React.createElement("div", { className: classesPane }, (_a = pane.nodes) == null ? void 0 : _a.map(
            (node, index) => renderItem(pane, node, index)
          )));
        }) : /* @__PURE__ */ React.createElement(Tabs.TabPane, null, /* @__PURE__ */ React.createElement("div", { className: classesPane }))
      ));
    };
    return /* @__PURE__ */ React.createElement(React.Fragment, null, popup ? /* @__PURE__ */ React.createElement(
      Popup,
      {
        ...popupProps,
        visible: innerVisible,
        position: "bottom",
        round: true,
        closeIcon,
        closeable,
        closeIconPosition,
        title: popup && title,
        left,
        onOverlayClick: closePopup,
        onCloseIconClick: closePopup
      },
      renderTabs()
    ) : renderTabs());
  };
  const Cascader = React.forwardRef(InternalCascader);
  Cascader.displayName = "NutCascader";
  const defaultProps$16 = {
    ...ComponentDefaults,
    visible: false,
    type: "custom",
    options: [],
    optionKey: { textKey: "text", valueKey: "value", childrenKey: "children" },
    format: {},
    height: "200px"
  };
  const CustomRender = (props) => {
    const {
      children,
      visible,
      type,
      height,
      options: options2,
      title,
      left,
      value,
      defaultValue,
      optionKey,
      format: format2,
      onClose,
      onChange,
      onPathChange,
      ...rest
    } = {
      ...defaultProps$16,
      ...props
    };
    return /* @__PURE__ */ React.createElement(React.Fragment, null, type === "custom" && /* @__PURE__ */ React.createElement(
      Cascader,
      {
        visible,
        value,
        defaultValue,
        title,
        left,
        options: options2,
        format: format2,
        optionKey,
        onClose: () => {
          onClose == null ? void 0 : onClose();
        },
        onChange: (val, params) => {
          onChange == null ? void 0 : onChange(val, params);
        },
        onPathChange,
        ...rest
      }
    ));
  };
  const defaultProps$15 = {
    type: "custom",
    existList: [],
    defaultIcon: null,
    selectIcon: null,
    custom: false
  };
  const ExistRender = (props) => {
    const { locale } = useConfig();
    const {
      children,
      type,
      existList,
      selectIcon,
      defaultIcon,
      custom,
      onSelect,
      onSwitch,
      ...rest
    } = { ...defaultProps$15, ...props };
    const classPrefix2 = "nut-address";
    const selectedExist = (item) => {
      existList.forEach((list, index) => {
        list.selectedAddress = false;
      });
      item.selectedAddress = true;
      onSelect && onSelect(item);
    };
    const onClick = (e) => {
      e.stopPropagation();
      onSwitch && onSwitch({ type: type === "exist" ? "custom" : "exist" });
    };
    return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement("ul", { className: `${classPrefix2}-exist` }, existList.map((item, index) => {
      return /* @__PURE__ */ React.createElement(
        "li",
        {
          className: `${classPrefix2}-exist-item ${item.selectedAddress ? "active" : ""}`,
          key: index,
          onClick: (e) => {
            e.stopPropagation();
            selectedExist(item);
          }
        },
        item.selectedAddress ? /* @__PURE__ */ React.createElement(React.Fragment, null, React.isValidElement(selectIcon) ? selectIcon : /* @__PURE__ */ React.createElement(i$5, { color: "var(--nutui-color-primary)" })) : /* @__PURE__ */ React.createElement(React.Fragment, null, React.isValidElement(defaultIcon) ? defaultIcon : /* @__PURE__ */ React.createElement(n$2, null)),
        /* @__PURE__ */ React.createElement("div", { className: `${classPrefix2}-exist-item-info` }, item.name && item.phone && /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement("div", null, item.name), /* @__PURE__ */ React.createElement("div", null, item.phone)), /* @__PURE__ */ React.createElement("div", null, item.provinceName + item.cityName + item.countyName + item.townName + item.addressDetail))
      );
    })), (custom || custom && locale.address.chooseAnotherAddress) && /* @__PURE__ */ React.createElement("div", { className: `${classPrefix2}-footer`, onClick }, /* @__PURE__ */ React.createElement("div", { className: `${classPrefix2}-footer-btn` }, custom)));
  };
  const defaultProps$14 = {
    ...ComponentDefaults,
    defaultValue: [],
    type: "custom",
    options: [],
    optionKey: { textKey: "text", valueKey: "value", childrenKey: "children" },
    format: {},
    custom: false,
    existList: [],
    height: "200px",
    defaultIcon: null,
    selectIcon: null,
    closeIcon: null,
    backIcon: null
  };
  const InternalAddress = (props, ref) => {
    const { locale } = useConfig();
    const {
      style,
      className,
      visible,
      defaultVisible,
      defaultValue,
      children,
      type,
      options: options2,
      optionKey,
      format: format2,
      height,
      title,
      existList,
      custom,
      selectIcon,
      defaultIcon,
      closeIcon,
      backIcon,
      onChange,
      onExistSelect,
      onClose,
      onSwitch,
      ...rest
    } = {
      ...defaultProps$14,
      ...props
    };
    const classPrefix2 = "nut-address";
    const [currentType, setCurrentType] = React.useState(type);
    const [innerVisible, setInnerVisible] = usePropsValue({
      value: visible,
      defaultValue: defaultVisible,
      finalValue: defaultVisible
    });
    React.useImperativeHandle(ref, () => {
      return {
        open() {
          setInnerVisible(true);
        },
        close() {
          setInnerVisible(false);
        }
      };
    });
    const handleClose = () => {
      setInnerVisible(false);
      onClose && onClose();
    };
    const renderLeftOnCustomSwitch = () => {
      return /* @__PURE__ */ React.createElement(React.Fragment, null, custom && /* @__PURE__ */ React.createElement("div", { className: `${classPrefix2}-left-icon`, onClick: onSwitchModule }, React.isValidElement(backIcon) ? backIcon : /* @__PURE__ */ React.createElement(n$6, { color: "#cccccc" })));
    };
    const selectedExistItem = (data) => {
      onExistSelect && onExistSelect(data);
      handleClose();
    };
    const onSwitchModule = () => {
      if (currentType === "exist") {
        setCurrentType("custom");
      } else {
        setCurrentType("exist");
      }
      onSwitch && onSwitch({ type: currentType });
    };
    return /* @__PURE__ */ React.createElement(React.Fragment, null, currentType === "custom" || currentType === "custom2" ? /* @__PURE__ */ React.createElement(
      CustomRender,
      {
        visible: innerVisible,
        closeable: true,
        title: title || locale.address.selectRegion,
        left: renderLeftOnCustomSwitch(),
        defaultValue,
        closeIcon,
        options: options2,
        format: format2,
        optionKey,
        type: currentType,
        height,
        onClose: handleClose,
        onChange: (val, params) => {
          onChange == null ? void 0 : onChange(val, params);
        }
      }
    ) : /* @__PURE__ */ React.createElement(
      Popup,
      {
        visible: innerVisible,
        position: "bottom",
        round: true,
        closeable: true,
        closeIcon,
        title: title || locale.address.selectRegion,
        onClose: handleClose
      },
      /* @__PURE__ */ React.createElement(
        "div",
        {
          className: `${classPrefix2} ${className || ""}`,
          style: { ...style }
        },
        // 不需要 close，选中切换即关闭弹框。可手动关闭弹框，只关闭弹框不处理逻辑。
        /* @__PURE__ */ React.createElement(
          ExistRender,
          {
            type: currentType,
            existList,
            selectIcon,
            defaultIcon,
            custom,
            onSelect: selectedExistItem,
            onSwitch: onSwitchModule
          }
        )
      )
    ));
  };
  const Address = React.forwardRef(InternalAddress);
  Address.displayName = "NutAddress";
  const isLeapYear = (y) => {
    return y % 4 === 0 && y % 100 !== 0 || y % 400 === 0;
  };
  const getWhatDay = (year, month, day) => {
    const date = new Date(year, month - 1, day);
    const dayNames = [
      "星期日",
      "星期一",
      "星期二",
      "星期三",
      "星期四",
      "星期五",
      "星期六"
    ];
    return dayNames[date.getDay()];
  };
  const getMonthPreDay = (year, month) => {
    const day = new Date(year, month - 1, 1).getDay();
    return day === 0 ? 7 : day;
  };
  const getMonthDays = (year, month) => {
    if (/^0/.test(month)) {
      month = month.split("")[1];
    }
    return [
      0,
      31,
      isLeapYear(Number(year)) ? 29 : 28,
      31,
      30,
      31,
      30,
      31,
      31,
      30,
      31,
      30,
      31
    ][month];
  };
  const getNumTwoBit = (n2) => {
    return n2 > 9 ? `${n2}` : `0${n2}`;
  };
  const date2Str = (date, split = "-") => {
    const y = date.getFullYear();
    const m2 = getNumTwoBit(date.getMonth() + 1);
    const d2 = getNumTwoBit(date.getDate());
    return [y, m2, d2].join(split);
  };
  const getDateString = (offset = 0) => {
    const date = /* @__PURE__ */ new Date();
    date.setDate(date.getDate() + offset);
    return date2Str(date, "-");
  };
  const compareDate = (date1, date22) => {
    const startTime = new Date(date1.replace("-", "/").replace("-", "/"));
    const endTime = new Date(date22.replace("-", "/").replace("-", "/"));
    return startTime < endTime;
  };
  const isEqual = (date1, date22) => {
    const startTime = new Date((date1 || "").replace(/-/g, "/")).getTime();
    const endTime = new Date(date22.replace(/-/g, "/")).getTime();
    return startTime === endTime;
  };
  const getCurrMonthData = (type, year, month) => {
    {
      month === 12 && (year += 1);
      month = month === 12 ? 1 : ++month;
    }
    return [year, getNumTwoBit(month), getMonthDays(String(year), String(month))];
  };
  const getDaysStatus = (type, year, month) => {
    let days = getMonthDays(`${year}`, `${month}`);
    return Array.from(Array(days), (v, k) => {
      return {
        day: k + 1,
        type,
        year,
        month
      };
    });
  };
  const getPreMonthDates = (type, year, month, firstDayOfWeek) => {
    let preMonth = +month - 1;
    let preYear = year;
    if (preMonth <= 0) {
      preMonth = 12;
      preYear += 1;
    }
    let days = getMonthPreDay(+year, +month);
    days -= firstDayOfWeek;
    if (days >= 7) {
      days -= 7;
    }
    const preDates = getMonthDays(`${preYear}`, `${preMonth}`);
    const months = Array.from(Array(preDates), (v, k) => {
      return {
        day: k + 1,
        type,
        preYear,
        preMonth
      };
    });
    return months.slice(preDates - days);
  };
  const getWeekDate = (year, month, date, firstDayOfWeek = 0) => {
    const dateNow = new Date(Number(year), parseInt(month) - 1, Number(date));
    const nowTime = dateNow.getTime();
    let day = dateNow.getDay();
    if (firstDayOfWeek === 0) {
      const oneDayTime2 = 24 * 60 * 60 * 1e3;
      const SundayTime2 = nowTime - day * oneDayTime2;
      const SaturdayTime = nowTime + (6 - day) * oneDayTime2;
      const sunday2 = date2Str(new Date(SundayTime2));
      const saturday = date2Str(new Date(SaturdayTime));
      return [sunday2, saturday];
    }
    day = day === 0 ? 7 : day;
    const oneDayTime = 24 * 60 * 60 * 1e3;
    const MondayTime = nowTime - (day - 1) * oneDayTime;
    const SundayTime = nowTime + (7 - day) * oneDayTime;
    const monday = date2Str(new Date(MondayTime));
    const sunday = date2Str(new Date(SundayTime));
    return [monday, sunday];
  };
  const formatResultDate = (date) => {
    const [year, month, day] = [...date.split("-")];
    const formatterDay = getNumTwoBit(Number(day));
    const formatterDate = `${year}-${month}-${day}`;
    const dayOfWeek = getWhatDay(Number(year), Number(month), Number(day));
    return [year, month, formatterDay, formatterDate, dayOfWeek];
  };
  const getWeekOfYearByYMD = (year, month, date, firstDayOfWeek = 0) => {
    const MILLISECONDS_PER_DAY = 864e5;
    const dateNow = new Date(year, month - 1, date);
    const dateFirst = new Date(year, 0, 1);
    const dayOfYear = Math.round(
      (dateNow.valueOf() - dateFirst.valueOf()) / MILLISECONDS_PER_DAY
    );
    const DAYS_OF_FIRST_WEEK = 3;
    let dayOfWeek = dateNow.getDay();
    let remainder = 6 - dayOfWeek - DAYS_OF_FIRST_WEEK;
    if (firstDayOfWeek !== 0) {
      dayOfWeek = dayOfWeek === 0 ? 7 : dayOfWeek;
      remainder = 7 - dayOfWeek - DAYS_OF_FIRST_WEEK;
    }
    let weekNo = Math.ceil((dayOfYear + remainder + 1) / 7);
    if (weekNo === 0) {
      weekNo = getWeekOfYearByYMD(year - 1, 12, 31, firstDayOfWeek);
    } else if (weekNo === 53) {
      const remainder2 = 7 - dayOfWeek - DAYS_OF_FIRST_WEEK;
      weekNo = remainder2 > 0 ? 1 : weekNo;
    }
    return weekNo;
  };
  const getWeekNosOfYear = (year, month, firstDayOfWeek) => {
    const startWeekNo = getWeekOfYearByYMD(year, month, 1, firstDayOfWeek);
    const endWeekNo = getWeekOfYearByYMD(
      year,
      month,
      getMonthDays(`${year}`, `${month}`),
      firstDayOfWeek
    );
    return Array.from(
      {
        length: (endWeekNo === 1 ? 53 : endWeekNo) - (startWeekNo === 53 || startWeekNo === 52 ? 0 : startWeekNo) + 1
      },
      (_, i2) => {
        const lastIndex = (endWeekNo === 1 ? 53 : endWeekNo) - startWeekNo;
        return `${endWeekNo === 1 && i2 === lastIndex ? 1 : ((startWeekNo === 53 || startWeekNo === 52) && i2 !== 0 ? 0 : startWeekNo) + i2}`;
      }
    );
  };
  const splitDate = (date) => {
    const split = date.indexOf("-") !== -1 ? "-" : "/";
    return date.split(split);
  };
  const isMultiple = (day, days) => {
    if (days.length > 0) {
      return days.some((item) => {
        return isEqual(item, day);
      });
    }
    return false;
  };
  const isCurrDay = (month, day) => {
    const date = `${month.curData[0]}/${month.curData[1]}/${day}`;
    return isEqual(date, date2Str(/* @__PURE__ */ new Date(), "/"));
  };
  const getCurrDate = (day, month) => {
    return `${month.curData[0]}/${month.curData[1]}/${getNumTwoBit(+day.day)}`;
  };
  const isStart = (day, days) => {
    return isEqual(days[0], day);
  };
  const isEnd = (day, days) => {
    return isEqual(days[1], day);
  };
  const isStartAndEnd = (days) => {
    return days.length >= 2 && isEqual(days[0], days[1]);
  };
  const getPreMonths = (type, year, month) => {
    const preMonth = +month - 1;
    const months = Array.from(Array(preMonth), (v, k) => {
      return {
        year,
        month: k + 1,
        yearAndMonth: formatMonth(year, k + 1),
        type
      };
    });
    return months;
  };
  const getMonths = (type, year, month, endMonth = 12) => {
    const nextMonth = endMonth - month + 1;
    const months = Array.from(Array(nextMonth), (v, k) => {
      return {
        year,
        month: k + month,
        yearAndMonth: formatMonth(year, k + month),
        type
      };
    });
    return months;
  };
  const formatMonth = (year, month) => {
    return `${year}-${String(month).padStart(2, "0")}`;
  };
  const formatQuarter = (year, quarter) => {
    return `${year}-Q${quarter}`;
  };
  const getQuarter = (month) => {
    if (month < 1 || month > 12) {
      throw new Error("月份必须在 1 到 12 之间");
    }
    const quarter = Math.floor((month - 1) / 3) + 1;
    return quarter;
  };
  const getQuarters = (type, year, month, endMonth = 12) => {
    const quarters = [];
    const startIndex = month;
    const endIndex = endMonth;
    for (let index = startIndex; index <= endIndex; index += 3) {
      const quarter = getQuarter(index);
      quarters.push({
        year,
        quarter,
        yearAndQuarter: formatQuarter(year, quarter),
        type
      });
    }
    return quarters;
  };
  const getPreQuarters = (type, year, month) => {
    const quarters = [];
    const startIndex = 1;
    const endIndex = month - 3;
    for (let index = startIndex; index <= endIndex; index += 3) {
      const quarter = getQuarter(index);
      quarters.push({
        year,
        quarter,
        yearAndQuarter: formatQuarter(year, quarter),
        type
      });
    }
    return quarters;
  };
  const getNextQuarters = (type, year, month, endMonth = 12) => {
    const quarters = [];
    const startIndex = month + 3;
    const endIndex = endMonth;
    for (let index = startIndex; index <= endIndex; index += 3) {
      const quarter = getQuarter(index);
      quarters.push({
        year,
        quarter,
        yearAndQuarter: formatQuarter(year, quarter),
        type
      });
    }
    return quarters;
  };
  const defaultProps$13 = {
    ...ComponentDefaults,
    type: "single",
    autoBackfill: false,
    popup: true,
    title: "",
    startDate: getDateString(0),
    endDate: getDateString(365),
    showToday: true,
    startText: "",
    endText: "",
    confirmText: "",
    showTitle: true,
    showSubTitle: true,
    showMonthNumber: false,
    scrollAnimation: true,
    firstDayOfWeek: 0,
    disableDate: (date) => false,
    renderHeaderButtons: void 0,
    renderDay: void 0,
    renderDayTop: void 0,
    renderDayBottom: void 0,
    onConfirm: (data) => {
    },
    onUpdate: () => {
    },
    onDayClick: (data) => {
    },
    onPageChange: (data) => {
    }
  };
  const CalendarItem = React.forwardRef((props, ref) => {
    const { locale } = useConfig();
    const {
      style,
      className,
      children,
      popup,
      type,
      autoBackfill,
      title,
      value,
      defaultValue,
      startDate,
      endDate,
      showToday,
      startText,
      endText,
      confirmText,
      showTitle,
      showSubTitle,
      showMonthNumber,
      scrollAnimation,
      firstDayOfWeek,
      disableDate,
      renderHeaderButtons,
      renderBottomButton,
      renderDay,
      renderDayTop,
      renderDayBottom,
      onConfirm,
      onUpdate,
      onDayClick,
      onPageChange
    } = { ...defaultProps$13, ...props };
    const classPrefix2 = "nut-calendar";
    const dayPrefix = "nut-calendar-day";
    const weekdays = locale.calendaritem.weekdays;
    const weeks = [
      ...weekdays.slice(firstDayOfWeek, 7),
      ...weekdays.slice(0, firstDayOfWeek)
    ];
    const monthTitle = locale.calendaritem.monthTitle;
    const [yearMonthTitle, setYearMonthTitle] = React.useState("");
    const [monthsData, setMonthsData] = React.useState([]);
    const [monthsNum, setMonthsNum] = React.useState(0);
    const [translateY, setTranslateY] = React.useState(0);
    const [monthDefaultRange, setMonthDefaultRange] = React.useState([]);
    const propStartDate = startDate || getDateString(0);
    const propEndDate = endDate || getDateString(365);
    const startDates = splitDate(propStartDate);
    const endDates = splitDate(propEndDate);
    const [state] = React.useState({
      currDateArray: []
    });
    const resetDefaultValue = () => {
      if (defaultValue || Array.isArray(defaultValue) && defaultValue.length > 0) {
        return type !== "single" ? [...defaultValue] : defaultValue;
      }
      return type === "single" ? "" : [];
    };
    const [currentDate, setCurrentDate] = usePropsValue({
      value,
      defaultValue: resetDefaultValue(),
      finalValue: [],
      onChange: (val) => {
      }
    });
    const weeksPanel = React.useRef(null);
    const monthsRef = React.useRef(null);
    const monthsPanel = React.useRef(null);
    const viewAreaRef = React.useRef(null);
    const [avgHeight, setAvgHeight] = React.useState(0);
    let viewHeight = 0;
    const getMonthData = (curData, monthNum) => {
      let i2 = 0;
      let date = curData;
      const monthData = monthsData;
      do {
        const y = parseInt(date[0], 10);
        const m2 = parseInt(date[1], 10);
        const days = [
          ...getPreMonthDates("prev", y, m2, firstDayOfWeek),
          ...getDaysStatus("active", y, m2)
        ];
        let scrollTop = 0;
        if (monthData.length > 0) {
          const monthEle = monthData[monthData.length - 1];
          scrollTop = monthEle.scrollTop + monthEle.cssHeight;
        }
        const cssHeight = 39 + (days.length > 35 ? 384 : 320);
        const monthInfo = {
          curData: date,
          title: monthTitle(y, m2),
          weekNo: getWeekNosOfYear(y, m2, firstDayOfWeek),
          monthData: days,
          cssHeight,
          scrollTop
        };
        if (!endDates || !compareDate(
          `${endDates[0]}/${endDates[1]}/${getMonthDays(
            endDates[0],
            endDates[1]
          )}`,
          `${curData[0]}/${curData[1]}/${curData[2]}`
        )) {
          monthData.push(monthInfo);
        }
        date = getCurrMonthData("next", y, m2);
      } while (i2++ < monthNum);
      setMonthsData(monthData);
    };
    const setReachedYearMonthInfo = (current) => {
      const currentMonthsData = monthsData[current];
      if (currentMonthsData.title === yearMonthTitle) return;
      const [year, month] = currentMonthsData.curData;
      onPageChange == null ? void 0 : onPageChange([year, month, `${year}-${month}`]);
      setYearMonthTitle(currentMonthsData.title);
    };
    const setDefaultRange = (monthNum, current) => {
      let start2 = 0;
      let end = 0;
      if (monthNum >= 3) {
        if (current > 0 && current < monthNum) {
          start2 = current - 1;
          end = current + 3;
        } else if (current === 0) {
          start2 = current;
          end = current + 4;
        } else if (current === monthNum) {
          start2 = current - 2;
          end = current + 2;
        }
      } else {
        start2 = 0;
        end = monthNum + 2;
      }
      setMonthDefaultRange([start2, end]);
      setTranslateY(monthsData[start2].scrollTop);
      setReachedYearMonthInfo(current);
    };
    const setDefaultDate = () => {
      let defaultData = [];
      if (type === "single" && typeof currentDate === "string") {
        if (!currentDate.length) {
          return defaultData;
        }
        if (compareDate(currentDate, propStartDate)) {
          defaultData = [...splitDate(propStartDate)];
        } else if (!compareDate(currentDate, propEndDate)) {
          defaultData = [...splitDate(propEndDate)];
        } else {
          defaultData = [...splitDate(currentDate)];
        }
        return defaultData;
      }
      if (Array.isArray(currentDate) && currentDate.length) {
        if (type === "range") {
          if (compareDate(currentDate[0], propStartDate)) {
            currentDate[0] = propStartDate;
          }
          if (compareDate(propEndDate, currentDate[1])) {
            currentDate[1] = propEndDate;
          }
          defaultData = [
            ...splitDate(currentDate[0]),
            ...splitDate(currentDate[1])
          ];
        } else if (type === "multiple") {
          const defaultArr = [];
          const obj = {};
          currentDate.forEach((item) => {
            if (!compareDate(item, propStartDate) && !compareDate(propEndDate, item)) {
              if (!Object.hasOwnProperty.call(obj, item)) {
                defaultArr.push(item);
                obj[item] = item;
              }
            }
          });
          currentDate.splice(0, currentDate.length, ...defaultArr);
          defaultData = [...splitDate(defaultArr[0])];
        } else if (type === "week") {
          const [y, m2, d2] = splitDate(currentDate[0]);
          const weekArr = getWeekDate(y, m2, d2, firstDayOfWeek);
          currentDate.splice(0, currentDate.length, ...weekArr);
          if (compareDate(currentDate[0], propStartDate)) {
            currentDate.splice(0, 1, propStartDate);
          }
          if (compareDate(propEndDate, currentDate[1])) {
            currentDate.splice(1, 1, propEndDate);
          }
          defaultData = [
            ...splitDate(currentDate[0]),
            ...splitDate(currentDate[1])
          ];
        }
      }
      return defaultData;
    };
    const getCurrentIndex = (defaultData) => {
      let current = 0;
      let lastCurrent = 0;
      if (defaultData.length > 0) {
        monthsData.forEach((item, index) => {
          if (item.title === monthTitle(defaultData[0], defaultData[1])) {
            current = index;
          }
          if (type === "range" || type === "week") {
            if (item.title === monthTitle(defaultData[3], defaultData[4])) {
              lastCurrent = index;
            }
          }
        });
      } else {
        const date = /* @__PURE__ */ new Date();
        const year = date.getFullYear();
        const month = date.getMonth() + 1;
        const index = monthsData.findIndex((item) => {
          return +item.curData[0] === year && +item.curData[1] === month;
        });
        if (index > -1) current = index;
      }
      return {
        current,
        lastCurrent
      };
    };
    const renderCurrentDate = (defaultData, current) => {
      if (!defaultData.length) return;
      const date = monthsData[current.current];
      if (type === "range") {
        handleDayClick({ day: defaultData[2], type: "active" }, date);
        handleDayClick(
          { day: defaultData[5], type: "active" },
          monthsData[current.lastCurrent]
        );
      } else if (type === "week") {
        handleDayClick({ day: defaultData[2], type: "curr" }, date);
      } else if (type === "multiple") {
        [...currentDate].forEach((item) => {
          const dateArr = splitDate(item);
          let currentIndex = current.current;
          currentIndex = monthsData.findIndex(
            (item2) => item2.title === monthTitle(dateArr[0], dateArr[1])
          );
          handleDayClick(
            { day: dateArr[2], type: "active" },
            monthsData[currentIndex]
          );
        });
      } else {
        handleDayClick({ day: defaultData[2], type: "active" }, date);
      }
    };
    const getMonthsPanel = () => {
      return monthsPanel.current;
    };
    const getMonthsRef = () => {
      return monthsRef.current;
    };
    const requestAniFrameFunc = (current, monthNum) => {
      const lastItem = monthsData[monthsData.length - 1];
      const containerHeight = lastItem.cssHeight + lastItem.scrollTop;
      requestAniFrame$1(() => {
        if (monthsRef && monthsPanel && viewAreaRef) {
          viewHeight = getMonthsRef().clientHeight;
          getMonthsPanel().style.height = `${containerHeight}px`;
          getMonthsRef().scrollTop = monthsData[current].scrollTop;
        }
      });
      setAvgHeight(Math.floor(containerHeight / (monthNum + 1)));
    };
    const getMonthNum = () => {
      let monthNum = Number(endDates[1]) - Number(startDates[1]);
      const yearNum = Number(endDates[0]) - Number(startDates[0]);
      if (yearNum > 0) monthNum += 12 * yearNum;
      if (monthNum <= 0) monthNum = 1;
      setMonthsNum(monthNum);
      return monthNum;
    };
    const initData = () => {
      const monthNum = getMonthNum();
      getMonthData(startDates, monthNum);
      const defaultData = setDefaultDate();
      const current = getCurrentIndex(defaultData);
      const currentIndex = current.current;
      renderCurrentDate(defaultData, current);
      setDefaultRange(monthNum, currentIndex);
      requestAniFrameFunc(currentIndex, monthNum);
    };
    React.useEffect(() => {
      initData();
    }, []);
    const resetRender = () => {
      state.currDateArray.splice(0);
      monthsData.splice(0);
      initData();
    };
    React.useEffect(() => {
      setCurrentDate(resetDefaultValue());
    }, [defaultValue]);
    React.useEffect(() => {
      popup && resetRender();
    }, [currentDate]);
    const scrollToDate = (date) => {
      if (compareDate(date, propStartDate)) {
        date = propStartDate;
      } else if (!compareDate(date, propEndDate)) {
        date = propEndDate;
      }
      const dateArr = splitDate(date);
      monthsData.forEach((item, index) => {
        if (item.title === monthTitle(dateArr[0], dateArr[1])) {
          const currTop = monthsData[index].scrollTop;
          if (monthsRef.current) {
            const distance = currTop - monthsRef.current.scrollTop;
            if (scrollAnimation) {
              let flag = 0;
              const interval = setInterval(() => {
                flag++;
                if (monthsRef.current) {
                  const offset = distance / 10;
                  monthsRef.current.scrollTop += offset;
                }
                if (flag >= 10) {
                  clearInterval(interval);
                  if (monthsRef.current) {
                    monthsRef.current.scrollTop = currTop;
                  }
                }
              }, 40);
            } else {
              monthsRef.current.scrollTop = currTop;
            }
          }
        }
      });
    };
    const monthsViewScroll = (e) => {
      if (monthsData.length <= 1) {
        return;
      }
      const scrollTop = e.target.scrollTop;
      let current = Math.floor(scrollTop / avgHeight);
      if (current < 0) return;
      if (!monthsData[current + 1]) return;
      const nextTop = monthsData[current + 1].scrollTop;
      const nextHeight = monthsData[current + 1].cssHeight;
      if (current === 0) {
        if (scrollTop >= nextTop) current += 1;
      } else if (current > 0 && current < monthsNum - 1) {
        if (scrollTop >= nextTop) current += 1;
        if (scrollTop < monthsData[current].scrollTop) current -= 1;
      } else {
        const viewPosition = Math.round(scrollTop + viewHeight);
        if (current + 1 <= monthsNum && viewPosition >= nextTop + nextHeight) {
          current += 1;
        }
        if (current >= 1 && scrollTop < monthsData[current - 1].scrollTop) {
          current -= 1;
        }
      }
      setDefaultRange(monthsNum, current);
    };
    React.useImperativeHandle(ref, () => ({
      scrollToDate
    }));
    const isDisable = (day, month) => {
      if (day.type !== "active") return true;
      const dateStr = getCurrDate(day, month);
      if (compareDate(dateStr, propStartDate)) return true;
      if (compareDate(propEndDate, dateStr)) return true;
      return false;
    };
    const getClasses = (day, month) => {
      const dateStr = getCurrDate(day, month);
      if (isDisable(day, month)) return `${dayPrefix}-disabled`;
      const activeCls = `${dayPrefix}-active`;
      if (type === "range" || type === "week") {
        if (isStart(dateStr, currentDate))
          return `${activeCls} active-start`;
        if (isEnd(dateStr, currentDate)) {
          return `${activeCls} active-end`;
        }
        if (currentDate.length === 2 && compareDate(currentDate[0], dateStr) && compareDate(dateStr, currentDate[1])) {
          return disableDate(day) ? `${dayPrefix}-choose-disabled` : `${dayPrefix}-choose`;
        }
      } else if (type === "multiple" && isMultiple(dateStr, currentDate) || type === "single" && isEqual(currentDate, dateStr)) {
        return activeCls;
      }
      if (disableDate(day)) return `${dayPrefix}-disabled`;
      return null;
    };
    const handleDayClick = (day, month, isFirst = true) => {
      if (getClasses(day, month) === `${dayPrefix}-disabled`) {
        return;
      }
      const days = [...month.curData];
      const [y, m2] = month.curData;
      days[2] = typeof day.day === "number" ? getNumTwoBit(day.day) : day.day;
      days[3] = `${days[0]}/${days[1]}/${days[2]}`;
      days[4] = getWhatDay(+days[0], +days[1], +days[2]);
      const newDate = days[3];
      if (type === "multiple") {
        if (Array.isArray(currentDate)) {
          if (currentDate.length > 0) {
            const hasIndex = currentDate.findIndex((item) => item === newDate);
            if (isFirst) {
              state.currDateArray.push([...days]);
            } else if (hasIndex > -1) {
              currentDate.splice(hasIndex, 1);
              state.currDateArray.splice(hasIndex, 1);
            } else {
              currentDate.push(newDate);
              state.currDateArray.push([...days]);
            }
          } else {
            currentDate.push(newDate);
            state.currDateArray = [[...days]];
          }
        }
      } else if (type === "range") {
        if (Array.isArray(currentDate)) {
          if (currentDate.length === 2 || currentDate.length === 0) {
            currentDate.splice(0, currentDate.length, newDate);
            state.currDateArray = [[...days]];
          } else if (compareDate(currentDate[0], newDate)) {
            currentDate.push(newDate);
            state.currDateArray = [...state.currDateArray, [...days]];
          } else {
            currentDate.unshift(newDate);
            state.currDateArray = [[...days], ...state.currDateArray];
          }
        }
      } else if (type === "week") {
        const weekArr = getWeekDate(y, m2, `${day.day}`, firstDayOfWeek);
        if (compareDate(weekArr[0], propStartDate)) {
          weekArr[0] = propStartDate;
        }
        if (compareDate(propEndDate, weekArr[1])) {
          weekArr[1] = propEndDate;
        }
        currentDate.splice(0, currentDate.length, ...weekArr);
        state.currDateArray = [
          formatResultDate(weekArr[0]),
          formatResultDate(weekArr[1])
        ];
      } else {
        setCurrentDate(days[3]);
        state.currDateArray = [...days];
      }
      if (!isFirst) {
        onDayClick == null ? void 0 : onDayClick(state.currDateArray);
        if (autoBackfill || !popup) {
          confirm2();
        }
      }
      setMonthsData(monthsData.slice());
    };
    const confirm2 = () => {
      if (type === "range" && state.currDateArray.length === 2 || type !== "range") {
        const chooseData = state.currDateArray.slice(0);
        onConfirm == null ? void 0 : onConfirm(chooseData);
        if (popup) {
          onUpdate == null ? void 0 : onUpdate();
        }
      }
    };
    const classes = classNames(
      classPrefix2,
      {
        [`${classPrefix2}-title`]: !popup,
        [`${classPrefix2}-nofooter`]: !!autoBackfill
      },
      className
    );
    const headerClasses = classNames({
      [`${classPrefix2}-header`]: true,
      [`${classPrefix2}-header-title`]: !popup
    });
    const isStartTip = (day, month) => {
      return (type === "range" || type === "week") && day.type === "active" && isStart(getCurrDate(day, month), currentDate);
    };
    const isEndTip = (day, month) => {
      return currentDate.length >= 2 && (type === "range" || type === "week") && day.type === "active" && isEnd(getCurrDate(day, month), currentDate);
    };
    const renderHeader = () => {
      return /* @__PURE__ */ React.createElement("div", { className: headerClasses }, showTitle && /* @__PURE__ */ React.createElement("div", { className: `${classPrefix2}-title` }, title || locale.calendaritem.title), renderHeaderButtons && /* @__PURE__ */ React.createElement("div", { className: `${classPrefix2}-header-buttons` }, renderHeaderButtons()), showSubTitle && /* @__PURE__ */ React.createElement("div", { className: `${classPrefix2}-sub-title` }, yearMonthTitle), /* @__PURE__ */ React.createElement(
        "div",
        {
          className: `${classPrefix2}-weeks ${showMonthNumber ? `${classPrefix2}-weeks-shrink` : ""}`,
          ref: weeksPanel
        },
        weeks.map((item) => /* @__PURE__ */ React.createElement("div", { className: `${classPrefix2}-week-item`, key: item }, item))
      ));
    };
    const renderItem = (month, day, index) => {
      const startTip = isStartTip(day, month);
      const endTip = isEndTip(day, month);
      const noStartNorEnd = !startTip && !endTip;
      return /* @__PURE__ */ React.createElement(
        "div",
        {
          className: classNames("nut-calendar-day", getClasses(day, month)),
          onClick: () => handleDayClick(day, month, false),
          key: index
        },
        /* @__PURE__ */ React.createElement("div", { className: `${classPrefix2}-day-day` }, renderDay ? renderDay(day) : day.day),
        !startTip && renderDayTop && /* @__PURE__ */ React.createElement("div", { className: `${classPrefix2}-day-info-top` }, renderDayTop(day)),
        noStartNorEnd && renderDayBottom && /* @__PURE__ */ React.createElement("div", { className: `${classPrefix2}-day-info-bottom` }, renderDayBottom(day)),
        noStartNorEnd && !renderDayBottom && showToday && isCurrDay(month, day.day) && /* @__PURE__ */ React.createElement("div", { className: `${classPrefix2}-day-info-curr` }, locale.calendaritem.today),
        startTip && /* @__PURE__ */ React.createElement(
          "div",
          {
            className: classNames("nut-calendar-day-info", {
              "nut-calendar-day-info-top": isStartAndEnd(
                currentDate
              )
            })
          },
          startText || locale.calendaritem.start
        ),
        endTip && /* @__PURE__ */ React.createElement("div", { className: `${classPrefix2}-day-info` }, endText || locale.calendaritem.end)
      );
    };
    const renderPanel = (month, key) => {
      return /* @__PURE__ */ React.createElement("div", { className: `${classPrefix2}-month`, key }, /* @__PURE__ */ React.createElement("div", { className: `${classPrefix2}-month-title` }, month.title), /* @__PURE__ */ React.createElement("div", { className: `${showMonthNumber ? "shrink" : ""}` }, showMonthNumber && /* @__PURE__ */ React.createElement("div", { className: `${classPrefix2}-weeknumber` }, month.weekNo.map((item, index) => /* @__PURE__ */ React.createElement("div", { className: `${classPrefix2}-weeknumber-index`, key: index }, item))), /* @__PURE__ */ React.createElement("div", { className: `${classPrefix2}-days` }, month.monthData.map(
        (day, i2) => renderItem(month, day, i2)
      ))));
    };
    const renderContent = () => {
      return /* @__PURE__ */ React.createElement(
        "div",
        {
          className: `${classPrefix2}-content`,
          onScroll: monthsViewScroll,
          ref: monthsRef
        },
        /* @__PURE__ */ React.createElement("div", { className: `${classPrefix2}-pannel`, ref: monthsPanel }, /* @__PURE__ */ React.createElement(
          "div",
          {
            ref: viewAreaRef,
            style: { transform: `translateY(${translateY}px)` }
          },
          monthsData.slice(monthDefaultRange[0], monthDefaultRange[1]).map((month, key) => {
            return renderPanel(month, key);
          })
        ))
      );
    };
    const renderFooter = () => {
      return /* @__PURE__ */ React.createElement("div", { className: "nut-calendar-footer" }, children, /* @__PURE__ */ React.createElement("div", { onClick: confirm2 }, renderBottomButton ? renderBottomButton() : /* @__PURE__ */ React.createElement("div", { className: "calendar-confirm-btn" }, confirmText || locale.confirm)));
    };
    return /* @__PURE__ */ React.createElement("div", { className: classes, style }, renderHeader(), renderContent(), popup && !autoBackfill ? renderFooter() : "");
  });
  CalendarItem.displayName = "NutCalendarItem";
  const YearMonthPanelHeight = 231;
  const YearQuarterPanelHeight = 103;
  const defaultProps$12 = {
    ...ComponentDefaults,
    type: "single",
    viewMode: "month",
    title: "",
    startDate: getDateString(0),
    endDate: getDateString(365),
    showToday: true,
    showTitle: true,
    scrollAnimation: true,
    renderDay: void 0,
    onItemClick: () => {
    }
  };
  const CalendarViewModeItem = React.forwardRef((props) => {
    const { locale } = useConfig();
    const {
      style,
      className,
      viewMode,
      title,
      value,
      defaultValue,
      startDate,
      endDate,
      showTitle,
      renderDay,
      onItemClick
    } = { ...defaultProps$12, ...props };
    const classPrefix2 = "nut-calendar-viewmode";
    const [panelDate, setPanelDate] = React.useState({
      months: [
        {
          year: (/* @__PURE__ */ new Date()).getFullYear(),
          months: [],
          cssHeight: 0,
          scrollTop: 0,
          currYear: false
        }
      ],
      quarters: [
        {
          year: (/* @__PURE__ */ new Date()).getFullYear(),
          quarters: [],
          cssHeight: 0,
          scrollTop: 0,
          currYear: false
        }
      ]
    });
    const propStartDate = startDate || getDateString(0);
    const propEndDate = endDate || getDateString(365);
    const startDates = splitDate(propStartDate);
    const endDates = splitDate(propEndDate);
    const [innerValue, setInnerValue] = usePropsValue({
      value,
      defaultValue,
      finalValue: [],
      onChange: (val) => {
      }
    });
    const monthsRef = React.useRef(null);
    const monthsPanel = React.useRef(null);
    const viewAreaRef = React.useRef(null);
    const getMonthsPanel = () => {
      return monthsPanel.current;
    };
    const getMonthsRef = () => {
      return monthsRef.current;
    };
    const requestAniFrameFunc = (viewMode2) => {
      switch (viewMode2) {
        case "month":
          {
            const lastItem = panelDate.months[panelDate.months.length - 1];
            const containerHeight = lastItem.cssHeight + lastItem.scrollTop;
            const currentIndex = panelDate.months.findIndex(
              (item) => item.currYear === true
            );
            requestAniFrame$1(() => {
              if (monthsRef && monthsPanel && viewAreaRef) {
                getMonthsRef().clientHeight;
                getMonthsPanel().style.height = `${containerHeight}px`;
                getMonthsRef().scrollTop = panelDate.months[currentIndex].scrollTop;
              }
            });
          }
          break;
        case "quarter":
          {
            const lastItem = panelDate.quarters[panelDate.quarters.length - 1];
            const containerHeight = lastItem.cssHeight + lastItem.scrollTop;
            const currentIndex = panelDate.quarters.findIndex(
              (item) => item.currYear === true
            );
            requestAniFrame$1(() => {
              if (monthsRef && monthsPanel && viewAreaRef) {
                getMonthsRef().clientHeight;
                getMonthsPanel().style.height = `${containerHeight}px`;
                getMonthsRef().scrollTop = panelDate.quarters[currentIndex].scrollTop;
              }
            });
          }
          break;
      }
    };
    const isCurrYear = (year) => {
      return innerValue.split("-")[0] === `${year}`;
    };
    const getMonthsData = () => {
      const startYear = Number(startDates[0]);
      const startMonth = Number(startDates[1]);
      const endYear = Number(endDates[0]);
      const endMonth = Number(endDates[1]);
      const panelData = [];
      const addPanelData = (year, months, scrollTop) => {
        panelData.push({
          year,
          months,
          scrollTop,
          cssHeight: YearMonthPanelHeight,
          currYear: isCurrYear(year)
        });
      };
      if (startYear === endYear) {
        addPanelData(
          startYear,
          [
            ...getPreMonths("prev", startYear, startMonth),
            ...getMonths("curr", startYear, startMonth, endMonth),
            ...getMonths("next", endYear, endMonth + 1)
          ],
          0
        );
      } else {
        let scrollTop = panelData.length * YearMonthPanelHeight;
        const startMonths = [
          ...getPreMonths("prev", startYear, startMonth),
          ...getMonths("curr", startYear, startMonth)
        ];
        addPanelData(startYear, startMonths, scrollTop);
        for (let i2 = startYear + 1; i2 < endYear; i2++) {
          scrollTop = panelData.length * YearMonthPanelHeight;
          const midMonths = [...getMonths("curr", i2, 1)];
          addPanelData(i2, midMonths, scrollTop);
        }
        const lastMonths = [
          ...getPreMonths("curr", endYear, endMonth + 1),
          ...getMonths("next", endYear, endMonth + 1)
        ];
        scrollTop = panelData.length * YearMonthPanelHeight;
        addPanelData(endYear, lastMonths, scrollTop);
      }
      return panelData;
    };
    const getQuartersData = () => {
      const startYear = Number(startDates[0]);
      const startMonth = Number(startDates[1]);
      const endYear = Number(endDates[0]);
      const endMonth = Number(endDates[1]);
      const panelData = [];
      const addPanelData = (year, quarters, scrollTop) => {
        panelData.push({
          year,
          quarters,
          scrollTop,
          cssHeight: YearQuarterPanelHeight,
          currYear: isCurrYear(year)
        });
      };
      if (startYear === endYear) {
        const quarters = [
          ...getPreQuarters("prev", startYear, startMonth),
          ...getQuarters("curr", startYear, startMonth, endMonth),
          ...getNextQuarters("next", endYear, endMonth)
        ];
        addPanelData(startYear, quarters, 0);
      } else {
        let scrollTop = panelData.length * YearQuarterPanelHeight;
        const startQuarters = [
          ...getPreQuarters("prev", startYear, startMonth),
          ...getQuarters("curr", startYear, startMonth)
        ];
        addPanelData(startYear, startQuarters, scrollTop);
        for (let i2 = startYear + 1; i2 < endYear; i2++) {
          scrollTop = panelData.length * YearQuarterPanelHeight;
          const midQuarters = [...getQuarters("curr", i2, 1)];
          addPanelData(i2, midQuarters, scrollTop);
        }
        const lastQuarters = [
          ...getQuarters("curr", endYear, 1, endMonth),
          ...getNextQuarters("next", endYear, endMonth)
        ];
        scrollTop = panelData.length * YearQuarterPanelHeight;
        addPanelData(endYear, lastQuarters, scrollTop);
      }
      return panelData;
    };
    const initData = () => {
      const data = (
        // eslint-disable-next-line no-nested-ternary
        viewMode === "month" ? getMonthsData() : viewMode === "quarter" ? getQuartersData() : null
      );
      setPanelDate({ ...panelDate, [`${viewMode}s`]: data });
    };
    React.useEffect(() => {
      requestAniFrameFunc(viewMode);
    }, [panelDate]);
    React.useEffect(() => {
      initData();
    }, []);
    const handleItemClick = (item) => {
      if (item.type !== "curr") return;
      const val = viewMode === "month" ? item.yearAndMonth : item.yearAndQuarter;
      setInnerValue(val);
      onItemClick == null ? void 0 : onItemClick(val);
    };
    const isDisable = (item) => {
      return item.type === "prev" || item.type === "next";
    };
    const isActive = (item) => {
      const val = viewMode === "month" ? item.yearAndMonth : item.yearAndQuarter;
      return val === innerValue;
    };
    const getClasses = (item) => {
      if (isDisable(item)) {
        return ["disabled"];
      }
      const res = [];
      if (item.type === "curr") {
        if (isActive(item)) {
          res.push("active");
        }
      }
      return res;
    };
    const classes = classNames(classPrefix2, className);
    const renderHeader = () => {
      return showTitle && /* @__PURE__ */ React.createElement(
        "div",
        {
          className: classNames({
            [`${classPrefix2}-header`]: true
          })
        },
        /* @__PURE__ */ React.createElement("div", { className: `${classPrefix2}-title` }, title)
      );
    };
    const renderItem = (item, index) => {
      const units = {
        month: locale.calendaritem.month,
        quarter: locale.calendaritem.quarter
      };
      return /* @__PURE__ */ React.createElement(
        "div",
        {
          className: classNames(
            `${classPrefix2}-item`,
            item.type,
            getClasses(item)
          ),
          onClick: () => handleItemClick(item),
          key: index
        },
        /* @__PURE__ */ React.createElement("div", { className: `${classPrefix2}-item-${item.type}` }, renderDay ? renderDay(item) : `${item[viewMode]}${units[viewMode]}`)
      );
    };
    const renderPanel = () => {
      return /* @__PURE__ */ React.createElement(React.Fragment, null, panelDate[`${viewMode}s`].map((item, key) => /* @__PURE__ */ React.createElement("div", { className: `${classPrefix2}-panel`, key }, /* @__PURE__ */ React.createElement("div", { className: `${classPrefix2}-panel-title` }, item.year), /* @__PURE__ */ React.createElement("div", { className: `${classPrefix2}-content` }, item[`${viewMode}s`].map(
        (item2, i2) => renderItem(item2, i2)
      )))));
    };
    const renderContent = () => {
      return /* @__PURE__ */ React.createElement("div", { className: `${classPrefix2}-content`, ref: monthsRef }, /* @__PURE__ */ React.createElement("div", { className: `${classPrefix2}-pannel`, ref: monthsPanel }, /* @__PURE__ */ React.createElement("div", { ref: viewAreaRef }, renderPanel())));
    };
    return /* @__PURE__ */ React.createElement("div", { className: classes, style }, renderHeader(), renderContent());
  });
  CalendarViewModeItem.displayName = "NutCalendarViewModeItem";
  const defaultProps$11 = {
    ...ComponentDefaults,
    type: "single",
    viewMode: "day",
    autoBackfill: false,
    popup: true,
    visible: false,
    title: "",
    value: "",
    defaultValue: "",
    startDate: getDateString(0),
    endDate: getDateString(365),
    showToday: true,
    startText: "",
    endText: "",
    confirmText: "",
    showTitle: true,
    showSubTitle: true,
    showMonthNumber: false,
    scrollAnimation: true,
    firstDayOfWeek: 0,
    disableDate: (date) => false,
    renderHeaderButtons: void 0,
    renderDay: void 0,
    renderDayTop: void 0,
    renderDayBottom: void 0,
    onClose: () => {
    },
    onConfirm: (param) => {
    },
    onDayClick: (data) => {
    },
    onItemClick: () => {
    },
    onPageChange: (param) => {
    }
  };
  const Calendar = React.forwardRef((props, ref) => {
    const { locale } = useConfig();
    const {
      style,
      className,
      children,
      popup,
      visible,
      type,
      viewMode,
      autoBackfill,
      title,
      value,
      defaultValue,
      startDate,
      endDate,
      showToday,
      startText,
      endText,
      confirmText,
      showTitle,
      showSubTitle,
      showMonthNumber,
      scrollAnimation,
      firstDayOfWeek,
      closeIcon,
      disableDate,
      renderHeaderButtons,
      renderBottomButton,
      renderDay,
      renderDayTop,
      renderDayBottom,
      onClose,
      onConfirm,
      onDayClick,
      onItemClick,
      onPageChange
    } = { ...defaultProps$11, ...props };
    const calendarRef = React.useRef(null);
    const close = () => {
      onClose && onClose();
    };
    const choose = (param) => {
      close();
      onConfirm && onConfirm(param);
    };
    const closePopup = () => {
      close();
    };
    const scrollToDate = (date) => {
      var _a;
      (_a = calendarRef.current) == null ? void 0 : _a.scrollToDate(date);
    };
    const yearMonthChange = (param) => {
      onPageChange && onPageChange(param);
    };
    React.useImperativeHandle(ref, () => ({
      scrollToDate
    }));
    const renderItem = () => {
      return /* @__PURE__ */ React.createElement(React.Fragment, null, viewMode !== "day" ? /* @__PURE__ */ React.createElement(
        CalendarViewModeItem,
        {
          ref: calendarRef,
          style,
          className,
          type,
          viewMode,
          title: title || locale.calendaritem.title,
          value,
          defaultValue,
          startDate,
          endDate,
          showTitle,
          scrollAnimation,
          renderDay,
          onItemClick
        }
      ) : /* @__PURE__ */ React.createElement(
        CalendarItem,
        {
          ref: calendarRef,
          style,
          className,
          children,
          type,
          autoBackfill,
          renderBottomButton,
          popup,
          title: title || locale.calendaritem.title,
          defaultValue,
          startDate,
          endDate,
          showToday,
          startText: startText || locale.calendaritem.start,
          endText: endText || locale.calendaritem.end,
          confirmText: confirmText || locale.calendaritem.confirm,
          showTitle,
          showSubTitle,
          showMonthNumber,
          scrollAnimation,
          firstDayOfWeek,
          disableDate,
          renderHeaderButtons,
          renderDay,
          renderDayTop,
          renderDayBottom,
          onConfirm: choose,
          onDayClick: (param) => onDayClick && onDayClick(param),
          onPageChange: yearMonthChange
        }
      ));
    };
    return /* @__PURE__ */ React.createElement(React.Fragment, null, popup && viewMode === "day" ? /* @__PURE__ */ React.createElement(
      Popup,
      {
        className: "nut-calendar-popup",
        visible,
        position: "bottom",
        round: true,
        closeable: true,
        closeIcon,
        destroyOnClose: true,
        onOverlayClick: closePopup,
        onCloseIconClick: closePopup,
        style: { height: "83%" }
      },
      renderItem()
    ) : renderItem());
  });
  Calendar.displayName = "NutCalendar";
  const ArrowLeft = () => {
    return /* @__PURE__ */ React.createElement(
      "svg",
      {
        xmlns: "http://www.w3.org/2000/svg",
        width: "18",
        height: "18",
        viewBox: "0 0 18 18"
      },
      /* @__PURE__ */ React.createElement("path", { d: "M6.605 9.49a.771.771 0 0 1 0-.98l3.6-4.372a.771.771 0 0 1 1.19.981L8.2 9l3.197 3.881a.771.771 0 1 1-1.191.98l-3.6-4.37Z" })
    );
  };
  const ArrowRight = () => {
    return /* @__PURE__ */ React.createElement(
      "svg",
      {
        xmlns: "http://www.w3.org/2000/svg",
        width: "18",
        height: "18",
        viewBox: "0 0 18 18"
      },
      /* @__PURE__ */ React.createElement("path", { d: "M11.396 9.49a.771.771 0 0 0 0-.98l-3.6-4.372a.771.771 0 0 0-1.191.981L9.8 9l-3.196 3.881a.771.771 0 0 0 1.19.98l3.6-4.37Z" })
    );
  };
  const DoubleLeft = () => {
    return /* @__PURE__ */ React.createElement(
      "svg",
      {
        xmlns: "http://www.w3.org/2000/svg",
        width: "18",
        height: "18",
        viewBox: "0 0 18 18"
      },
      /* @__PURE__ */ React.createElement("path", { d: "M13.853 4.026a.771.771 0 0 1 .12 1.085L10.864 9l3.11 3.889a.771.771 0 1 1-1.204.963L9.272 9.482a.771.771 0 0 1 0-.964l3.497-4.371a.771.771 0 0 1 1.084-.12Zm-5.245 0a.771.771 0 0 1 .12 1.085L5.617 9l3.111 3.889a.771.771 0 0 1-1.205.963L4.026 9.482a.771.771 0 0 1 0-.964l3.497-4.371a.771.771 0 0 1 1.085-.12Z" })
    );
  };
  const DoubleRight = () => {
    return /* @__PURE__ */ React.createElement(
      "svg",
      {
        xmlns: "http://www.w3.org/2000/svg",
        width: "18",
        height: "18",
        viewBox: "0 0 18 18"
      },
      /* @__PURE__ */ React.createElement("path", { d: "M4.147 13.974a.771.771 0 0 1-.12-1.085L7.136 9 4.028 5.11a.771.771 0 1 1 1.204-.963l3.497 4.371a.771.771 0 0 1 0 .964l-3.497 4.371a.771.771 0 0 1-1.084.12Zm5.245 0a.771.771 0 0 1-.12-1.085L12.383 9 9.272 5.11a.771.771 0 1 1 1.205-.963l3.497 4.371a.771.771 0 0 1 0 .964l-3.497 4.371a.771.771 0 0 1-1.085.12Z" })
    );
  };
  const convertDateToDay = (date) => {
    return date ? {
      year: date.getFullYear(),
      month: date.getMonth() + 1,
      date: date.getDate()
    } : null;
  };
  const convertDayToDate = (day) => {
    return day ? new Date(day.year, day.month - 1, day.date) : null;
  };
  const getPrevMonthDays = (year, month, firstDayOfWeek) => {
    let prevMonth = month - 1;
    let prevYear = year;
    if (prevMonth <= 0) {
      prevMonth = 12;
      prevYear -= 1;
    }
    let days = getMonthPreDay(year, month);
    days -= firstDayOfWeek;
    if (days >= 7) {
      days -= 7;
    }
    const preDates = getMonthDays(`${prevYear}`, `${prevMonth}`);
    const months = Array.from(Array(preDates), (_, k) => {
      return {
        type: "prev",
        year: prevYear,
        month: prevMonth,
        date: k + 1
      };
    });
    return months.slice(preDates - days);
  };
  const getCurrentMonthDays = (year, month) => {
    const days = getMonthDays(`${year}`, `${month}`);
    return Array.from(Array(days), (_, k) => {
      return {
        type: "current",
        year,
        month,
        date: k + 1
      };
    });
  };
  const getCurrentWeekDays = (day, firstDayOfWeek) => {
    const current = new Date(day.year, day.month - 1, day.date);
    const count = (current.getDay() + 7 - firstDayOfWeek) % 7;
    return [
      convertDateToDay(
        new Date(current.getTime() - 24 * 60 * 60 * 1e3 * count)
      ),
      convertDateToDay(
        new Date(current.getTime() + 24 * 60 * 60 * 1e3 * (6 - count))
      )
    ];
  };
  const defaultProps$10 = {
    ...ComponentDefaults,
    type: "single",
    firstDayOfWeek: 0
  };
  const prefixCls = "nut-calendarcard";
  const CalendarCard = React.forwardRef((props, ref) => {
    const { locale } = useConfig();
    const {
      style,
      className,
      type,
      value,
      defaultValue,
      firstDayOfWeek,
      startDate,
      endDate,
      disableDay,
      renderDay,
      renderDayTop,
      renderDayBottom,
      onDayClick,
      onPageChange,
      onChange
    } = { ...defaultProps$10, ...props };
    const [month, setMonth] = React.useState(() => {
      let date = new Date(Date.now());
      const val = value || defaultValue;
      if (Array.isArray(val)) {
        if (val.length) {
          date = val[0];
        }
      } else if (val) {
        date = val;
      }
      return {
        year: date.getFullYear(),
        month: date.getMonth() + 1
      };
    });
    const [days, setDays] = React.useState([]);
    const valueToRange = (val) => {
      if (Array.isArray(val)) {
        return val.map((date) => {
          return convertDateToDay(date);
        });
      }
      return val ? [convertDateToDay(val)] : [];
    };
    const rangeTovalue = (range2) => {
      if (Array.isArray(range2)) {
        return range2.map((day) => {
          return convertDayToDate(day);
        });
      }
      return range2 ? [convertDayToDate(range2)] : [];
    };
    const [innerValue, setInnerValue] = usePropsValue({
      value: value ? valueToRange(value) : void 0,
      defaultValue: defaultValue ? valueToRange(defaultValue) : void 0,
      finalValue: []
    });
    const change = (v) => {
      setInnerValue(v);
      if (type === "single") {
        const date = convertDayToDate(v[0]);
        onChange == null ? void 0 : onChange(date);
      } else if (type === "multiple" || type === "range" || type === "week") {
        const val = rangeTovalue(v);
        onChange == null ? void 0 : onChange(val);
      }
    };
    const getDays = (month2) => {
      const y = month2.year;
      const m2 = month2.month;
      const days2 = [
        ...getPrevMonthDays(y, m2, firstDayOfWeek),
        ...getCurrentMonthDays(y, m2)
      ];
      const size = days2.length;
      const yearOfNextMonth = month2.month === 12 ? month2.year + 1 : month2.year;
      const monthOfNextMonth = month2.month === 12 ? 1 : month2.month + 1;
      for (let i2 = 1; i2 <= 42 - size; i2++) {
        days2.push({
          type: "next",
          year: yearOfNextMonth,
          month: monthOfNextMonth,
          date: i2
        });
      }
      return days2;
    };
    React.useEffect(() => {
      const newDays = getDays(month);
      setDays(newDays);
      onPageChange == null ? void 0 : onPageChange(month);
    }, [month]);
    const isSameDay = (day1, day2) => {
      return (day1 == null ? void 0 : day1.year) === (day2 == null ? void 0 : day2.year) && (day1 == null ? void 0 : day1.month) === (day2 == null ? void 0 : day2.month) && (day1 == null ? void 0 : day1.date) === (day2 == null ? void 0 : day2.date);
    };
    const compareDay = (day1, day2) => {
      if (day1 && day2) {
        if (day1.year === day2.year) {
          if (day1.month === day2.month) {
            return day1.date - day2.date;
          }
          return day1.month - day2.month;
        }
        return day1.year - day2.year;
      }
    };
    const isDisable = (day) => {
      if (disableDay && disableDay(day)) {
        return true;
      }
      if (startDate && Number(compareDay(day, convertDateToDay(startDate))) < 0) {
        return true;
      }
      if (endDate && Number(compareDay(day, convertDateToDay(endDate))) > 0) {
        return true;
      }
      return false;
    };
    const isActive = (day) => {
      if (type === "single" || type === "multiple") {
        for (const val of innerValue) {
          if (isSameDay(day, val)) {
            return true;
          }
        }
      } else if (type === "range" && innerValue.length === 1 && isSameDay(innerValue[0], day)) {
        return true;
      }
      return false;
    };
    const isStart2 = (day) => {
      return (type === "range" || type === "week") && innerValue.length === 2 && isSameDay(day, innerValue[0]);
    };
    const isEnd2 = (day) => {
      return (type === "range" || type === "week") && innerValue.length === 2 && isSameDay(day, innerValue[1]);
    };
    const isMid = (day) => {
      if (type === "range" || type === "week") {
        if (innerValue.length === 2) {
          const c12 = compareDay(innerValue[0], day);
          const c22 = compareDay(day, innerValue[1]);
          if (c12 && c12 < 0 && c22 && c22 < 0) {
            return true;
          }
        }
      }
      return false;
    };
    const isWeekend = (day) => {
      const d2 = new Date(day.year, day.month - 1, day.date).getDay();
      return d2 === 0 || d2 === 6;
    };
    const getClasses = (day) => {
      if (isDisable(day)) {
        return ["disabled"];
      }
      const res = [];
      if (day.type === "current") {
        if (isActive(day)) {
          res.push("active");
        }
        if (isStart2(day)) {
          res.push("start");
        }
        if (isEnd2(day)) {
          res.push("end");
        }
        if (isMid(day)) {
          res.push("mid");
        }
        if (isWeekend(day)) {
          res.push("weekend");
        }
      }
      return res;
    };
    const jumpTo = (year, month2) => {
      if (startDate) {
        const c6 = compareDay(
          {
            year,
            month: month2,
            date: 31
          },
          convertDateToDay(startDate)
        );
        if (c6 && c6 < 0) {
          return;
        }
      }
      if (endDate) {
        const c6 = compareDay(
          {
            year,
            month: month2,
            date: 1
          },
          convertDateToDay(endDate)
        );
        if (c6 && c6 > 0) {
          return;
        }
      }
      setMonth({ year, month: month2 });
    };
    const jump = (step = 1) => {
      const current = month.year * 12 + month.month;
      let newMonth = (current + step) % 12;
      if (newMonth === 0) {
        newMonth = 12;
      }
      const newYear = Math.floor((current + step - newMonth) / 12);
      jumpTo(newYear, newMonth);
    };
    React.useImperativeHandle(ref, () => {
      return {
        jump,
        jumpTo
      };
    });
    const handleDayClick = (day) => {
      onDayClick == null ? void 0 : onDayClick(day);
      if (day.type === "prev" || day.type === "next" || isDisable(day)) {
        return;
      }
      switch (type) {
        case "single": {
          if (innerValue[0] && isSameDay(innerValue[0], day)) {
            change([]);
          } else {
            change([day]);
          }
          break;
        }
        case "multiple": {
          const t = innerValue.find((i2) => isSameDay(i2, day));
          if (t) {
            change(innerValue.filter((i2) => i2 !== t));
          } else {
            change([...innerValue, day]);
          }
          break;
        }
        case "range": {
          const len = innerValue.length;
          if (len === 0 || len === 2) {
            change([day]);
          } else if (len === 1) {
            const t = compareDay(innerValue[0], day);
            if (t === null || t === void 0) {
              change([]);
            } else if (t < 0) {
              change([innerValue[0], day]);
            } else {
              change([day, innerValue[0]]);
            }
          } else {
            console.warn("[NutUI] Calendar range error");
          }
          break;
        }
        case "week": {
          if (innerValue.length === 2 || innerValue.length === 0) {
            const [left, right] = getCurrentWeekDays(day, firstDayOfWeek);
            change([left, right]);
          } else {
            console.warn("[NutUI] Calendar week error");
          }
          break;
        }
        default: {
          console.warn("[NutUI] Calendar type error");
        }
      }
    };
    const monthTitle = locale.calendaritem.monthTitle;
    const renderHeader = () => {
      return /* @__PURE__ */ React.createElement("div", { className: `${prefixCls}-header` }, /* @__PURE__ */ React.createElement("div", { className: `${prefixCls}-header-left` }, /* @__PURE__ */ React.createElement("div", { className: "double-left", onClick: () => jump(-12) }, /* @__PURE__ */ React.createElement(DoubleLeft, null)), /* @__PURE__ */ React.createElement("div", { className: "left", onClick: () => jump(-1) }, /* @__PURE__ */ React.createElement(ArrowLeft, null))), /* @__PURE__ */ React.createElement("div", { className: `${prefixCls}-header-title` }, monthTitle(month.year, month.month)), /* @__PURE__ */ React.createElement("div", { className: `${prefixCls}-header-right` }, /* @__PURE__ */ React.createElement("div", { className: "right", onClick: () => jump(1) }, /* @__PURE__ */ React.createElement(ArrowRight, null)), /* @__PURE__ */ React.createElement("div", { className: "double-right", onClick: () => jump(12) }, /* @__PURE__ */ React.createElement(DoubleRight, null))));
    };
    const [weekHeader] = React.useState(() => {
      const weekdays = locale.calendaritem.weekdays.map((day, index) => {
        return {
          name: day,
          key: index
        };
      });
      return [
        ...weekdays.slice(firstDayOfWeek, 7),
        ...weekdays.slice(0, firstDayOfWeek)
      ];
    });
    const renderContent = () => {
      return /* @__PURE__ */ React.createElement("div", { className: `${prefixCls}-content` }, /* @__PURE__ */ React.createElement("div", { className: `${prefixCls}-days` }, weekHeader.map((day) => {
        return /* @__PURE__ */ React.createElement(
          "div",
          {
            className: classNames(`${prefixCls}-day`, "header", {
              weekend: day.key === 0 || day.key === 6
            }),
            key: day.key
          },
          day.name
        );
      })), /* @__PURE__ */ React.createElement("div", { className: `${prefixCls}-days` }, days.map((day) => /* @__PURE__ */ React.createElement(
        "div",
        {
          className: classNames(
            `${prefixCls}-day`,
            day.type,
            getClasses(day)
          ),
          key: `${day.year}-${day.month}-${day.date}`,
          onClick: () => handleDayClick(day)
        },
        /* @__PURE__ */ React.createElement("div", { className: `${prefixCls}-day-top` }, renderDayTop ? renderDayTop(day) : ""),
        /* @__PURE__ */ React.createElement("div", { className: `${prefixCls}-day-inner` }, renderDay ? renderDay(day) : day.date),
        /* @__PURE__ */ React.createElement("div", { className: `${prefixCls}-day-bottom` }, renderDayBottom ? renderDayBottom(day) : "")
      ))));
    };
    return days.length > 0 ? /* @__PURE__ */ React.createElement("div", { className: classNames(prefixCls, className), style }, renderHeader(), renderContent()) : null;
  });
  CalendarCard.displayName = "NutCalendarCard";
  const CheckboxGroupContext = React.createContext(null);
  const defaultProps$$ = {
    max: void 0,
    min: void 0,
    list: false,
    labelPosition: "right",
    direction: "vertical",
    onChange: (value) => {
    },
    onLimit: (type) => {
    },
    options: []
  };
  const classPrefix$i = "nut-checkboxgroup";
  const CheckboxGroup = React.forwardRef(
    (props, ref) => {
      const {
        children,
        className,
        disabled,
        list,
        value,
        defaultValue,
        max,
        min,
        labelPosition,
        direction,
        options: options2,
        onChange,
        onLimit,
        ...rest
      } = { ...defaultProps$$, ...props };
      React.useImperativeHandle(ref, () => ({
        toggle(state) {
          if (state === false) {
            setValue([]);
          } else {
            const childrenLabel = [];
            React.Children.map(children, (child) => {
              const childProps = child.props;
              childrenLabel.push(childProps.value);
            });
            setValue(childrenLabel);
          }
        },
        reverse() {
          const childrenLabel = [];
          React.Children.map(children, (child) => {
            const childProps = child.props;
            childrenLabel.push(childProps.value);
          });
          const reverse = childrenLabel.filter(
            (c6) => (_value == null ? void 0 : _value.findIndex((v) => v === c6)) === -1
          );
          setValue(reverse);
        }
      }));
      const [_value, setValue] = usePropsValue({
        value,
        defaultValue,
        finalValue: [],
        onChange
      });
      const renderOptions = React.useCallback(() => {
        return options2 == null ? void 0 : options2.map(({ label, value: value2, disabled: disabled2, onChange: onChange2, ...rest2 }) => {
          return /* @__PURE__ */ React.createElement(
            Checkbox,
            {
              key: value2 == null ? void 0 : value2.toString(),
              label,
              disabled: disabled2,
              value: value2,
              ...rest2
            }
          );
        });
      }, [options2, max, min]);
      return /* @__PURE__ */ React.createElement(
        CheckboxGroupContext.Provider,
        {
          value: {
            labelPosition: labelPosition || "right",
            disabled,
            max,
            list,
            onLimit,
            value: _value,
            check: (value2) => {
              const combined = [..._value, value2];
              if (max !== void 0) {
                if (combined.length > max) {
                  return onLimit == null ? void 0 : onLimit("max");
                }
              }
              setValue(combined);
            },
            uncheck: (value2) => {
              const reduced = _value.filter((item) => item !== value2);
              if (min !== void 0 && reduced.length < min) {
                return onLimit == null ? void 0 : onLimit("min");
              }
              setValue(reduced);
            }
          }
        },
        /* @__PURE__ */ React.createElement(
          "div",
          {
            className: classNames(
              classPrefix$i,
              {
                [`nut-checkboxgroup-${direction}`]: direction,
                [`nut-checkboxgroup-list`]: list
              },
              className
            ),
            ...rest
          },
          (options2 == null ? void 0 : options2.length) ? renderOptions() : children
        )
      );
    }
  );
  CheckboxGroup.displayName = "NutCheckboxGroup";
  const defaultProps$_ = {
    ...ComponentDefaults,
    disabled: false,
    shape: "round",
    labelPosition: "right",
    icon: null,
    activeIcon: null,
    indeterminateIcon: null,
    onChange: (value) => {
    }
  };
  const classPrefix$h = "nut-checkbox";
  const Checkbox = (props) => {
    const { children } = {
      ...defaultProps$_,
      ...props
    };
    const {
      icon,
      label,
      className,
      activeIcon,
      checked,
      value,
      defaultChecked,
      shape,
      disabled,
      onChange,
      indeterminate,
      indeterminateIcon,
      ...others
    } = props;
    let { labelPosition, ...rest } = others;
    const ctx2 = React.useContext(CheckboxGroupContext);
    let [innerChecked, setChecked] = usePropsValue({
      value: checked,
      defaultValue: defaultChecked,
      finalValue: defaultChecked,
      onChange
    });
    let [innerDisabled, setDisabled] = React.useState(disabled);
    const [innerIndeterminate, setIndeterminate] = React.useState(indeterminate);
    React.useEffect(() => {
      setDisabled(disabled);
    }, [disabled]);
    React.useEffect(() => {
      setIndeterminate(indeterminate);
    }, [indeterminate]);
    if (ctx2) {
      if (ctx2.labelPosition !== void 0) {
        labelPosition = ctx2.labelPosition;
      }
      innerDisabled = ctx2.disabled !== void 0 ? ctx2.disabled : innerDisabled;
      innerChecked = ctx2.value.includes(value);
      setChecked = (checked2) => {
        if (ctx2.disabled) return;
        if (checked2) ctx2.check(value);
        if (!checked2) ctx2.uncheck(value);
      };
    }
    const renderIcon = () => {
      if (innerDisabled) {
        if (innerIndeterminate) {
          return /* @__PURE__ */ React.createElement(i$7, { className: color() });
        }
        if (innerChecked) {
          return /* @__PURE__ */ React.createElement(d, { className: color() });
        }
        return /* @__PURE__ */ React.createElement(i$7, { className: color() });
      }
      if (!innerChecked) {
        return React.isValidElement(icon) ? icon : /* @__PURE__ */ React.createElement(i$6, { className: color() });
      }
      if (innerIndeterminate) {
        return React.isValidElement(indeterminateIcon) ? indeterminateIcon : /* @__PURE__ */ React.createElement(i$7, { className: color() });
      }
      return React.isValidElement(activeIcon) ? activeIcon : /* @__PURE__ */ React.createElement(d, { className: color() });
    };
    const color = () => {
      const cls = `${classPrefix$h}-icon `;
      if (innerDisabled) {
        if (innerChecked && !innerIndeterminate) {
          return `${cls}${classPrefix$h}-icon-checked ${classPrefix$h}-icon-disabled`;
        }
        if (innerChecked && innerIndeterminate) {
          return `${cls}${classPrefix$h}-icon-indeterminate ${classPrefix$h}-icon-disabled`;
        }
        return `${cls}${classPrefix$h}-icon-disabled`;
      }
      if (innerChecked) {
        if (innerIndeterminate) {
          return `${cls}${classPrefix$h}-icon-indeterminate`;
        }
        return `${cls}${classPrefix$h}-icon-checked`;
      }
      return cls;
    };
    const renderLabel = () => {
      return /* @__PURE__ */ React.createElement(
        "span",
        {
          className: classNames(`${classPrefix$h}-label `, {
            [`${classPrefix$h}-label-disabled`]: innerDisabled
          })
        },
        children || label
      );
    };
    const handleClick2 = () => {
      if (disabled) return;
      const latestChecked = !innerChecked;
      setChecked(latestChecked);
    };
    const renderButton = () => {
      return /* @__PURE__ */ React.createElement(
        "div",
        {
          className: classNames(`${classPrefix$h}-button`, {
            [`${classPrefix$h}-button-active`]: innerChecked,
            [`${classPrefix$h}-button-disabled`]: disabled
          })
        },
        children || label,
        innerChecked && activeIcon ? /* @__PURE__ */ React.createElement("div", { className: classNames(`${classPrefix$h}-button-icon`) }, activeIcon) : null
      );
    };
    const renderListItem = () => {
      return /* @__PURE__ */ React.createElement("div", { className: `${classPrefix$h}-list-item` }, renderLabel(), renderIcon());
    };
    const renderCheckboxItem = () => {
      if (ctx2 == null ? void 0 : ctx2.list) {
        return /* @__PURE__ */ React.createElement(React.Fragment, null, renderListItem());
      }
      if (shape === "button") {
        return renderButton();
      }
      return /* @__PURE__ */ React.createElement(React.Fragment, null, renderIcon(), renderLabel());
    };
    return /* @__PURE__ */ React.createElement(
      "div",
      {
        className: classNames(
          classPrefix$h,
          {
            [`${classPrefix$h}-reverse`]: labelPosition === "left"
          },
          className
        ),
        ...rest,
        onClick: handleClick2
      },
      renderCheckboxItem()
    );
  };
  Checkbox.displayName = "NutCheckBox";
  Checkbox.Group = CheckboxGroup;
  const InternalPickerPanel = (props, ref) => {
    const {
      keyIndex = 0,
      defaultValue,
      options: options2 = [],
      threeDimensional = true,
      duration = 1e3,
      chooseItem
    } = props;
    const touch = useTouch();
    const DEFAULT_DURATION = 200;
    const INERTIA_TIME = 300;
    const INERTIA_DISTANCE = 15;
    const [currIndex, setCurrIndex] = React.useState(1);
    const lineSpacing = 36;
    const [touchTime, setTouchTime] = React.useState(0);
    const [touchDeg, setTouchDeg] = React.useState("0deg");
    const rotation = 20;
    const moving = React.useRef(false);
    let timer;
    const rollerRef = React.useRef(null);
    const PickerPanelRef = React.useRef(null);
    const [startTime, setStartTime] = React.useState(0);
    const [startY, setStartY] = React.useState(0);
    const transformY = React.useRef(0);
    const [scrollDistance, setScrollDistance] = React.useState(0);
    const isHidden = (index) => {
      if (index >= currIndex + 8 || index <= currIndex - 8) {
        return true;
      }
      return false;
    };
    const setTransform = (type, deg, time = DEFAULT_DURATION, translateY = 0) => {
      let nTime = time;
      if (type !== "end") {
        nTime = 0;
      }
      setTouchTime(nTime);
      setTouchDeg(deg);
      setScrollDistance(translateY);
    };
    const setMove = (move, type, time) => {
      let updateMove = move + transformY.current;
      if (type === "end") {
        if (updateMove > 0) {
          updateMove = 0;
        }
        if (updateMove < -(options2.length - 1) * lineSpacing) {
          updateMove = -(options2.length - 1) * lineSpacing;
        }
        const endMove = Math.round(updateMove / lineSpacing) * lineSpacing;
        const deg = `${(Math.abs(Math.round(endMove / lineSpacing)) + 1) * rotation}deg`;
        setTransform(type, deg, time, endMove);
        setCurrIndex(Math.abs(Math.round(endMove / lineSpacing)) + 1);
      } else {
        let deg = 0;
        const currentDeg = (-updateMove / lineSpacing + 1) * rotation;
        const maxDeg = (options2.length + 1) * rotation;
        const minDeg = 0;
        deg = Math.min(Math.max(currentDeg, minDeg), maxDeg);
        if (minDeg < deg && deg < maxDeg) {
          setTransform("", `${deg}deg`, void 0, updateMove);
          setCurrIndex(Math.abs(Math.round(updateMove / lineSpacing)) + 1);
        }
      }
    };
    const setChooseValue = (move) => {
      chooseItem == null ? void 0 : chooseItem(options2 == null ? void 0 : options2[Math.round(-move / lineSpacing)], keyIndex);
    };
    const touchStart = (event) => {
      touch.start(event);
      setStartY(touch.deltaY.current);
      setStartTime(Date.now());
      transformY.current = scrollDistance;
    };
    const touchMove = (event) => {
      touch.move(event);
      if (touch.isVertical) {
        moving.current = true;
        preventDefault2(event);
      }
      const move = touch.deltaY.current - startY;
      setMove(move);
    };
    const touchEnd = () => {
      if (!moving.current) return;
      const move = touch.deltaY.current - startY;
      const moveTime = Date.now() - startTime;
      if (moveTime <= INERTIA_TIME && Math.abs(move) > INERTIA_DISTANCE) {
        const distance = momentum(move, moveTime);
        setMove(distance, "end", +duration);
      } else {
        setMove(move, "end");
      }
      setTimeout(() => {
        touch.reset();
      }, 0);
    };
    const momentum = (distance, duration2) => {
      let nDistance = distance;
      const speed = Math.abs(nDistance / duration2);
      nDistance = speed / 3e-3 * (nDistance < 0 ? -1 : 1);
      return nDistance;
    };
    const modifyStatus = (type, val) => {
      const value = defaultValue;
      let index = -1;
      if (value) {
        options2.some((item, idx) => {
          if (item.value === value) {
            index = idx;
            return true;
          }
          return false;
        });
      } else {
        options2.forEach((item, i2) => {
          if (item.value === defaultValue) {
            index = i2;
          }
        });
      }
      setCurrIndex(index === -1 ? 1 : index + 1);
      const move = index === -1 ? 0 : index * lineSpacing;
      setMove(-move);
    };
    const stopMomentum = () => {
      moving.current = false;
      setTouchTime(0);
      setChooseValue(scrollDistance);
    };
    const preventDefault2 = (event, isStopPropagation) => {
      if (typeof event.cancelable !== "boolean" || event.cancelable) {
        event.preventDefault();
      }
      {
        event.stopPropagation();
      }
    };
    const touchRollerStyle = () => {
      return {
        transition: `transform ${touchTime}ms cubic-bezier(0.17, 0.89, 0.45, 1)`,
        transform: `rotate3d(1, 0, 0, ${touchDeg})`
      };
    };
    const touchTileStyle = () => {
      return {
        transition: `transform ${touchTime}ms cubic-bezier(0.17, 0.89, 0.45, 1)`,
        transform: `translate3d(0, ${scrollDistance}px, 0)`
      };
    };
    React.useEffect(() => {
      setScrollDistance(0);
      transformY.current = 0;
      modifyStatus();
      return () => {
        clearTimeout(timer);
      };
    }, [options2]);
    React.useImperativeHandle(ref, () => ({
      stopMomentum,
      moving: moving.current
    }));
    React.useEffect(() => {
      var _a, _b, _c;
      const options22 = passiveSupported ? { passive: false } : false;
      (_a = PickerPanelRef.current) == null ? void 0 : _a.addEventListener("touchstart", touchStart, options22);
      (_b = PickerPanelRef.current) == null ? void 0 : _b.addEventListener("touchmove", touchMove, options22);
      (_c = PickerPanelRef.current) == null ? void 0 : _c.addEventListener("touchend", touchEnd, options22);
      return () => {
        var _a2, _b2, _c2;
        (_a2 = PickerPanelRef.current) == null ? void 0 : _a2.removeEventListener("touchstart", touchStart);
        (_b2 = PickerPanelRef.current) == null ? void 0 : _b2.removeEventListener("touchmove", touchMove);
        (_c2 = PickerPanelRef.current) == null ? void 0 : _c2.removeEventListener("touchend", touchEnd);
      };
    });
    return /* @__PURE__ */ React.createElement(
      "div",
      {
        className: "nut-picker-list",
        ref: PickerPanelRef,
        onTouchStart: touchStart,
        onTouchMove: touchMove,
        onTouchEnd: touchEnd
      },
      /* @__PURE__ */ React.createElement(
        "div",
        {
          className: "nut-picker-roller",
          ref: rollerRef,
          style: threeDimensional ? touchRollerStyle() : touchTileStyle(),
          onTransitionEnd: stopMomentum
        },
        threeDimensional && options2.map((item, index) => {
          return /* @__PURE__ */ React.createElement(
            "div",
            {
              className: `nut-picker-roller-item ${isHidden(index + 1) && "nut-picker-roller-item-hidden"}`,
              style: {
                transform: `rotate3d(1, 0, 0, ${-rotation * (index + 1)}deg) translate3d(0px, 0px, 104px)`
              },
              key: item.value ? item.value : index
            },
            /* @__PURE__ */ React.createElement(React.Fragment, null, item.text)
          );
        }),
        !threeDimensional && options2.map((item, index) => {
          return /* @__PURE__ */ React.createElement(
            "div",
            {
              className: "nut-picker-roller-item-title",
              key: item.value ? item.value : index
            },
            /* @__PURE__ */ React.createElement(React.Fragment, null, item.text)
          );
        })
      ),
      /* @__PURE__ */ React.createElement("div", { className: "nut-picker-mask" }),
      /* @__PURE__ */ React.createElement("div", { className: "nut-picker-indicator" })
    );
  };
  const PickerPanel = React.forwardRef(InternalPickerPanel);
  function useRefs() {
    const refs = React.useRef([]);
    const setRefs = React.useCallback(
      (index) => (el) => {
        if (el) refs.current[index] = el;
      },
      []
    );
    const reset = React.useCallback(() => {
      refs.current = [];
    }, []);
    return [refs.current, setRefs, reset];
  }
  const defaultProps$Z = {
    ...ComponentDefaults,
    title: "",
    options: [],
    value: [],
    defaultValue: [],
    threeDimensional: true,
    closeOnOverlayClick: true,
    duration: 1e3
  };
  const InternalPicker = (props, ref) => {
    const { locale } = useConfig();
    const {
      children,
      visible,
      title,
      options: options2 = [],
      closeOnOverlayClick,
      popupProps = {},
      defaultValue = [],
      className,
      style,
      threeDimensional,
      duration,
      onConfirm,
      onCancel,
      onClose,
      afterClose,
      onChange,
      ...rest
    } = { ...defaultProps$Z, ...props };
    const classPrefix2 = "nut-picker";
    const classes = classNames(classPrefix2, className);
    const [selectedValue, setSelectedValue] = usePropsValue({
      value: props.value,
      defaultValue: [...defaultValue],
      finalValue: [...defaultValue],
      onChange: (val) => {
        var _a;
        (_a = props.onConfirm) == null ? void 0 : _a.call(props, setSelectedOptions(), val);
      }
    });
    const [innerVisible, setInnerVisible] = usePropsValue({
      value: props.visible,
      defaultValue: false,
      finalValue: false,
      onChange: (val) => {
        var _a;
        (_a = props.onClose) == null ? void 0 : _a.call(props, setSelectedOptions(), innerValue);
      }
    });
    const [innerValue, setInnerValue] = React.useState(selectedValue);
    const [columnIndex, setColumnIndex] = React.useState(0);
    const pickerRef = React.useRef(null);
    const [refs, setRefs] = useRefs();
    const [columnsList, setColumnsList] = React.useState([]);
    const isConfirmEvent = React.useRef(false);
    const actions = {
      open: () => {
        setInnerVisible(true);
      },
      close: () => {
        setInnerVisible(false);
      }
    };
    React.useImperativeHandle(ref, () => actions);
    const formatCascade = (columns, values) => {
      const formatted = [];
      let columnOptions = {
        text: "",
        value: "",
        children: columns
      };
      let columnIndex2 = 0;
      while (columnOptions && columnOptions.children) {
        const options22 = columnOptions.children;
        const value = values[columnIndex2];
        let index = options22.findIndex((columnItem) => columnItem.value === value);
        if (index === -1) index = 0;
        columnOptions = columnOptions.children[index];
        columnIndex2++;
        formatted.push(options22);
      }
      return formatted;
    };
    const columnsType = () => {
      const firstColumn = options2[0];
      if (firstColumn) {
        if (Array.isArray(firstColumn)) {
          return "multiple";
        }
        if ("children" in firstColumn) {
          return "cascade";
        }
      }
      return "single";
    };
    const normalListData = (innerValue2) => {
      const type = columnsType();
      switch (type) {
        case "multiple":
          return options2;
        case "cascade":
          return formatCascade(options2, innerValue2);
        default:
          return [options2];
      }
    };
    const init = () => {
      const normalData = normalListData(
        innerValue
      );
      setColumnsList(normalData);
      const data = [];
      normalData.length > 0 && normalData.map((item) => {
        item[0] && data.push(item[0].value);
        return item;
      });
      if (!innerValue.length && innerValue.length === 0) {
        setInnerValue([...data]);
      }
    };
    React.useEffect(() => {
      setInnerValue(innerValue !== selectedValue ? selectedValue : innerValue);
    }, [innerVisible, selectedValue]);
    React.useEffect(() => {
      if (innerVisible) {
        init();
      }
    }, [options2, innerVisible]);
    React.useEffect(() => {
      onChange && onChange(setSelectedOptions(), innerValue, columnIndex);
    }, [innerValue, columnsList]);
    const setSelectedOptions = () => {
      const options22 = [];
      let currOptions = [];
      columnsList.forEach((columnOptions, index) => {
        currOptions = columnOptions.filter(
          (item) => item.value === innerValue[index]
        );
        if (currOptions[0]) {
          options22.push(currOptions[0]);
        } else {
          columnOptions[0] && options22.push(columnOptions[0]);
        }
      });
      return options22;
    };
    const chooseItem = (columnOptions, columnIndex2) => {
      var _a, _b;
      const values = [];
      const start2 = columnIndex2;
      if (columnOptions && Object.keys(columnOptions).length) {
        if (values[columnIndex2] !== columnOptions.value) {
          if (columnsType() === "cascade") {
            values[columnIndex2] = columnOptions.value || "";
            while ((_a = columnOptions == null ? void 0 : columnOptions.children) == null ? void 0 : _a[0]) {
              values[columnIndex2 + 1] = columnOptions.children[0].value;
              columnIndex2++;
              columnOptions = columnOptions.children[0];
            }
            if ((_b = columnOptions == null ? void 0 : columnOptions.children) == null ? void 0 : _b.length) {
              values[columnIndex2 + 1] = "";
            }
            const combineResult = [
              ...innerValue.slice(0, start2),
              ...values.splice(start2)
            ];
            setInnerValue(combineResult);
            setColumnsList(normalListData(combineResult));
          } else {
            setInnerValue((data) => {
              const cdata = [...data];
              cdata[columnIndex2] = Object.prototype.hasOwnProperty.call(
                columnOptions,
                "value"
              ) ? columnOptions.value : "";
              return cdata;
            });
          }
          setColumnIndex(columnIndex2);
        }
      }
    };
    const confirm2 = () => {
      let moving = false;
      refs.forEach((ref2) => {
        if (ref2.moving) moving = true;
        ref2.stopMomentum();
      });
      if (moving) {
        isConfirmEvent.current = true;
      } else {
        setSelectedValue(innerValue, true);
        setInnerVisible(false);
      }
      setTimeout(() => {
        isConfirmEvent.current = false;
      }, 0);
    };
    const renderTitleBar = () => {
      return /* @__PURE__ */ React.createElement("div", { className: `${classPrefix2}-control` }, /* @__PURE__ */ React.createElement(
        "span",
        {
          className: `${classPrefix2}-cancel-btn`,
          onClick: (e) => {
            e.stopPropagation();
            onCancel == null ? void 0 : onCancel();
            setInnerVisible(false);
          }
        },
        locale == null ? void 0 : locale.cancel
      ), /* @__PURE__ */ React.createElement("div", { className: `${classPrefix2}-title` }, title || ""), /* @__PURE__ */ React.createElement(
        "span",
        {
          className: `${classPrefix2}-confirm-btn`,
          onClick: (e) => {
            e.stopPropagation();
            confirm2();
          }
        },
        locale.confirm
      ));
    };
    return /* @__PURE__ */ React.createElement(React.Fragment, null, typeof children === "function" && children(selectedValue), /* @__PURE__ */ React.createElement(
      Popup,
      {
        ...popupProps,
        visible: innerVisible,
        position: "bottom",
        onOverlayClick: () => {
          var _a;
          if (closeOnOverlayClick) {
            (_a = props.onCancel) == null ? void 0 : _a.call(props);
            setInnerVisible(false);
          }
        },
        afterClose: () => {
          afterClose == null ? void 0 : afterClose(setSelectedOptions(), innerValue, pickerRef);
        }
      },
      /* @__PURE__ */ React.createElement("div", { className: classes, style, ...rest }, renderTitleBar(), typeof children !== "function" && children, /* @__PURE__ */ React.createElement("div", { className: `${classPrefix2}-panel`, ref: pickerRef }, columnsList == null ? void 0 : columnsList.map((item, index) => {
        return /* @__PURE__ */ React.createElement(
          PickerPanel,
          {
            ref: setRefs(index),
            defaultValue: innerValue == null ? void 0 : innerValue[index],
            options: item,
            threeDimensional,
            chooseItem: (value, index2) => chooseItem(value, index2),
            duration,
            key: index,
            keyIndex: index
          }
        );
      }))),
      /* @__PURE__ */ React.createElement(SafeArea, { position: "bottom" })
    ));
  };
  const Picker = React.forwardRef(InternalPicker);
  const isDate = (val) => {
    return Object.prototype.toString.call(val) === "[object Date]" && !Number.isNaN(val.getTime());
  };
  const padZero = (num, targetLength = 2) => {
    let str = `${num}`;
    while (str.length < targetLength) {
      str = `0${str}`;
    }
    return str;
  };
  const currentYear = (/* @__PURE__ */ new Date()).getFullYear();
  const defaultProps$Y = {
    ...ComponentDefaults,
    visible: false,
    title: "",
    type: "date",
    showChinese: false,
    threeDimensional: true,
    minuteStep: 1,
    startDate: new Date(currentYear - 10, 0, 1),
    endDate: new Date(currentYear + 10, 11, 31)
  };
  const DatePicker = (props) => {
    const {
      startDate,
      endDate,
      type,
      showChinese,
      minuteStep,
      visible,
      title,
      defaultValue,
      pickerProps = {},
      formatter,
      onClose,
      onCancel,
      onConfirm,
      filter,
      onChange,
      threeDimensional,
      className,
      style,
      ...rest
    } = {
      ...defaultProps$Y,
      ...props
    };
    const { locale } = useConfig();
    const lang = locale.datepicker;
    const zhCNType = {
      day: lang.day,
      year: lang.year,
      month: lang.month,
      hour: lang.hour,
      minute: lang.min,
      seconds: lang.seconds
    };
    const [pickerValue, setPickerValue] = React.useState([]);
    const [pickerOptions, setPickerOptions] = React.useState([]);
    const formatValue = (value) => {
      if (!value || value && !isDate(value)) {
        value = startDate;
      }
      return Math.min(
        Math.max(value.getTime(), startDate.getTime()),
        endDate.getTime()
      );
    };
    const [selectedDate, setSelectedDate] = usePropsValue({
      value: props.value && formatValue(props.value),
      defaultValue: props.defaultValue && formatValue(props.defaultValue),
      finalValue: 0
    });
    function getMonthEndDay(year, month) {
      return new Date(year, month, 0).getDate();
    }
    const getBoundary = (type22, value) => {
      const boundary = type22 === "min" ? startDate : endDate;
      const year = boundary.getFullYear();
      let month = 1;
      let date = 1;
      let hour = 0;
      let minute = 0;
      if (type22 === "max") {
        month = 12;
        date = getMonthEndDay(value.getFullYear(), value.getMonth() + 1);
        hour = 23;
        minute = 59;
      }
      const seconds = minute;
      if (value.getFullYear() === year) {
        month = boundary.getMonth() + 1;
        if (value.getMonth() + 1 === month) {
          date = boundary.getDate();
          if (value.getDate() === date) {
            hour = boundary.getHours();
            if (value.getHours() === hour) {
              minute = boundary.getMinutes();
            }
          }
        }
      }
      return {
        [`${type22}Year`]: year,
        [`${type22}Month`]: month,
        [`${type22}Date`]: date,
        [`${type22}Hour`]: hour,
        [`${type22}Minute`]: minute,
        [`${type22}Seconds`]: seconds
      };
    };
    const ranges = () => {
      const selected = new Date(selectedDate);
      if (!selected) return [];
      const { maxYear, maxDate, maxMonth, maxHour, maxMinute, maxSeconds } = getBoundary("max", selected);
      const { minYear, minDate, minMonth, minHour, minMinute, minSeconds } = getBoundary("min", selected);
      const result = [
        {
          type: "year",
          range: [minYear, maxYear]
        },
        {
          type: "month",
          range: [minMonth, maxMonth]
        },
        {
          type: "day",
          range: [minDate, maxDate]
        },
        {
          type: "hour",
          range: [minHour, maxHour]
        },
        {
          type: "minute",
          range: [minMinute, maxMinute]
        },
        {
          type: "seconds",
          range: [minSeconds, maxSeconds]
        }
      ];
      switch (type.toLocaleLowerCase()) {
        case "date":
          return result.slice(0, 3);
        case "datetime":
          return result.slice(0, 5);
        case "time":
          return result.slice(3, 6);
        case "year-month":
          return result.slice(0, 2);
        case "hour-minutes":
          return result.slice(3, 5);
        case "month-day":
          return result.slice(1, 3);
        case "datehour":
          return result.slice(0, 4);
        default:
          return result;
      }
    };
    const compareDateChange = (currentDate, newDate, selectedOptions, index) => {
      var _a;
      const isEqual2 = ((_a = new Date(currentDate)) == null ? void 0 : _a.getTime()) === (newDate == null ? void 0 : newDate.getTime());
      if (newDate && isDate(newDate)) {
        if (!isEqual2) {
          setSelectedDate(formatValue(newDate));
        }
        onChange == null ? void 0 : onChange(
          selectedOptions,
          [
            String(newDate.getFullYear()),
            String(newDate.getMonth() + 1),
            String(newDate.getDate())
          ],
          index
        );
      }
    };
    const handlePickerChange = (selectedOptions, selectedValue, index) => {
      const rangeType = type.toLocaleLowerCase();
      if (["date", "datetime", "datehour", "month-day", "year-month"].includes(
        rangeType
      )) {
        const formatDate = [];
        selectedValue.forEach((item) => {
          formatDate.push(item);
        });
        if (rangeType === "month-day" && formatDate.length < 3) {
          formatDate.unshift(
            new Date(defaultValue || startDate || endDate).getFullYear()
          );
        }
        if (rangeType === "year-month" && formatDate.length < 3) {
          formatDate.push(
            new Date(defaultValue || startDate || endDate).getDate()
          );
        }
        const year = Number(formatDate[0]);
        const month = Number(formatDate[1]) - 1;
        const day = Math.min(
          Number(formatDate[2]),
          getMonthEndDay(Number(formatDate[0]), Number(formatDate[1]))
        );
        if (selectedOptions.length >= 2 && ["date", "datehour", "datetime", "month-day"].includes(rangeType)) {
          const dayOption = formatOption("day", day);
          if (rangeType === "month-day") {
            selectedOptions[1] = dayOption;
          } else {
            selectedOptions[2] = dayOption;
          }
        }
        let date = null;
        if (rangeType === "date" || rangeType === "month-day" || rangeType === "year-month") {
          date = new Date(year, month, day);
        } else if (rangeType === "datetime") {
          date = new Date(
            year,
            month,
            day,
            Number(formatDate[3]),
            Number(formatDate[4])
          );
        } else if (rangeType === "datehour") {
          date = new Date(year, month, day, Number(formatDate[3]));
        }
        compareDateChange(selectedDate, date, selectedOptions, index);
      } else {
        const [hour, minute, seconds] = selectedValue;
        const currentDate = new Date(selectedDate);
        const year = currentDate.getFullYear();
        const month = currentDate.getMonth();
        const day = currentDate.getDate();
        const date = new Date(
          year,
          month,
          day,
          Number(hour),
          Number(minute),
          rangeType === "time" ? Number(seconds) : 0
        );
        compareDateChange(selectedDate, date, selectedOptions, index);
      }
    };
    const formatOption = (type22, value) => {
      if (formatter) {
        return formatter(type22, {
          text: padZero(value, 2),
          value: padZero(value, 2)
        });
      }
      const padMin = padZero(value, 2);
      const fatter = showChinese ? zhCNType[type22] : "";
      return { text: padMin + fatter, value: padMin };
    };
    const generateColumn = (min, max, val, type22, columnIndex) => {
      var _a;
      let cmin = min;
      const arr = [];
      let index = 0;
      while (cmin <= max) {
        arr.push(formatOption(type22, cmin));
        if (type22 === "minute") {
          cmin += minuteStep;
        } else {
          cmin++;
        }
        if (cmin <= Number(val)) {
          index++;
        }
      }
      pickerValue[columnIndex] = (_a = arr[index]) == null ? void 0 : _a.value;
      setPickerValue([...pickerValue]);
      if (filter == null ? void 0 : filter(type22, arr)) {
        return filter == null ? void 0 : filter(type22, arr);
      }
      return arr;
    };
    const getDateIndex = (type22) => {
      const date = new Date(selectedDate);
      if (!selectedDate) return 0;
      if (type22 === "year") {
        return date.getFullYear();
      }
      if (type22 === "month") {
        return date.getMonth() + 1;
      }
      if (type22 === "day") {
        return date.getDate();
      }
      if (type22 === "hour") {
        return date.getHours();
      }
      if (type22 === "minute") {
        return date.getMinutes();
      }
      if (type22 === "seconds") {
        return date.getSeconds();
      }
      return 0;
    };
    const columns = () => {
      const val = ranges().map((res, columnIndex) => {
        return generateColumn(
          res.range[0],
          res.range[1],
          getDateIndex(res.type),
          res.type,
          columnIndex
        );
      });
      return val || [];
    };
    React.useEffect(() => {
      setPickerOptions(columns());
    }, [selectedDate, startDate, endDate]);
    return /* @__PURE__ */ React.createElement("div", { className: `nut-datepicker ${className}`, style, ...rest }, pickerOptions.length > 0 && /* @__PURE__ */ React.createElement(
      Picker,
      {
        ...pickerProps,
        title,
        visible,
        options: pickerOptions,
        onClose,
        onCancel,
        value: pickerValue,
        onConfirm: (options2, value) => onConfirm && onConfirm(options2, value),
        onChange: (options2, value, index) => handlePickerChange(options2, value, index),
        threeDimensional
      }
    ));
  };
  DatePicker.displayName = "NutDatePicker";
  const Context = React.createContext({});
  function _extends() {
    _extends = Object.assign ? Object.assign.bind() : function(target) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        var source = arguments[i2];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends.apply(this, arguments);
  }
  function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    _setPrototypeOf(subClass, superClass);
  }
  function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
      return o2.__proto__ || Object.getPrototypeOf(o2);
    };
    return _getPrototypeOf(o);
  }
  function _setPrototypeOf(o, p2) {
    _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p22) {
      o2.__proto__ = p22;
      return o2;
    };
    return _setPrototypeOf(o, p2);
  }
  function _isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;
    try {
      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      }));
      return true;
    } catch (e) {
      return false;
    }
  }
  function _construct(Parent, args, Class) {
    if (_isNativeReflectConstruct()) {
      _construct = Reflect.construct.bind();
    } else {
      _construct = function _construct2(Parent2, args2, Class2) {
        var a = [null];
        a.push.apply(a, args2);
        var Constructor = Function.bind.apply(Parent2, a);
        var instance = new Constructor();
        if (Class2) _setPrototypeOf(instance, Class2.prototype);
        return instance;
      };
    }
    return _construct.apply(null, arguments);
  }
  function _isNativeFunction(fn) {
    return Function.toString.call(fn).indexOf("[native code]") !== -1;
  }
  function _wrapNativeSuper(Class) {
    var _cache = typeof Map === "function" ? /* @__PURE__ */ new Map() : void 0;
    _wrapNativeSuper = function _wrapNativeSuper2(Class2) {
      if (Class2 === null || !_isNativeFunction(Class2)) return Class2;
      if (typeof Class2 !== "function") {
        throw new TypeError("Super expression must either be null or a function");
      }
      if (typeof _cache !== "undefined") {
        if (_cache.has(Class2)) return _cache.get(Class2);
        _cache.set(Class2, Wrapper);
      }
      function Wrapper() {
        return _construct(Class2, arguments, _getPrototypeOf(this).constructor);
      }
      Wrapper.prototype = Object.create(Class2.prototype, {
        constructor: {
          value: Wrapper,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
      return _setPrototypeOf(Wrapper, Class2);
    };
    return _wrapNativeSuper(Class);
  }
  var formatRegExp = /%[sdj%]/g;
  var warning = function warning2() {
  };
  if (typeof process !== "undefined" && process.env && false) {
    warning = function warning3(type4, errors) {
      if (typeof console !== "undefined" && console.warn && typeof ASYNC_VALIDATOR_NO_WARNING === "undefined") {
        if (errors.every(function(e) {
          return typeof e === "string";
        })) {
          console.warn(type4, errors);
        }
      }
    };
  }
  function convertFieldsError(errors) {
    if (!errors || !errors.length) return null;
    var fields = {};
    errors.forEach(function(error) {
      var field = error.field;
      fields[field] = fields[field] || [];
      fields[field].push(error);
    });
    return fields;
  }
  function format(template) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }
    var i2 = 0;
    var len = args.length;
    if (typeof template === "function") {
      return template.apply(null, args);
    }
    if (typeof template === "string") {
      var str = template.replace(formatRegExp, function(x) {
        if (x === "%%") {
          return "%";
        }
        if (i2 >= len) {
          return x;
        }
        switch (x) {
          case "%s":
            return String(args[i2++]);
          case "%d":
            return Number(args[i2++]);
          case "%j":
            try {
              return JSON.stringify(args[i2++]);
            } catch (_) {
              return "[Circular]";
            }
            break;
          default:
            return x;
        }
      });
      return str;
    }
    return template;
  }
  function isNativeStringType(type4) {
    return type4 === "string" || type4 === "url" || type4 === "hex" || type4 === "email" || type4 === "date" || type4 === "pattern";
  }
  function isEmptyValue(value, type4) {
    if (value === void 0 || value === null) {
      return true;
    }
    if (type4 === "array" && Array.isArray(value) && !value.length) {
      return true;
    }
    if (isNativeStringType(type4) && typeof value === "string" && !value) {
      return true;
    }
    return false;
  }
  function asyncParallelArray(arr, func, callback) {
    var results = [];
    var total = 0;
    var arrLength = arr.length;
    function count(errors) {
      results.push.apply(results, errors || []);
      total++;
      if (total === arrLength) {
        callback(results);
      }
    }
    arr.forEach(function(a) {
      func(a, count);
    });
  }
  function asyncSerialArray(arr, func, callback) {
    var index = 0;
    var arrLength = arr.length;
    function next(errors) {
      if (errors && errors.length) {
        callback(errors);
        return;
      }
      var original = index;
      index = index + 1;
      if (original < arrLength) {
        func(arr[original], next);
      } else {
        callback([]);
      }
    }
    next([]);
  }
  function flattenObjArr(objArr) {
    var ret = [];
    Object.keys(objArr).forEach(function(k) {
      ret.push.apply(ret, objArr[k] || []);
    });
    return ret;
  }
  var AsyncValidationError = /* @__PURE__ */ function(_Error) {
    _inheritsLoose(AsyncValidationError2, _Error);
    function AsyncValidationError2(errors, fields) {
      var _this;
      _this = _Error.call(this, "Async Validation Error") || this;
      _this.errors = errors;
      _this.fields = fields;
      return _this;
    }
    return AsyncValidationError2;
  }(/* @__PURE__ */ _wrapNativeSuper(Error));
  function asyncMap(objArr, option, func, callback, source) {
    if (option.first) {
      var _pending = new Promise(function(resolve, reject) {
        var next = function next2(errors) {
          callback(errors);
          return errors.length ? reject(new AsyncValidationError(errors, convertFieldsError(errors))) : resolve(source);
        };
        var flattenArr = flattenObjArr(objArr);
        asyncSerialArray(flattenArr, func, next);
      });
      _pending["catch"](function(e) {
        return e;
      });
      return _pending;
    }
    var firstFields = option.firstFields === true ? Object.keys(objArr) : option.firstFields || [];
    var objArrKeys = Object.keys(objArr);
    var objArrLength = objArrKeys.length;
    var total = 0;
    var results = [];
    var pending = new Promise(function(resolve, reject) {
      var next = function next2(errors) {
        results.push.apply(results, errors);
        total++;
        if (total === objArrLength) {
          callback(results);
          return results.length ? reject(new AsyncValidationError(results, convertFieldsError(results))) : resolve(source);
        }
      };
      if (!objArrKeys.length) {
        callback(results);
        resolve(source);
      }
      objArrKeys.forEach(function(key) {
        var arr = objArr[key];
        if (firstFields.indexOf(key) !== -1) {
          asyncSerialArray(arr, func, next);
        } else {
          asyncParallelArray(arr, func, next);
        }
      });
    });
    pending["catch"](function(e) {
      return e;
    });
    return pending;
  }
  function isErrorObj(obj) {
    return !!(obj && obj.message !== void 0);
  }
  function getValue(value, path) {
    var v = value;
    for (var i2 = 0; i2 < path.length; i2++) {
      if (v == void 0) {
        return v;
      }
      v = v[path[i2]];
    }
    return v;
  }
  function complementError(rule, source) {
    return function(oe) {
      var fieldValue;
      if (rule.fullFields) {
        fieldValue = getValue(source, rule.fullFields);
      } else {
        fieldValue = source[oe.field || rule.fullField];
      }
      if (isErrorObj(oe)) {
        oe.field = oe.field || rule.fullField;
        oe.fieldValue = fieldValue;
        return oe;
      }
      return {
        message: typeof oe === "function" ? oe() : oe,
        fieldValue,
        field: oe.field || rule.fullField
      };
    };
  }
  function deepMerge(target, source) {
    if (source) {
      for (var s2 in source) {
        if (source.hasOwnProperty(s2)) {
          var value = source[s2];
          if (typeof value === "object" && typeof target[s2] === "object") {
            target[s2] = _extends({}, target[s2], value);
          } else {
            target[s2] = value;
          }
        }
      }
    }
    return target;
  }
  var required$1 = function required(rule, value, source, errors, options2, type4) {
    if (rule.required && (!source.hasOwnProperty(rule.field) || isEmptyValue(value, type4 || rule.type))) {
      errors.push(format(options2.messages.required, rule.fullField));
    }
  };
  var whitespace = function whitespace2(rule, value, source, errors, options2) {
    if (/^\s+$/.test(value) || value === "") {
      errors.push(format(options2.messages.whitespace, rule.fullField));
    }
  };
  var urlReg;
  var getUrlRegex = function() {
    if (urlReg) {
      return urlReg;
    }
    var word = "[a-fA-F\\d:]";
    var b = function b2(options2) {
      return options2 && options2.includeBoundaries ? "(?:(?<=\\s|^)(?=" + word + ")|(?<=" + word + ")(?=\\s|$))" : "";
    };
    var v4 = "(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}";
    var v6seg = "[a-fA-F\\d]{1,4}";
    var v6 = ("\n(?:\n(?:" + v6seg + ":){7}(?:" + v6seg + "|:)|                                    // 1:2:3:4:5:6:7::  1:2:3:4:5:6:7:8\n(?:" + v6seg + ":){6}(?:" + v4 + "|:" + v6seg + "|:)|                             // 1:2:3:4:5:6::    1:2:3:4:5:6::8   1:2:3:4:5:6::8  1:2:3:4:5:6::1.2.3.4\n(?:" + v6seg + ":){5}(?::" + v4 + "|(?::" + v6seg + "){1,2}|:)|                   // 1:2:3:4:5::      1:2:3:4:5::7:8   1:2:3:4:5::8    1:2:3:4:5::7:1.2.3.4\n(?:" + v6seg + ":){4}(?:(?::" + v6seg + "){0,1}:" + v4 + "|(?::" + v6seg + "){1,3}|:)| // 1:2:3:4::        1:2:3:4::6:7:8   1:2:3:4::8      1:2:3:4::6:7:1.2.3.4\n(?:" + v6seg + ":){3}(?:(?::" + v6seg + "){0,2}:" + v4 + "|(?::" + v6seg + "){1,4}|:)| // 1:2:3::          1:2:3::5:6:7:8   1:2:3::8        1:2:3::5:6:7:1.2.3.4\n(?:" + v6seg + ":){2}(?:(?::" + v6seg + "){0,3}:" + v4 + "|(?::" + v6seg + "){1,5}|:)| // 1:2::            1:2::4:5:6:7:8   1:2::8          1:2::4:5:6:7:1.2.3.4\n(?:" + v6seg + ":){1}(?:(?::" + v6seg + "){0,4}:" + v4 + "|(?::" + v6seg + "){1,6}|:)| // 1::              1::3:4:5:6:7:8   1::8            1::3:4:5:6:7:1.2.3.4\n(?::(?:(?::" + v6seg + "){0,5}:" + v4 + "|(?::" + v6seg + "){1,7}|:))             // ::2:3:4:5:6:7:8  ::2:3:4:5:6:7:8  ::8             ::1.2.3.4\n)(?:%[0-9a-zA-Z]{1,})?                                             // %eth0            %1\n").replace(/\s*\/\/.*$/gm, "").replace(/\n/g, "").trim();
    var v46Exact = new RegExp("(?:^" + v4 + "$)|(?:^" + v6 + "$)");
    var v4exact = new RegExp("^" + v4 + "$");
    var v6exact = new RegExp("^" + v6 + "$");
    var ip = function ip2(options2) {
      return options2 && options2.exact ? v46Exact : new RegExp("(?:" + b(options2) + v4 + b(options2) + ")|(?:" + b(options2) + v6 + b(options2) + ")", "g");
    };
    ip.v4 = function(options2) {
      return options2 && options2.exact ? v4exact : new RegExp("" + b(options2) + v4 + b(options2), "g");
    };
    ip.v6 = function(options2) {
      return options2 && options2.exact ? v6exact : new RegExp("" + b(options2) + v6 + b(options2), "g");
    };
    var protocol = "(?:(?:[a-z]+:)?//)";
    var auth = "(?:\\S+(?::\\S*)?@)?";
    var ipv4 = ip.v4().source;
    var ipv6 = ip.v6().source;
    var host2 = "(?:(?:[a-z\\u00a1-\\uffff0-9][-_]*)*[a-z\\u00a1-\\uffff0-9]+)";
    var domain = "(?:\\.(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)*";
    var tld = "(?:\\.(?:[a-z\\u00a1-\\uffff]{2,}))";
    var port = "(?::\\d{2,5})?";
    var path = '(?:[/?#][^\\s"]*)?';
    var regex = "(?:" + protocol + "|www\\.)" + auth + "(?:localhost|" + ipv4 + "|" + ipv6 + "|" + host2 + domain + tld + ")" + port + path;
    urlReg = new RegExp("(?:^" + regex + "$)", "i");
    return urlReg;
  };
  var pattern$2 = {
    // http://emailregex.com/
    email: /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+\.)+[a-zA-Z\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]{2,}))$/,
    // url: new RegExp(
    //   '^(?!mailto:)(?:(?:http|https|ftp)://|//)(?:\\S+(?::\\S*)?@)?(?:(?:(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[0-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z\\u00a1-\\uffff0-9]+-*)*[a-z\\u00a1-\\uffff0-9]+)(?:\\.(?:[a-z\\u00a1-\\uffff0-9]+-*)*[a-z\\u00a1-\\uffff0-9]+)*(?:\\.(?:[a-z\\u00a1-\\uffff]{2,})))|localhost)(?::\\d{2,5})?(?:(/|\\?|#)[^\\s]*)?$',
    //   'i',
    // ),
    hex: /^#?([a-f0-9]{6}|[a-f0-9]{3})$/i
  };
  var types = {
    integer: function integer(value) {
      return types.number(value) && parseInt(value, 10) === value;
    },
    "float": function float(value) {
      return types.number(value) && !types.integer(value);
    },
    array: function array(value) {
      return Array.isArray(value);
    },
    regexp: function regexp(value) {
      if (value instanceof RegExp) {
        return true;
      }
      try {
        return !!new RegExp(value);
      } catch (e) {
        return false;
      }
    },
    date: function date(value) {
      return typeof value.getTime === "function" && typeof value.getMonth === "function" && typeof value.getYear === "function" && !isNaN(value.getTime());
    },
    number: function number(value) {
      if (isNaN(value)) {
        return false;
      }
      return typeof value === "number";
    },
    object: function object(value) {
      return typeof value === "object" && !types.array(value);
    },
    method: function method(value) {
      return typeof value === "function";
    },
    email: function email(value) {
      return typeof value === "string" && value.length <= 320 && !!value.match(pattern$2.email);
    },
    url: function url(value) {
      return typeof value === "string" && value.length <= 2048 && !!value.match(getUrlRegex());
    },
    hex: function hex(value) {
      return typeof value === "string" && !!value.match(pattern$2.hex);
    }
  };
  var type$1 = function type(rule, value, source, errors, options2) {
    if (rule.required && value === void 0) {
      required$1(rule, value, source, errors, options2);
      return;
    }
    var custom = ["integer", "float", "array", "regexp", "object", "method", "email", "number", "date", "url", "hex"];
    var ruleType = rule.type;
    if (custom.indexOf(ruleType) > -1) {
      if (!types[ruleType](value)) {
        errors.push(format(options2.messages.types[ruleType], rule.fullField, rule.type));
      }
    } else if (ruleType && typeof value !== rule.type) {
      errors.push(format(options2.messages.types[ruleType], rule.fullField, rule.type));
    }
  };
  var range = function range2(rule, value, source, errors, options2) {
    var len = typeof rule.len === "number";
    var min = typeof rule.min === "number";
    var max = typeof rule.max === "number";
    var spRegexp = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
    var val = value;
    var key = null;
    var num = typeof value === "number";
    var str = typeof value === "string";
    var arr = Array.isArray(value);
    if (num) {
      key = "number";
    } else if (str) {
      key = "string";
    } else if (arr) {
      key = "array";
    }
    if (!key) {
      return false;
    }
    if (arr) {
      val = value.length;
    }
    if (str) {
      val = value.replace(spRegexp, "_").length;
    }
    if (len) {
      if (val !== rule.len) {
        errors.push(format(options2.messages[key].len, rule.fullField, rule.len));
      }
    } else if (min && !max && val < rule.min) {
      errors.push(format(options2.messages[key].min, rule.fullField, rule.min));
    } else if (max && !min && val > rule.max) {
      errors.push(format(options2.messages[key].max, rule.fullField, rule.max));
    } else if (min && max && (val < rule.min || val > rule.max)) {
      errors.push(format(options2.messages[key].range, rule.fullField, rule.min, rule.max));
    }
  };
  var ENUM$1 = "enum";
  var enumerable$1 = function enumerable(rule, value, source, errors, options2) {
    rule[ENUM$1] = Array.isArray(rule[ENUM$1]) ? rule[ENUM$1] : [];
    if (rule[ENUM$1].indexOf(value) === -1) {
      errors.push(format(options2.messages[ENUM$1], rule.fullField, rule[ENUM$1].join(", ")));
    }
  };
  var pattern$1 = function pattern(rule, value, source, errors, options2) {
    if (rule.pattern) {
      if (rule.pattern instanceof RegExp) {
        rule.pattern.lastIndex = 0;
        if (!rule.pattern.test(value)) {
          errors.push(format(options2.messages.pattern.mismatch, rule.fullField, value, rule.pattern));
        }
      } else if (typeof rule.pattern === "string") {
        var _pattern = new RegExp(rule.pattern);
        if (!_pattern.test(value)) {
          errors.push(format(options2.messages.pattern.mismatch, rule.fullField, value, rule.pattern));
        }
      }
    }
  };
  var rules = {
    required: required$1,
    whitespace,
    type: type$1,
    range,
    "enum": enumerable$1,
    pattern: pattern$1
  };
  var string = function string2(rule, value, callback, source, options2) {
    var errors = [];
    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
    if (validate) {
      if (isEmptyValue(value, "string") && !rule.required) {
        return callback();
      }
      rules.required(rule, value, source, errors, options2, "string");
      if (!isEmptyValue(value, "string")) {
        rules.type(rule, value, source, errors, options2);
        rules.range(rule, value, source, errors, options2);
        rules.pattern(rule, value, source, errors, options2);
        if (rule.whitespace === true) {
          rules.whitespace(rule, value, source, errors, options2);
        }
      }
    }
    callback(errors);
  };
  var method2 = function method3(rule, value, callback, source, options2) {
    var errors = [];
    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
    if (validate) {
      if (isEmptyValue(value) && !rule.required) {
        return callback();
      }
      rules.required(rule, value, source, errors, options2);
      if (value !== void 0) {
        rules.type(rule, value, source, errors, options2);
      }
    }
    callback(errors);
  };
  var number2 = function number3(rule, value, callback, source, options2) {
    var errors = [];
    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
    if (validate) {
      if (value === "") {
        value = void 0;
      }
      if (isEmptyValue(value) && !rule.required) {
        return callback();
      }
      rules.required(rule, value, source, errors, options2);
      if (value !== void 0) {
        rules.type(rule, value, source, errors, options2);
        rules.range(rule, value, source, errors, options2);
      }
    }
    callback(errors);
  };
  var _boolean = function _boolean2(rule, value, callback, source, options2) {
    var errors = [];
    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
    if (validate) {
      if (isEmptyValue(value) && !rule.required) {
        return callback();
      }
      rules.required(rule, value, source, errors, options2);
      if (value !== void 0) {
        rules.type(rule, value, source, errors, options2);
      }
    }
    callback(errors);
  };
  var regexp2 = function regexp3(rule, value, callback, source, options2) {
    var errors = [];
    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
    if (validate) {
      if (isEmptyValue(value) && !rule.required) {
        return callback();
      }
      rules.required(rule, value, source, errors, options2);
      if (!isEmptyValue(value)) {
        rules.type(rule, value, source, errors, options2);
      }
    }
    callback(errors);
  };
  var integer2 = function integer3(rule, value, callback, source, options2) {
    var errors = [];
    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
    if (validate) {
      if (isEmptyValue(value) && !rule.required) {
        return callback();
      }
      rules.required(rule, value, source, errors, options2);
      if (value !== void 0) {
        rules.type(rule, value, source, errors, options2);
        rules.range(rule, value, source, errors, options2);
      }
    }
    callback(errors);
  };
  var floatFn = function floatFn2(rule, value, callback, source, options2) {
    var errors = [];
    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
    if (validate) {
      if (isEmptyValue(value) && !rule.required) {
        return callback();
      }
      rules.required(rule, value, source, errors, options2);
      if (value !== void 0) {
        rules.type(rule, value, source, errors, options2);
        rules.range(rule, value, source, errors, options2);
      }
    }
    callback(errors);
  };
  var array2 = function array3(rule, value, callback, source, options2) {
    var errors = [];
    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
    if (validate) {
      if ((value === void 0 || value === null) && !rule.required) {
        return callback();
      }
      rules.required(rule, value, source, errors, options2, "array");
      if (value !== void 0 && value !== null) {
        rules.type(rule, value, source, errors, options2);
        rules.range(rule, value, source, errors, options2);
      }
    }
    callback(errors);
  };
  var object2 = function object3(rule, value, callback, source, options2) {
    var errors = [];
    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
    if (validate) {
      if (isEmptyValue(value) && !rule.required) {
        return callback();
      }
      rules.required(rule, value, source, errors, options2);
      if (value !== void 0) {
        rules.type(rule, value, source, errors, options2);
      }
    }
    callback(errors);
  };
  var ENUM = "enum";
  var enumerable2 = function enumerable3(rule, value, callback, source, options2) {
    var errors = [];
    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
    if (validate) {
      if (isEmptyValue(value) && !rule.required) {
        return callback();
      }
      rules.required(rule, value, source, errors, options2);
      if (value !== void 0) {
        rules[ENUM](rule, value, source, errors, options2);
      }
    }
    callback(errors);
  };
  var pattern2 = function pattern3(rule, value, callback, source, options2) {
    var errors = [];
    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
    if (validate) {
      if (isEmptyValue(value, "string") && !rule.required) {
        return callback();
      }
      rules.required(rule, value, source, errors, options2);
      if (!isEmptyValue(value, "string")) {
        rules.pattern(rule, value, source, errors, options2);
      }
    }
    callback(errors);
  };
  var date2 = function date3(rule, value, callback, source, options2) {
    var errors = [];
    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
    if (validate) {
      if (isEmptyValue(value, "date") && !rule.required) {
        return callback();
      }
      rules.required(rule, value, source, errors, options2);
      if (!isEmptyValue(value, "date")) {
        var dateObject;
        if (value instanceof Date) {
          dateObject = value;
        } else {
          dateObject = new Date(value);
        }
        rules.type(rule, dateObject, source, errors, options2);
        if (dateObject) {
          rules.range(rule, dateObject.getTime(), source, errors, options2);
        }
      }
    }
    callback(errors);
  };
  var required2 = function required3(rule, value, callback, source, options2) {
    var errors = [];
    var type4 = Array.isArray(value) ? "array" : typeof value;
    rules.required(rule, value, source, errors, options2, type4);
    callback(errors);
  };
  var type2 = function type3(rule, value, callback, source, options2) {
    var ruleType = rule.type;
    var errors = [];
    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
    if (validate) {
      if (isEmptyValue(value, ruleType) && !rule.required) {
        return callback();
      }
      rules.required(rule, value, source, errors, options2, ruleType);
      if (!isEmptyValue(value, ruleType)) {
        rules.type(rule, value, source, errors, options2);
      }
    }
    callback(errors);
  };
  var any = function any2(rule, value, callback, source, options2) {
    var errors = [];
    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
    if (validate) {
      if (isEmptyValue(value) && !rule.required) {
        return callback();
      }
      rules.required(rule, value, source, errors, options2);
    }
    callback(errors);
  };
  var validators = {
    string,
    method: method2,
    number: number2,
    "boolean": _boolean,
    regexp: regexp2,
    integer: integer2,
    "float": floatFn,
    array: array2,
    object: object2,
    "enum": enumerable2,
    pattern: pattern2,
    date: date2,
    url: type2,
    hex: type2,
    email: type2,
    required: required2,
    any
  };
  function newMessages() {
    return {
      "default": "Validation error on field %s",
      required: "%s is required",
      "enum": "%s must be one of %s",
      whitespace: "%s cannot be empty",
      date: {
        format: "%s date %s is invalid for format %s",
        parse: "%s date could not be parsed, %s is invalid ",
        invalid: "%s date %s is invalid"
      },
      types: {
        string: "%s is not a %s",
        method: "%s is not a %s (function)",
        array: "%s is not an %s",
        object: "%s is not an %s",
        number: "%s is not a %s",
        date: "%s is not a %s",
        "boolean": "%s is not a %s",
        integer: "%s is not an %s",
        "float": "%s is not a %s",
        regexp: "%s is not a valid %s",
        email: "%s is not a valid %s",
        url: "%s is not a valid %s",
        hex: "%s is not a valid %s"
      },
      string: {
        len: "%s must be exactly %s characters",
        min: "%s must be at least %s characters",
        max: "%s cannot be longer than %s characters",
        range: "%s must be between %s and %s characters"
      },
      number: {
        len: "%s must equal %s",
        min: "%s cannot be less than %s",
        max: "%s cannot be greater than %s",
        range: "%s must be between %s and %s"
      },
      array: {
        len: "%s must be exactly %s in length",
        min: "%s cannot be less than %s in length",
        max: "%s cannot be greater than %s in length",
        range: "%s must be between %s and %s in length"
      },
      pattern: {
        mismatch: "%s value %s does not match pattern %s"
      },
      clone: function clone2() {
        var cloned = JSON.parse(JSON.stringify(this));
        cloned.clone = this.clone;
        return cloned;
      }
    };
  }
  var messages = newMessages();
  var Schema = /* @__PURE__ */ function() {
    function Schema2(descriptor) {
      this.rules = null;
      this._messages = messages;
      this.define(descriptor);
    }
    var _proto = Schema2.prototype;
    _proto.define = function define2(rules2) {
      var _this = this;
      if (!rules2) {
        throw new Error("Cannot configure a schema with no rules");
      }
      if (typeof rules2 !== "object" || Array.isArray(rules2)) {
        throw new Error("Rules must be an object");
      }
      this.rules = {};
      Object.keys(rules2).forEach(function(name) {
        var item = rules2[name];
        _this.rules[name] = Array.isArray(item) ? item : [item];
      });
    };
    _proto.messages = function messages2(_messages) {
      if (_messages) {
        this._messages = deepMerge(newMessages(), _messages);
      }
      return this._messages;
    };
    _proto.validate = function validate(source_, o, oc) {
      var _this2 = this;
      if (o === void 0) {
        o = {};
      }
      if (oc === void 0) {
        oc = function oc2() {
        };
      }
      var source = source_;
      var options2 = o;
      var callback = oc;
      if (typeof options2 === "function") {
        callback = options2;
        options2 = {};
      }
      if (!this.rules || Object.keys(this.rules).length === 0) {
        if (callback) {
          callback(null, source);
        }
        return Promise.resolve(source);
      }
      function complete(results) {
        var errors = [];
        var fields = {};
        function add(e) {
          if (Array.isArray(e)) {
            var _errors;
            errors = (_errors = errors).concat.apply(_errors, e);
          } else {
            errors.push(e);
          }
        }
        for (var i2 = 0; i2 < results.length; i2++) {
          add(results[i2]);
        }
        if (!errors.length) {
          callback(null, source);
        } else {
          fields = convertFieldsError(errors);
          callback(errors, fields);
        }
      }
      if (options2.messages) {
        var messages$1 = this.messages();
        if (messages$1 === messages) {
          messages$1 = newMessages();
        }
        deepMerge(messages$1, options2.messages);
        options2.messages = messages$1;
      } else {
        options2.messages = this.messages();
      }
      var series = {};
      var keys = options2.keys || Object.keys(this.rules);
      keys.forEach(function(z) {
        var arr = _this2.rules[z];
        var value = source[z];
        arr.forEach(function(r) {
          var rule = r;
          if (typeof rule.transform === "function") {
            if (source === source_) {
              source = _extends({}, source);
            }
            value = source[z] = rule.transform(value);
          }
          if (typeof rule === "function") {
            rule = {
              validator: rule
            };
          } else {
            rule = _extends({}, rule);
          }
          rule.validator = _this2.getValidationMethod(rule);
          if (!rule.validator) {
            return;
          }
          rule.field = z;
          rule.fullField = rule.fullField || z;
          rule.type = _this2.getType(rule);
          series[z] = series[z] || [];
          series[z].push({
            rule,
            value,
            source,
            field: z
          });
        });
      });
      var errorFields = {};
      return asyncMap(series, options2, function(data, doIt) {
        var rule = data.rule;
        var deep = (rule.type === "object" || rule.type === "array") && (typeof rule.fields === "object" || typeof rule.defaultField === "object");
        deep = deep && (rule.required || !rule.required && data.value);
        rule.field = data.field;
        function addFullField(key, schema) {
          return _extends({}, schema, {
            fullField: rule.fullField + "." + key,
            fullFields: rule.fullFields ? [].concat(rule.fullFields, [key]) : [key]
          });
        }
        function cb(e) {
          if (e === void 0) {
            e = [];
          }
          var errorList = Array.isArray(e) ? e : [e];
          if (!options2.suppressWarning && errorList.length) {
            Schema2.warning("async-validator:", errorList);
          }
          if (errorList.length && rule.message !== void 0) {
            errorList = [].concat(rule.message);
          }
          var filledErrors = errorList.map(complementError(rule, source));
          if (options2.first && filledErrors.length) {
            errorFields[rule.field] = 1;
            return doIt(filledErrors);
          }
          if (!deep) {
            doIt(filledErrors);
          } else {
            if (rule.required && !data.value) {
              if (rule.message !== void 0) {
                filledErrors = [].concat(rule.message).map(complementError(rule, source));
              } else if (options2.error) {
                filledErrors = [options2.error(rule, format(options2.messages.required, rule.field))];
              }
              return doIt(filledErrors);
            }
            var fieldsSchema = {};
            if (rule.defaultField) {
              Object.keys(data.value).map(function(key) {
                fieldsSchema[key] = rule.defaultField;
              });
            }
            fieldsSchema = _extends({}, fieldsSchema, data.rule.fields);
            var paredFieldsSchema = {};
            Object.keys(fieldsSchema).forEach(function(field) {
              var fieldSchema = fieldsSchema[field];
              var fieldSchemaList = Array.isArray(fieldSchema) ? fieldSchema : [fieldSchema];
              paredFieldsSchema[field] = fieldSchemaList.map(addFullField.bind(null, field));
            });
            var schema = new Schema2(paredFieldsSchema);
            schema.messages(options2.messages);
            if (data.rule.options) {
              data.rule.options.messages = options2.messages;
              data.rule.options.error = options2.error;
            }
            schema.validate(data.value, data.rule.options || options2, function(errs) {
              var finalErrors = [];
              if (filledErrors && filledErrors.length) {
                finalErrors.push.apply(finalErrors, filledErrors);
              }
              if (errs && errs.length) {
                finalErrors.push.apply(finalErrors, errs);
              }
              doIt(finalErrors.length ? finalErrors : null);
            });
          }
        }
        var res;
        if (rule.asyncValidator) {
          res = rule.asyncValidator(rule, data.value, cb, data.source, options2);
        } else if (rule.validator) {
          try {
            res = rule.validator(rule, data.value, cb, data.source, options2);
          } catch (error) {
            console.error == null ? void 0 : console.error(error);
            if (!options2.suppressValidatorError) {
              setTimeout(function() {
                throw error;
              }, 0);
            }
            cb(error.message);
          }
          if (res === true) {
            cb();
          } else if (res === false) {
            cb(typeof rule.message === "function" ? rule.message(rule.fullField || rule.field) : rule.message || (rule.fullField || rule.field) + " fails");
          } else if (res instanceof Array) {
            cb(res);
          } else if (res instanceof Error) {
            cb(res.message);
          }
        }
        if (res && res.then) {
          res.then(function() {
            return cb();
          }, function(e) {
            return cb(e);
          });
        }
      }, function(results) {
        complete(results);
      }, source);
    };
    _proto.getType = function getType(rule) {
      if (rule.type === void 0 && rule.pattern instanceof RegExp) {
        rule.type = "pattern";
      }
      if (typeof rule.validator !== "function" && rule.type && !validators.hasOwnProperty(rule.type)) {
        throw new Error(format("Unknown rule type %s", rule.type));
      }
      return rule.type || "string";
    };
    _proto.getValidationMethod = function getValidationMethod(rule) {
      if (typeof rule.validator === "function") {
        return rule.validator;
      }
      var keys = Object.keys(rule);
      var messageIndex = keys.indexOf("message");
      if (messageIndex !== -1) {
        keys.splice(messageIndex, 1);
      }
      if (keys.length === 1 && keys[0] === "required") {
        return validators.required;
      }
      return validators[this.getType(rule)] || void 0;
    };
    return Schema2;
  }();
  Schema.register = function register(type4, validator) {
    if (typeof validator !== "function") {
      throw new Error("Cannot register a validator by type, validator is not a function");
    }
    validators[type4] = validator;
  };
  Schema.warning = warning;
  Schema.messages = messages;
  Schema.validators = validators;
  function merge(...items) {
    return _merge(items[0] === true, false, items);
  }
  function recursive(...items) {
    return _merge(items[0] === true, true, items);
  }
  function clone(input) {
    if (Array.isArray(input)) {
      const output = [];
      for (let index = 0; index < input.length; ++index)
        output.push(clone(input[index]));
      return output;
    }
    if (isPlainObject(input)) {
      const output = {};
      for (const index in input) output[index] = clone(input[index]);
      return output;
    }
    return input;
  }
  function isPlainObject(input) {
    if (input === null || typeof input !== "object") return false;
    if (Object.getPrototypeOf(input) === null) return true;
    let ref = input;
    while (Object.getPrototypeOf(ref) !== null) ref = Object.getPrototypeOf(ref);
    return Object.getPrototypeOf(input) === ref;
  }
  function _recursiveMerge(base, extend) {
    if (!isPlainObject(base) || !isPlainObject(extend)) return extend;
    for (const key in extend) {
      if (key === "__proto__" || key === "constructor" || key === "prototype")
        continue;
      base[key] = isPlainObject(base[key]) && isPlainObject(extend[key]) ? _recursiveMerge(base[key], extend[key]) : extend[key];
    }
    return base;
  }
  function _merge(isClone, isRecursive, items) {
    let result;
    if (isClone || !isPlainObject(result = items.shift())) result = {};
    for (let index = 0; index < items.length; ++index) {
      const item = items[index];
      if (!isPlainObject(item)) continue;
      for (const key in item) {
        if (key === "__proto__" || key === "constructor" || key === "prototype")
          continue;
        const value = isClone ? clone(item[key]) : item[key];
        result[key] = isRecursive ? _recursiveMerge(result[key], value) : value;
      }
    }
    return result;
  }
  const SECRET = "NUT_FORM_INTERNAL";
  class FormStore {
    constructor() {
      this.initialValues = {};
      this.updateList = [];
      this.store = {};
      this.fieldEntities = [];
      this.callbacks = {};
      this.errors = {};
      this.registerField = (field) => {
        this.fieldEntities.push(field);
        return () => {
          this.fieldEntities = this.fieldEntities.filter((item) => item !== field);
        };
      };
      this.getFieldValue = (name) => {
        var _a;
        return (_a = this.store) == null ? void 0 : _a[name];
      };
      this.getFieldsValue = (nameList) => {
        if (typeof nameList === "boolean") {
          return JSON.parse(JSON.stringify(this.store));
        }
        const fieldsValue = {};
        nameList.forEach((field) => {
          fieldsValue[field] = this.getFieldValue(field);
        });
        return fieldsValue;
      };
      this.setInitialValues = (initialValues, init) => {
        this.initialValues = initialValues || {};
        if (init) {
          const nextStore = merge(initialValues, this.store);
          this.updateStore(nextStore);
          this.notifyWatch();
        }
      };
      this.setFieldsValue = (newStore) => {
        const nextStore = recursive(true, this.store, newStore);
        this.updateStore(nextStore);
        this.fieldEntities.forEach((entity) => {
          const { name } = entity.props;
          Object.keys(newStore).forEach((key) => {
            if (key === name) {
              entity.onStoreChange("update");
            }
          });
        });
        this.updateList.forEach((item) => {
          let shouldUpdate = item.condition;
          if (typeof item.condition === "function") {
            shouldUpdate = item.condition();
          }
          if (shouldUpdate) {
            item.entity.onStoreChange("update");
          }
        });
        this.notifyWatch();
      };
      this.setFieldValue = (name, value) => {
        const store = {
          [name]: value
        };
        this.setFieldsValue(store);
        this.notifyWatch([name]);
      };
      this.setCallback = (callback) => {
        this.callbacks = {
          ...this.callbacks,
          ...callback
        };
      };
      this.validateEntities = async (entity, errs) => {
        var _a;
        const { name, rules: rules2 = [] } = entity.props;
        if (!name) {
          console.warn("Form field missing name property");
          return;
        }
        const descriptor = {};
        if (rules2.length) {
          if (rules2.length > 1) {
            descriptor[name] = [];
            rules2.forEach((v) => {
              descriptor[name].push(v);
            });
          } else {
            descriptor[name] = rules2[0];
          }
        }
        const validator = new Schema(descriptor);
        try {
          await validator.validate({ [name]: (_a = this.store) == null ? void 0 : _a[name] });
        } catch ({ errors }) {
          if (errors) {
            errs.push(...errors);
            this.errors[name] = errors;
          }
        } finally {
          if (!errs || errs.length === 0) {
            this.errors[name] = [];
          }
        }
        entity.onStoreChange("validate");
      };
      this.validateFields = async (nameList) => {
        let filterEntities = [];
        if (!nameList || nameList.length === 0) {
          filterEntities = this.fieldEntities;
        } else {
          filterEntities = this.fieldEntities.filter(
            ({ props: { name } }) => nameList.includes(name)
          );
        }
        const errs = [];
        await Promise.all(
          filterEntities.map(async (entity) => {
            await this.validateEntities(entity, errs);
          })
        );
        return errs;
      };
      this.submit = async () => {
        var _a, _b, _c, _d;
        const errors = await this.validateFields();
        if (errors.length === 0) {
          (_b = (_a = this.callbacks).onFinish) == null ? void 0 : _b.call(_a, this.store);
        } else if (errors.length > 0) {
          (_d = (_c = this.callbacks).onFinishFailed) == null ? void 0 : _d.call(_c, this.store, errors);
        }
      };
      this.resetFields = (namePaths) => {
        if (namePaths && namePaths.length) {
          namePaths.forEach((path) => {
            this.errors[path] = null;
            this.fieldEntities.forEach((entity) => {
              const name = entity.props.name;
              if (name === path) {
                if (path in this.initialValues) {
                  this.updateStore({ [path]: this.initialValues[path] });
                } else {
                  delete this.store[path];
                }
                entity.onStoreChange("reset");
              }
            });
          });
        } else {
          const nextStore = merge({}, this.initialValues);
          this.updateStore(nextStore);
          this.fieldEntities.forEach((entity) => {
            entity.onStoreChange("reset");
          });
        }
      };
      this.registerUpdate = (field, shouldUpdate) => {
        this.updateList.push({
          entity: field,
          condition: shouldUpdate
        });
        return () => {
          this.updateList = this.updateList.filter((i2) => i2.entity !== field);
        };
      };
      this.dispatch = ({ name }) => {
        this.validateFields([name]);
      };
      this.getInternal = (key) => {
        if (key === SECRET) {
          return {
            registerField: this.registerField,
            setCallback: this.setCallback,
            setInitialValues: this.setInitialValues,
            dispatch: this.dispatch,
            store: this.store,
            fieldEntities: this.fieldEntities,
            registerUpdate: this.registerUpdate,
            registerWatch: this.registerWatch
          };
        }
      };
      this.getForm = () => {
        return {
          getFieldValue: this.getFieldValue,
          getFieldsValue: this.getFieldsValue,
          setFieldsValue: this.setFieldsValue,
          setFieldValue: this.setFieldValue,
          resetFields: this.resetFields,
          validateFields: this.validateFields,
          submit: this.submit,
          errors: this.errors,
          getInternal: this.getInternal
        };
      };
      this.watchList = [];
      this.registerWatch = (callback) => {
        this.watchList.push(callback);
        return () => {
          this.watchList = this.watchList.filter((fn) => fn !== callback);
        };
      };
      this.notifyWatch = (namePath = []) => {
        if (this.watchList.length) {
          let allValues;
          if (!namePath || namePath.length === 0) {
            allValues = this.getFieldsValue(true);
          } else {
            allValues = this.getFieldsValue(namePath);
          }
          this.watchList.forEach((callback) => {
            callback(allValues, namePath);
          });
        }
      };
      this.callbacks = {
        onFinish: () => {
        },
        onFinishFailed: () => {
        }
      };
    }
    updateStore(nextStore) {
      this.store = nextStore;
    }
  }
  const useForm = (form) => {
    const formRef = React.useRef();
    if (!formRef.current) {
      if (form) {
        formRef.current = form;
      } else {
        const formStore = new FormStore();
        formRef.current = formStore.getForm();
      }
    }
    return [formRef.current];
  };
  const useWatch = (path, form) => {
    const formInstance = form.getInternal(SECRET);
    const [value, setValue] = React.useState();
    React.useEffect(() => {
      const unsubscribe = formInstance.registerWatch(
        (data, namePath) => {
          const value2 = data[path];
          setValue(value2);
        }
      );
      const initialValue = form.getFieldsValue(true);
      if (value !== initialValue[path]) {
        setValue(initialValue[path]);
      }
      return () => unsubscribe();
    }, [form]);
    return value;
  };
  const defaultProps$X = {
    ...ComponentDefaults,
    labelPosition: "right",
    starPosition: "left",
    disabled: false,
    divider: false,
    validateTrigger: "onChange",
    onFinish: (values) => {
    },
    onFinishFailed: (values, errorFields) => {
    }
  };
  const PositionInfo = {
    top: "form-layout-top",
    left: "form-layout-left",
    right: "form-layout-right"
  };
  const Form = React.forwardRef(
    (props, ref) => {
      const classPrefix2 = "nut-form";
      const {
        className,
        style,
        footer,
        children,
        initialValues,
        divider,
        disabled,
        onFinish,
        onFinishFailed,
        validateTrigger,
        labelPosition,
        starPosition,
        form
      } = {
        ...defaultProps$X,
        ...props
      };
      let formInstance;
      if (form !== void 0) {
        formInstance = form;
      } else {
        [formInstance] = useForm();
      }
      React.useImperativeHandle(ref, () => formInstance);
      formInstance.starPosition = starPosition;
      const { submit, resetFields } = formInstance;
      const { setCallback, setInitialValues } = formInstance.getInternal(SECRET);
      setCallback({
        onFinish,
        onFinishFailed
      });
      const mountRef = React.useRef(false);
      setInitialValues(initialValues, !mountRef.current);
      if (!mountRef.current) {
        mountRef.current = true;
      }
      return /* @__PURE__ */ React.createElement(
        "form",
        {
          className: classNames(
            classPrefix2,
            PositionInfo[labelPosition],
            className
          ),
          style,
          onSubmit: (e) => {
            e.preventDefault();
            e.stopPropagation();
            submit();
          },
          onReset: (e) => {
            e.preventDefault();
            e.stopPropagation();
            resetFields();
          }
        },
        /* @__PURE__ */ React.createElement(Cell.Group, { divider }, /* @__PURE__ */ React.createElement(
          Context.Provider,
          {
            value: { formInstance, labelPosition, disabled, validateTrigger }
          },
          children
        ), footer ? /* @__PURE__ */ React.createElement(Cell, { className: `${classPrefix2}-footer` }, footer) : null)
      );
    }
  );
  Form.displayName = "NutForm";
  function isForwardRefComponent(component) {
    return component.type && component.type.$$typeof && // eslint-disable-next-line react/display-name
    React.forwardRef(
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      () => {
      }
    ).$$typeof === component.type.$$typeof;
  }
  function toArray(value) {
    if (value === void 0 || value === null) {
      return [];
    }
    return Array.isArray(value) ? value : [value];
  }
  const defaultProps$W = {
    ...ComponentDefaults,
    required: false,
    name: "",
    label: "",
    rules: [{ required: false, message: "" }],
    errorMessageAlign: "left",
    shouldUpdate: false,
    noStyle: false
  };
  const _FormItem = class _FormItem extends React.Component {
    constructor(props) {
      super(props);
      this.getControlled = (children) => {
        var _a;
        const { setFieldsValue, getFieldValue } = this.context.formInstance;
        const { dispatch } = this.context.formInstance.getInternal(SECRET);
        const { name = "" } = this.props;
        if ((_a = children == null ? void 0 : children.props) == null ? void 0 : _a.defaultValue) ;
        const fieldValue = getFieldValue(name);
        const controlled = {
          ...children.props,
          className: children.props.className,
          [this.props.valuePropName || "value"]: fieldValue !== void 0 ? fieldValue : this.props.initialValue,
          [this.props.trigger || "onChange"]: (...args) => {
            const originOnChange = children.props[this.props.trigger || "onChange"];
            if (originOnChange) {
              originOnChange(...args);
            }
            let [next] = args;
            if (this.props.getValueFromEvent) {
              next = this.props.getValueFromEvent(...args);
            }
            setFieldsValue({ [name]: next });
          }
        };
        const { validateTrigger } = this.props;
        const mergedValidateTrigger = validateTrigger || this.context.validateTrigger;
        const validateTriggers = toArray(mergedValidateTrigger);
        validateTriggers.forEach((trigger) => {
          const originTrigger = controlled[trigger];
          controlled[trigger] = (...args) => {
            if (originTrigger) {
              originTrigger(...args);
            }
            if (this.props.rules && this.props.rules.length) {
              dispatch({
                name: this.props.name
              });
            }
          };
        });
        if (isForwardRefComponent(children)) {
          controlled.ref = (componentInstance) => {
            const originRef = children.ref;
            if (originRef) {
              if (typeof originRef === "function") {
                originRef(componentInstance);
              }
              if ("current" in originRef) {
                originRef.current = componentInstance;
              }
            }
            this.componentRef = componentInstance;
          };
        }
        return controlled;
      };
      this.refresh = () => {
        this.setState(({ resetCount }) => ({
          resetCount: resetCount + 1
        }));
      };
      this.onStoreChange = (type) => {
        if (type === "reset") {
          this.context.formInstance.errors[this.props.name] = [];
          this.refresh();
        } else {
          this.forceUpdate();
        }
      };
      this.renderLayout = (childNode) => {
        const {
          label,
          name,
          required,
          rules: rules2,
          className,
          style,
          errorMessageAlign,
          align
        } = {
          ...defaultProps$W,
          ...this.props
        };
        const requiredInRules = rules2 == null ? void 0 : rules2.some((rule) => rule.required);
        const item = name ? this.context.formInstance.errors[name] : [];
        const { starPosition } = this.context.formInstance;
        const renderStar = (required || requiredInRules) && /* @__PURE__ */ React.createElement("div", { className: "nut-form-item-label-required required" }, "*");
        const renderLabel = /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement("span", { className: "nut-form-item-labeltxt" }, starPosition === "left" ? renderStar : null, label), starPosition === "right" ? renderStar : null);
        return /* @__PURE__ */ React.createElement(
          Cell,
          {
            className: `${this.getClassNameWithDirection("nut-form-item")} ${className}`,
            style,
            align,
            onClick: (e) => this.props.onClick && this.props.onClick(e, this.componentRef)
          },
          label ? /* @__PURE__ */ React.createElement(
            "div",
            {
              className: `nut-cell-title ${this.getClassNameWithDirection("nut-form-item-label")}`
            },
            renderLabel
          ) : null,
          /* @__PURE__ */ React.createElement(
            "div",
            {
              className: `nut-cell-value ${this.getClassNameWithDirection("nut-form-item-body")}`
            },
            /* @__PURE__ */ React.createElement("div", { className: "nut-form-item-body-slots" }, childNode),
            item && item.length > 0 && /* @__PURE__ */ React.createElement(
              "div",
              {
                className: "nut-form-item-body-tips",
                style: { textAlign: errorMessageAlign }
              },
              item[0].message
            )
          )
        );
      };
      this.componentRef = React.createRef();
      this.state = {
        resetCount: 1
      };
    }
    componentDidMount() {
      const { store = {}, setInitialValues } = this.context.formInstance.getInternal(SECRET);
      if (this.props.initialValue && this.props.name && !Object.keys(store).includes(this.props.name)) {
        setInitialValues(
          { ...store, [this.props.name]: this.props.initialValue },
          true
        );
      }
      const { registerField, registerUpdate } = this.context.formInstance.getInternal(SECRET);
      this.cancelRegister = registerField(this);
      this.eventOff = registerUpdate(this, this.props.shouldUpdate);
    }
    componentWillUnmount() {
      if (this.cancelRegister) {
        this.cancelRegister();
      }
      if (this.eventOff) {
        this.eventOff();
      }
    }
    getClassNameWithDirection(className) {
      if (className && this.context.labelPosition) {
        return `${className} ${className}-${this.context.labelPosition}`;
      }
      return className;
    }
    render() {
      const { children } = this.props;
      const child = Array.isArray(children) ? children[0] : children;
      let returnChildNode;
      if (!this.props.shouldUpdate) {
        returnChildNode = React.cloneElement(
          child,
          this.getControlled(child)
        );
      } else {
        returnChildNode = child(this.context.formInstance);
      }
      return /* @__PURE__ */ React.createElement(React.Fragment, { key: this.state.resetCount }, /* @__PURE__ */ React.createElement("div", { className: this.context.disabled ? "nut-form-item-disabled" : "" }, this.props.noStyle ? returnChildNode : this.renderLayout(returnChildNode)));
    }
  };
  _FormItem.defaultProps = defaultProps$W;
  _FormItem.contextType = Context;
  let FormItem = _FormItem;
  const InnerForm = Form;
  InnerForm.Item = FormItem;
  InnerForm.useForm = useForm;
  InnerForm.useWatch = useWatch;
  function trimExtraChar(value, char, regExp) {
    const index = value.indexOf(char);
    if (index === -1) {
      return value;
    }
    if (char === "-" && index !== 0) {
      return value.slice(0, index);
    }
    return value.slice(0, index + 1) + value.slice(index).replace(regExp, "");
  }
  function formatNumber(value, allowDot = true, allowMinus = true) {
    if (allowDot) {
      value = trimExtraChar(value, ".", /\./g);
    } else {
      value = value.split(".")[0];
    }
    if (allowMinus) {
      value = trimExtraChar(value, "-", /-/g);
    } else {
      value = value.replace(/-/, "");
    }
    const regExp = allowDot ? /[^-0-9.]/g : /[^-0-9]/g;
    return value.replace(regExp, "");
  }
  const defaultProps$V = {
    ...ComponentDefaults,
    type: "text",
    name: "",
    placeholder: void 0,
    confirmType: "done",
    align: "left",
    required: false,
    disabled: false,
    readOnly: false,
    maxLength: 9999,
    clearable: false,
    clearIcon: null,
    formatTrigger: "onChange",
    autoFocus: false
  };
  const Input = React.forwardRef(
    (props, ref) => {
      const rtl = useRtl();
      const { locale } = useConfig();
      const {
        type,
        name,
        placeholder,
        align,
        disabled,
        readOnly,
        maxLength,
        clearable,
        clearIcon,
        formatTrigger,
        autoFocus,
        style,
        className,
        onChange,
        onFocus,
        onClear,
        formatter,
        onClick,
        confirmType,
        defaultValue,
        value: _value,
        onCompositionStart,
        onCompositionEnd,
        ...rest
      } = {
        ...defaultProps$V,
        ...props
      };
      const [value, setValue] = usePropsValue({
        value: _value,
        defaultValue,
        finalValue: "",
        onChange
      });
      const inputRef = React.useRef(null);
      const composingRef = React.useRef(false);
      const [active, setActive] = React.useState(false);
      React.useImperativeHandle(ref, () => {
        return {
          clear: () => {
            setValue("");
          },
          focus: () => {
            var _a;
            (_a = inputRef.current) == null ? void 0 : _a.focus();
          },
          blur: () => {
            var _a;
            (_a = inputRef.current) == null ? void 0 : _a.blur();
          },
          get nativeElement() {
            return inputRef.current;
          }
        };
      });
      const inputClass = React.useCallback(() => {
        const classPrefix2 = "nut-input";
        return [classPrefix2, `${disabled ? `${classPrefix2}-disabled` : ""}`].filter(Boolean).join(" ");
      }, [disabled]);
      const updateValue = (value2, trigger = "onChange") => {
        let val = value2;
        if (type === "number") {
          val = formatNumber(val, false, true);
        }
        if (type === "digit") {
          val = formatNumber(val, true, true);
        }
        if (formatter && trigger === formatTrigger) {
          val = formatter(val);
        }
        setValue(val);
        const eventHandler = props[trigger];
        if (eventHandler && typeof eventHandler === "function" && trigger !== "onChange") {
          eventHandler(val);
        }
      };
      const handleFocus = (event) => {
        const val = event.target.value;
        onFocus && onFocus(val);
        setActive(true);
      };
      const handleInput = (value2) => {
        updateValue(value2, "onChange");
      };
      const handleBlur = (event) => {
        const val = event.target.value;
        updateValue(val, "onBlur");
        setTimeout(() => {
          setActive(false);
        }, 200);
      };
      const inputType = (type22) => {
        if (type22 === "digit") {
          return "text";
        }
        if (type22 === "number") {
          return "tel";
        }
        return type22;
      };
      return /* @__PURE__ */ React.createElement(
        "div",
        {
          className: `${inputClass()}  ${className || ""}`,
          style,
          onClick: (e) => {
            onClick && onClick(e);
          }
        },
        /* @__PURE__ */ React.createElement(
          "input",
          {
            ...rest,
            name,
            className: "nut-input-native",
            ref: inputRef,
            style: {
              // eslint-disable-next-line no-nested-ternary
              textAlign: rtl ? (
                // eslint-disable-next-line no-nested-ternary
                align === "right" ? (
                  // eslint-disable-next-line no-nested-ternary
                  "left"
                ) : align === "left" ? "right" : "center"
              ) : align
            },
            type: inputType(type),
            maxLength,
            placeholder: placeholder === void 0 ? locale.placeholder : placeholder,
            disabled,
            readOnly,
            value,
            autoFocus,
            enterKeyHint: confirmType,
            onBlur: (e) => {
              handleBlur(e);
            },
            onFocus: (e) => {
              handleFocus(e);
            },
            onChange: (e) => {
              handleInput(e.currentTarget.value);
            },
            onCompositionStart: (e) => {
              composingRef.current = true;
              onCompositionStart == null ? void 0 : onCompositionStart(e);
            },
            onCompositionEnd: (e) => {
              composingRef.current = false;
              onCompositionEnd == null ? void 0 : onCompositionEnd(e);
            }
          }
        ),
        clearable && !readOnly && active && value.length > 0 ? /* @__PURE__ */ React.createElement(
          "span",
          {
            style: { display: "flex", alignItems: "center", cursor: "pointer" },
            onClick: () => {
              if (!disabled) {
                setValue("");
                onClear && onClear("");
              }
            }
          },
          clearIcon || /* @__PURE__ */ React.createElement(i$3, { className: "nut-input-clear" })
        ) : null
      );
    }
  );
  Input.displayName = "NutInput";
  const defaultProps$U = {
    ...ComponentDefaults,
    disabled: false,
    readOnly: false,
    allowEmpty: false,
    min: 1,
    max: 9999,
    step: 1,
    digits: 0,
    async: false,
    select: true
  };
  const classPrefix$g = `nut-inputnumber`;
  const InputNumber = (props) => {
    const {
      children,
      disabled,
      min,
      max,
      readOnly,
      value,
      defaultValue,
      allowEmpty,
      digits,
      step,
      async,
      select,
      className,
      style,
      formatter,
      onPlus,
      onMinus,
      onOverlimit,
      onBlur,
      onFocus,
      onChange,
      ...restProps
    } = {
      ...defaultProps$U,
      ...props
    };
    const classes = classNames(classPrefix$g, className, {
      [`${classPrefix$g}-disabled`]: disabled
    });
    const [focused, setFocused] = React.useState(false);
    const inputRef = React.useRef(null);
    React.useEffect(() => {
      var _a, _b;
      if (select && focused) {
        (_b = (_a = inputRef.current) == null ? void 0 : _a.select) == null ? void 0 : _b.call(_a);
      }
    }, [select, focused]);
    const [shadowValue, setShadowValue] = usePropsValue({
      value: typeof value === "string" ? parseFloat(value) : value,
      defaultValue: typeof defaultValue === "string" ? parseFloat(defaultValue) : defaultValue,
      finalValue: 0,
      onChange: (value2) => {
      }
    });
    const bound2 = (value2, min2, max2) => {
      let res = value2;
      if (min2 !== void 0) {
        res = Math.max(Number(min2), res);
      }
      if (max2 !== void 0) {
        res = Math.min(Number(max2), res);
      }
      return res;
    };
    const format2 = (value2) => {
      if (value2 === null) return "";
      if (typeof value2 === "string") value2 = parseFloat(value2);
      const fixedValue = bound2(value2, Number(min), Number(max));
      if (formatter) {
        return formatter(fixedValue);
      }
      if (digits) {
        return fixedValue.toFixed(digits).toString();
      }
      return fixedValue.toString();
    };
    const [inputValue, setInputValue] = React.useState(format2(shadowValue));
    React.useEffect(() => {
      if (!focused && !async) {
        setShadowValue(bound2(Number(shadowValue), Number(min), Number(max)));
        setInputValue(format2(shadowValue));
      }
    }, [focused, shadowValue]);
    React.useEffect(() => {
      if (async) {
        setShadowValue(bound2(Number(value), Number(min), Number(max)));
        setInputValue(format2(value));
      }
    }, [value]);
    const calcNextValue = (current, step2, symbol) => {
      const dig = digits + 1;
      return (parseFloat(current || "0") * dig + parseFloat(step2) * dig * symbol) / dig;
    };
    const update2 = (negative, e) => {
      if (step !== void 0) {
        const shouldOverBoundary = calcNextValue(
          shadowValue,
          step,
          negative ? -1 : 1
        );
        const nextValue = bound2(shouldOverBoundary, Number(min), Number(max));
        setShadowValue(nextValue);
        if (negative ? shouldOverBoundary < Number(min) : shouldOverBoundary > Number(max)) {
          onOverlimit == null ? void 0 : onOverlimit(e);
        } else {
          onChange == null ? void 0 : onChange(nextValue, e);
        }
      }
    };
    const handleReduce = (e) => {
      if (disabled) return;
      onMinus == null ? void 0 : onMinus(e);
      update2(true, e);
    };
    const handlePlus = (e) => {
      if (disabled) return;
      onPlus == null ? void 0 : onPlus(e);
      update2(false, e);
    };
    const parseValue = (text) => {
      if (text === "") return null;
      if (text === "-") return null;
      return text;
    };
    const clampValue = (valueStr) => {
      if (valueStr === null) return defaultValue;
      const val = Number(parseFloat(valueStr || "0").toFixed(digits));
      return Math.max(Number(min), Math.min(Number(max), val));
    };
    const handleValueChange = (valueStr, e) => {
      const val = clampValue(valueStr);
      if (val !== Number(shadowValue)) {
        onChange == null ? void 0 : onChange(val, e);
      }
    };
    const handleInputChange = (e) => {
      setInputValue(e.target.value);
      const valueStr = parseValue(e.target.value);
      if (valueStr === null) {
        if (allowEmpty) {
          setShadowValue(null);
        } else {
          setShadowValue(defaultValue);
        }
      } else {
        setShadowValue(clampValue(valueStr));
      }
      !async && handleValueChange(valueStr, e);
    };
    const handleFocus = (e) => {
      setFocused(true);
      setInputValue(
        shadowValue !== void 0 && shadowValue !== null ? bound2(Number(shadowValue), Number(min), Number(max)).toString() : ""
      );
      onFocus == null ? void 0 : onFocus(e);
    };
    const handleBlur = (e) => {
      setFocused(false);
      onBlur == null ? void 0 : onBlur(e);
      const valueStr = parseValue(e.target.value);
      if (valueStr === null) {
        if (allowEmpty) {
          setShadowValue(null);
        } else {
          setShadowValue(defaultValue);
        }
      } else {
        setShadowValue(clampValue(valueStr));
      }
      async && handleValueChange(valueStr, e);
    };
    return /* @__PURE__ */ React.createElement("div", { className: classes, style, ...restProps }, /* @__PURE__ */ React.createElement("div", { className: "nut-input-minus", onClick: handleReduce }, /* @__PURE__ */ React.createElement(
      n$1,
      {
        className: classNames("nut-inputnumber-icon icon-minus", {
          [`${classPrefix$g}-icon-disabled`]: shadowValue === min || disabled
        })
      }
    )), /* @__PURE__ */ React.createElement(
      "input",
      {
        ref: inputRef,
        inputMode: "decimal",
        disabled,
        readOnly,
        value: inputValue,
        onInput: handleInputChange,
        onBlur: handleBlur,
        onFocus: handleFocus
      }
    ), /* @__PURE__ */ React.createElement("div", { className: "nut-input-add", onClick: handlePlus }, /* @__PURE__ */ React.createElement(
      n,
      {
        className: classNames("nut-inputnumber-icon icon-plus", {
          [`${classPrefix$g}-icon-disabled`]: shadowValue === max || disabled
        })
      }
    )));
  };
  InputNumber.displayName = "NutInputNumber";
  const isObject = (val) => val !== null && typeof val === "object";
  const isFunction = (val) => typeof val === "function";
  const isPromise = (val) => {
    return isObject(val) && isFunction(val.then) && isFunction(val.catch);
  };
  const clamp = (num, min, max) => Math.min(Math.max(num, min), max);
  function preventDefault$1(event, isStopPropagation) {
    if (typeof event.cancelable !== "boolean" || event.cancelable) {
      event.preventDefault();
    }
    if (isStopPropagation) {
      event.stopPropagation();
    }
  }
  const getTargetElement = (target) => {
    let targetElement;
    if (isFunction(target)) {
      targetElement = target();
    } else if ("current" in target) {
      targetElement = target.current;
    } else {
      targetElement = target;
    }
    return targetElement;
  };
  function useClickAway(onClickAway, target, eventName = "click", useCapture, isListener, outerVar) {
    const handler = (event) => {
      const targets = Array.isArray(target) ? target : [target];
      if (targets.some((item) => {
        const targetElement = getTargetElement(item);
        return !targetElement || targetElement.contains(event.target);
      })) {
        return;
      }
      if (outerVar) {
        onClickAway();
      }
    };
    React.useEffect(() => {
      if (isListener) {
        window.addEventListener(eventName, handler, useCapture);
      } else {
        window.removeEventListener(eventName, handler, useCapture);
      }
      return () => {
        window.removeEventListener(eventName, handler, useCapture);
      };
    }, [target]);
  }
  const defaultProps$T = {
    ...ComponentDefaults,
    titleIcon: null,
    columns: 1,
    direction: "down",
    icon: null,
    closeOnClickAway: true,
    activeTitleClass: "",
    inactiveTitleClass: "",
    onChange: (value) => void 0
  };
  const MenuItem = React.forwardRef((props, ref) => {
    const {
      className,
      style,
      options: options2,
      value,
      defaultValue,
      columns,
      title,
      icon,
      direction,
      onChange,
      activeTitleClass,
      inactiveTitleClass,
      closeOnClickAway,
      children,
      activeColor,
      show: show2,
      parent,
      index
    } = {
      ...defaultProps$T,
      ...props
    };
    const [showPopup, setShowPopup] = React.useState(show2);
    const [innerValue, setValue] = usePropsValue({
      defaultValue,
      value,
      finalValue: void 0,
      onChange: (v) => {
        const [option] = options2.filter((o) => o.value === v);
        onChange == null ? void 0 : onChange(option);
      }
    });
    React.useEffect(() => {
      setShowPopup(show2);
    }, [show2]);
    const getParentOffset = React.useCallback(() => {
      setTimeout(() => {
        const p2 = parent.menuRef.current;
        if (p2) {
          const rect = p2.getBoundingClientRect();
          setPosition({
            height: rect.height,
            top: rect.top
          });
        }
      });
    }, [parent.menuRef]);
    React.useEffect(() => {
      getParentOffset();
    }, [showPopup, getParentOffset]);
    React.useImperativeHandle(ref, () => ({
      toggle: (s2) => {
        const from = "REF";
        s2 ? parent.toggleMenuItem(index, from) : parent.hideMenuItem(index, from);
      }
    }));
    const getIconCName = (optionVal, value2) => {
      return classNames({
        [activeTitleClass]: optionVal === value2,
        [inactiveTitleClass]: optionVal !== value2
      });
    };
    const setTitle = (text) => {
      if (!title) {
        parent.updateTitle(text, index);
      }
    };
    const handleClick2 = (item) => {
      parent.toggleMenuItem(index);
      setTitle(item.text);
      setValue(item.value);
    };
    const isShow = () => {
      if (showPopup) return {};
      return { display: "none" };
    };
    const [position, setPosition] = React.useState({
      top: 0,
      height: 0
    });
    const scrollParent = React.useMemo(() => {
      return getScrollParent(parent.menuRef, window);
    }, [parent.menuRef]);
    React.useEffect(() => {
      if (!parent.lockScroll) {
        scrollParent == null ? void 0 : scrollParent.addEventListener("scroll", getParentOffset, false);
        return () => {
          scrollParent == null ? void 0 : scrollParent.removeEventListener("scroll", getParentOffset, false);
        };
      }
    }, [parent.lockScroll, scrollParent, getParentOffset]);
    const getPosition = () => {
      return direction === "down" ? {
        top: `${position.top + position.height}px`,
        bottom: "0",
        height: "initial"
      } : {
        bottom: `${window.innerHeight - position.top}px`,
        top: "auto",
        height: "initial"
      };
    };
    const micRef = React.useRef(null);
    const cssRef = React.useRef(null);
    const targetSet = [micRef.current];
    useClickAway(
      () => {
        parent.hideMenuItem(index);
      },
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      targetSet,
      "click",
      false,
      showPopup,
      closeOnClickAway
    );
    return /* @__PURE__ */ React.createElement("div", { className: "nut-menu-container", ref: micRef }, parent.overlay ? /* @__PURE__ */ React.createElement(
      Overlay,
      {
        className: "nut-menu-container-overlay",
        style: getPosition(),
        lockScroll: parent.lockScroll,
        visible: showPopup,
        closeOnOverlayClick: parent.closeOnOverlayClick,
        onClick: () => {
          parent.closeOnOverlayClick && parent.hideMenuItem(index);
        }
      }
    ) : null, /* @__PURE__ */ React.createElement(
      "div",
      {
        className: classNames(
          {
            "nut-menu-container-wrap": direction === "down",
            "nut-menu-container-wrap-up": direction !== "down"
          },
          className
        ),
        style: {
          ...style,
          ...isShow()
        }
      },
      /* @__PURE__ */ React.createElement(
        CSSTransition,
        {
          nodeRef: cssRef,
          in: showPopup,
          timeout: 100,
          classNames: direction === "down" ? "nut-menu-container-down" : "nut-menu-container-up"
        },
        /* @__PURE__ */ React.createElement("div", { className: "nut-menu-container-content" }, options2 == null ? void 0 : options2.map((item) => {
          return /* @__PURE__ */ React.createElement(
            "div",
            {
              className: `nut-menu-container-item ${classNames({
                active: item.value === innerValue
              })}`,
              key: item.text,
              style: {
                flexBasis: `${100 / columns}%`
              },
              onClick: () => {
                handleClick2(item);
              }
            },
            item.value === innerValue ? /* @__PURE__ */ React.createElement("i", { className: "nut-menu-container-item-icon" }, icon || /* @__PURE__ */ React.createElement(
              i$5,
              {
                color: activeColor,
                className: getIconCName(item.value, value)
              }
            )) : null,
            /* @__PURE__ */ React.createElement(
              "div",
              {
                className: `nut-menu-container-item-title ${getIconCName(item.value, value)}`,
                style: {
                  color: `${item.value === innerValue ? activeColor : ""}`
                }
              },
              item.text
            )
          );
        }), children)
      )
    ));
  });
  MenuItem.displayName = "NutMenuItem";
  const defaultProps$S = {
    ...ComponentDefaults,
    activeColor: "",
    closeOnOverlayClick: true,
    scrollFixed: false,
    lockScroll: true,
    overlay: true,
    icon: null,
    onOpen: (index, from) => {
    },
    onClose: (index, from) => {
    }
  };
  const Menu = (props) => {
    const {
      className,
      icon,
      scrollFixed,
      lockScroll,
      overlay,
      closeOnOverlayClick,
      children,
      activeColor,
      onClose,
      onOpen,
      ...rest
    } = {
      ...defaultProps$S,
      ...props
    };
    const menuRef = React.useRef(null);
    const [showMenuItem, setShowMenuItem] = React.useState([]);
    const [menuItemTitle, setMenuItemTitle] = React.useState([]);
    const [isScrollFixed, setIsScrollFixed] = React.useState(false);
    const cls = classNames(`nut-menu`, className, {
      "scroll-fixed": isScrollFixed
    });
    const getScrollTop = (el) => {
      return Math.max(
        0,
        el === window ? window.scrollY : el.scrollTop
      );
    };
    const onScroll = React.useCallback(() => {
      const scrollTop = getScrollTop(window);
      const isFixed = scrollTop > (typeof scrollFixed === "boolean" ? 30 : Number(scrollFixed));
      setIsScrollFixed(isFixed);
    }, [scrollFixed]);
    React.useEffect(() => {
      if (scrollFixed) {
        window.addEventListener("scroll", onScroll);
      }
      return () => window.removeEventListener("scroll", onScroll);
    }, [scrollFixed, onScroll]);
    const toggleMenuItem = (index, from = "NORMAL") => {
      showMenuItem[index] = !showMenuItem[index];
      if (showMenuItem[index]) {
        onOpen && onOpen(index, from);
      } else {
        onClose && onClose(index, from);
      }
      const temp = showMenuItem.map(
        (i2, idx) => idx === index ? i2 : false
      );
      setShowMenuItem([...temp]);
    };
    const hideMenuItem = (index, from = "NORMAL") => {
      showMenuItem[index] = false;
      setShowMenuItem([...showMenuItem]);
      onClose && onClose(index, from);
    };
    const updateTitle = (text, index) => {
      menuItemTitle[index] = text;
      setMenuItemTitle([...menuItemTitle]);
    };
    const cloneChildren = () => {
      return React.Children.map(children, (child, index) => {
        return React.cloneElement(child, {
          ...child.props,
          show: showMenuItem[index],
          index,
          activeColor,
          parent: {
            closeOnOverlayClick,
            overlay,
            lockScroll,
            toggleMenuItem,
            updateTitle,
            hideMenuItem,
            menuRef
          }
        });
      });
    };
    const menuTitle = () => {
      return React.Children.map(children, (child, index) => {
        if (React.isValidElement(child)) {
          const {
            title,
            titleIcon,
            options: options2,
            value,
            defaultValue,
            disabled,
            direction
          } = child.props;
          const selected = options2 == null ? void 0 : options2.filter(
            (option) => option.value === (value !== void 0 ? value : defaultValue)
          );
          const finallyTitle = () => {
            if (title) return title;
            if (menuItemTitle && menuItemTitle[index]) return menuItemTitle[index];
            if (selected && selected.length && selected[0].text)
              return selected[0].text;
            return "";
          };
          const finallyIcon = () => {
            if (titleIcon) return titleIcon;
            if (icon) return icon;
            return direction === "up" ? /* @__PURE__ */ React.createElement(
              i$8,
              {
                className: "nut-menu-title-icon",
                width: "12px",
                height: "12px"
              }
            ) : /* @__PURE__ */ React.createElement(
              i$9,
              {
                className: "nut-menu-title-icon",
                width: "12px",
                height: "12px"
              }
            );
          };
          return /* @__PURE__ */ React.createElement(
            "div",
            {
              className: classNames("nut-menu-title", `nut-menu-title-${index}`, {
                active: showMenuItem[index],
                disabled
              }),
              style: { color: showMenuItem[index] ? activeColor : "" },
              key: index,
              onClick: (e) => {
                e.stopPropagation();
                if ((!options2 || !options2.length) && !child.props.children) return;
                !disabled && toggleMenuItem(index);
              }
            },
            /* @__PURE__ */ React.createElement("div", { className: "nut-menu-title-text" }, finallyTitle()),
            finallyIcon()
          );
        }
        return null;
      });
    };
    return /* @__PURE__ */ React.createElement("div", { ...rest, className: cls, ref: menuRef }, /* @__PURE__ */ React.createElement(
      "div",
      {
        className: classNames("nut-menu-bar", {
          opened: showMenuItem.includes(true)
        })
      },
      menuTitle()
    ), cloneChildren());
  };
  Menu.displayName = "NutMenu";
  Menu.Item = MenuItem;
  const defaultProps$R = {
    ...ComponentDefaults,
    visible: false,
    rightActions: "",
    type: "default",
    custom: [],
    random: false,
    onClose: () => {
    }
  };
  const NumberKeyboard = (props) => {
    const { locale } = useConfig();
    const {
      title,
      rightActions,
      confirmText,
      visible,
      type,
      custom,
      random,
      style,
      className,
      onChange,
      onDelete,
      onClose,
      onConfirm,
      ...rest
    } = { ...defaultProps$R, ...props };
    const classPrefix2 = "nut-numberkeyboard";
    const getBasicKeys = () => {
      const keys = new Array(9).fill(0).map((_, index) => {
        return {
          id: String(index + 1),
          type: "num"
        };
      });
      return random ? keys.sort(() => Math.random() > 0.5 ? 1 : -1) : keys;
    };
    const getCustomKeys = () => {
      const customKeys = [
        { id: "close", type: "close" },
        { id: "0", type: "num" },
        { id: "delete", type: "delete" }
      ];
      if (!custom) return customKeys;
      if (custom.length > 0) {
        customKeys[0] = { id: custom[0], type: "custom" };
      }
      if (custom.length > 1) {
        customKeys[2] = { id: custom[1], type: "custom" };
      }
      return customKeys;
    };
    const keysList = React.useMemo(() => {
      return [...getBasicKeys(), ...getCustomKeys()];
    }, [type, random, custom]);
    const DeleteIcon = () => {
      return /* @__PURE__ */ React.createElement("svg", { viewBox: "0 0 1024 1024", width: "28", height: "28" }, /* @__PURE__ */ React.createElement(
        "path",
        {
          d: "M875.594 186.122H390.803a51.162 51.162 0 0 0-36.18 14.986L79.91 475.821a51.166 51.166 0 0 0 0 72.358l274.714 274.712a51.164 51.164 0 0 0 36.179 14.986h484.791c46.033 0 83.484-37.45 83.484-83.483V269.606c.001-46.033-37.45-83.484-83.483-83.484zm32.32 568.274c0 17.85-14.473 32.318-32.32 32.318H390.803L116.089 512l274.714-274.714h484.791c17.849 0 32.32 14.47 32.32 32.32v484.789z",
          fill: "currentColor"
        }
      ), /* @__PURE__ */ React.createElement(
        "path",
        {
          d: "M753.945 360.214l-121.43 121.429-121.43-121.429s-16.062-8.224-30.356 6.072c-14.295 14.295-6.073 30.357-6.073 30.357l121.43 121.428L486.8 627.357s-8.222 16.062 6.072 30.357c14.297 14.296 30.358 6.072 30.358 6.072l109.286-109.285 109.286 109.285s16.062 8.224 30.357-6.072c14.295-14.295 6.07-30.357 6.07-30.357L668.944 518.072l121.431-121.43s8.22-16.061-6.074-30.356c-14.294-14.296-30.356-6.072-30.356-6.072z",
          fill: "currentColor"
        }
      ));
    };
    const NumberKeyboardKey = (props2) => {
      const { item } = props2;
      const [active, setActive] = React.useState(false);
      const onTouchStart = () => {
        setActive(true);
      };
      const onTouchEnd = (item2) => {
        setActive(false);
        switch (item2.type) {
          case "num":
          case "custom":
            onChange == null ? void 0 : onChange(item2.id);
            break;
          case "close":
            onClose == null ? void 0 : onClose();
            break;
          case "delete":
            onDelete == null ? void 0 : onDelete();
            break;
          case "confirm":
            onConfirm == null ? void 0 : onConfirm();
            break;
        }
      };
      const renderContent = (item2) => {
        switch (item2.type) {
          case "num":
          case "custom":
            return /* @__PURE__ */ React.createElement("div", null, item2.id);
          case "delete":
            return /* @__PURE__ */ React.createElement(DeleteIcon, null);
          case "close":
            return /* @__PURE__ */ React.createElement(i$9, { width: 18, height: 18 });
          case "confirm":
            return /* @__PURE__ */ React.createElement(React.Fragment, null, confirmText || locale.done);
          default:
            return null;
        }
      };
      return /* @__PURE__ */ React.createElement("div", { key: item.id, className: `${classPrefix2}-body-wrapper` }, /* @__PURE__ */ React.createElement(
        "div",
        {
          className: classNames({
            key: true,
            active,
            close: item.type === "close",
            delete: item.type === "delete",
            confirm: item.type === "confirm"
          }),
          onTouchStart: () => onTouchStart(),
          onTouchEnd: () => onTouchEnd(item),
          onTouchCancel: () => onTouchEnd(item)
        },
        renderContent(item)
      ));
    };
    return /* @__PURE__ */ React.createElement(
      Popup,
      {
        ...rest,
        visible,
        position: "bottom",
        onOverlayClick: onClose,
        onCloseIconClick: onClose,
        zIndex: 9999,
        overlayStyle: { backgroundColor: "rgba(0, 0, 0, 0)" }
      },
      /* @__PURE__ */ React.createElement("div", { className: classNames(classPrefix2, className), style }, title && /* @__PURE__ */ React.createElement("div", { className: `${classPrefix2}-header` }, /* @__PURE__ */ React.createElement("div", { className: `${classPrefix2}-header-title` }, title), type === "default" && /* @__PURE__ */ React.createElement(
        "span",
        {
          className: `${classPrefix2}-header-close`,
          onClick: onConfirm
        },
        rightActions || locale.done
      )), /* @__PURE__ */ React.createElement("div", { className: `${classPrefix2}-body` }, /* @__PURE__ */ React.createElement("div", { className: `${classPrefix2}-body-keys` }, keysList == null ? void 0 : keysList.map((item) => {
        return /* @__PURE__ */ React.createElement(NumberKeyboardKey, { key: item.id, item });
      })), type === "rightColumn" && /* @__PURE__ */ React.createElement("div", { className: `${classPrefix2}-sidebar` }, /* @__PURE__ */ React.createElement(
        NumberKeyboardKey,
        {
          key: "delete",
          item: {
            id: "delete",
            type: "delete"
          }
        }
      ), /* @__PURE__ */ React.createElement(
        NumberKeyboardKey,
        {
          key: "confirm",
          item: {
            id: "confirm",
            type: "confirm"
          }
        }
      ))))
    );
  };
  NumberKeyboard.displayName = "NutNumberKeyboard";
  const RadioContext = React.createContext(null);
  const defaultProps$Q = {
    labelPosition: "right",
    onChange: (value) => {
    },
    direction: "vertical",
    options: []
  };
  const classPrefix$f = "nut-radiogroup";
  const RadioGroup = React.forwardRef(
    (props, ref) => {
      const {
        children,
        className,
        value,
        defaultValue,
        onChange,
        shape,
        labelPosition,
        direction,
        options: options2,
        disabled,
        ...rest
      } = { ...defaultProps$Q, ...props };
      const cls = classNames(
        classPrefix$f,
        {
          [`${classPrefix$f}-${props.direction}`]: props.direction
        },
        className
      );
      const [val2State, setVal2State] = usePropsValue({
        defaultValue: props.defaultValue,
        value: props.value,
        finalValue: "",
        onChange
      });
      const renderOptionsChildren = React.useCallback(() => {
        return options2 == null ? void 0 : options2.map(({ label, value: value2, disabled: disabled2, onChange: onChange2, ...rest2 }) => {
          return /* @__PURE__ */ React.createElement(
            Radio,
            {
              ...rest2,
              key: value2 == null ? void 0 : value2.toString(),
              children: label,
              value: value2,
              disabled: disabled2,
              onChange: onChange2,
              labelPosition,
              checked: value2 === val2State
            }
          );
        });
      }, [options2, labelPosition, val2State]);
      return /* @__PURE__ */ React.createElement(
        RadioContext.Provider,
        {
          value: {
            labelPosition: labelPosition || "right",
            disabled,
            shape,
            value: val2State,
            check: (value2) => {
              setVal2State(value2);
            },
            uncheck: () => {
              setVal2State("");
            }
          }
        },
        /* @__PURE__ */ React.createElement("div", { className: cls, ...rest }, (options2 == null ? void 0 : options2.length) ? renderOptionsChildren() : children)
      );
    }
  );
  RadioGroup.displayName = "NutRadioGroup";
  const defaultProps$P = {
    ...ComponentDefaults,
    disabled: false,
    shape: "round",
    value: "",
    labelPosition: "right",
    icon: null,
    activeIcon: null,
    onChange: (checked) => {
    }
  };
  const Radio = (props) => {
    const classPrefix2 = "nut-radio";
    const {
      children,
      className,
      style,
      checked,
      defaultChecked,
      shape,
      value,
      icon,
      activeIcon,
      onChange,
      ...others
    } = {
      ...defaultProps$P,
      ...props
    };
    let { labelPosition, disabled, ...rest } = others;
    let [checkedStatement, setCheckedStatement] = usePropsValue({
      value: checked,
      defaultValue: defaultChecked,
      finalValue: false,
      onChange
    });
    const context = React.useContext(RadioContext);
    if (context) {
      checkedStatement = context.value === value;
      if (context.labelPosition !== void 0) {
        labelPosition = context.labelPosition;
      }
      if (context.disabled !== void 0) {
        disabled = context.disabled;
      }
      setCheckedStatement = (value2) => {
        if (value2) {
          context.check(props.value === void 0 ? "" : props.value);
        } else {
          context.uncheck();
        }
      };
    }
    const color = () => {
      return {
        [`${classPrefix2}-icon-disabled`]: disabled,
        [`${classPrefix2}-icon`]: !checkedStatement,
        [`${classPrefix2}-icon-checked`]: checkedStatement
      };
    };
    const renderIcon = () => {
      const { icon: icon2, activeIcon: activeIcon2 } = props;
      if (disabled && !checkedStatement) {
        return /* @__PURE__ */ React.createElement(i$7, { className: classNames(color()) });
      }
      if (checkedStatement) {
        return React.isValidElement(activeIcon2) ? React.cloneElement(activeIcon2, {
          ...activeIcon2.props,
          className: classNames(color())
        }) : /* @__PURE__ */ React.createElement(p$5, { className: classNames(color()) });
      }
      return React.isValidElement(icon2) ? React.cloneElement(icon2, {
        ...icon2.props,
        className: classNames(color())
      }) : /* @__PURE__ */ React.createElement(i$6, { className: classNames(color()) });
    };
    const renderLabel = () => {
      const labelcls = classNames(`${classPrefix2}-label`, {
        [`${classPrefix2}-label-disabled`]: disabled
      });
      return /* @__PURE__ */ React.createElement(React.Fragment, null, renderIcon(), /* @__PURE__ */ React.createElement("div", { className: labelcls }, children));
    };
    const renderButton = () => {
      const buttoncls = classNames(`${classPrefix2}-button`, {
        [`${classPrefix2}-button-active`]: checkedStatement,
        [`${classPrefix2}-button-disabled`]: disabled
      });
      return /* @__PURE__ */ React.createElement("div", { className: buttoncls }, children);
    };
    const renderByShape = (shape2) => {
      return shape2 === "button" ? renderButton() : renderLabel();
    };
    const renderRadioItem = () => {
      return renderByShape(context && context.shape ? context.shape : shape);
    };
    const handleClick2 = (e) => {
      if (disabled || checkedStatement) return;
      setCheckedStatement(!checkedStatement);
    };
    const cls = classNames(
      classPrefix2,
      {
        [`${classPrefix2}-reverse`]: labelPosition === "left"
      },
      className
    );
    return /* @__PURE__ */ React.createElement("div", { className: cls, style, onClick: handleClick2, ...rest }, renderRadioItem());
  };
  Radio.displayName = "NutRadio";
  Radio.Group = RadioGroup;
  const defaultProps$O = {
    ...ComponentDefaults,
    range: false,
    min: 0,
    max: 100,
    step: 1,
    vertical: false,
    marks: {}
  };
  const Range = (props) => {
    const rtl = useRtl();
    const {
      className,
      range: range2,
      disabled,
      button,
      vertical,
      marks,
      minDescription,
      maxDescription,
      currentDescription,
      min,
      max,
      step,
      value,
      defaultValue,
      onChange,
      onStart,
      onEnd
    } = { ...defaultProps$O, ...props };
    const classPrefix2 = "nut-range";
    const [buttonIndex, setButtonIndex] = React.useState(0);
    const [dragStatus, setDragStatus] = React.useState("start");
    const touch = useTouch();
    const root2 = React.useRef(null);
    const [marksList, setMarksList] = React.useState([]);
    const [startValue, setStartValue] = React.useState(0);
    const handleChange = (value2) => {
      onChange && onChange(value2);
    };
    const [current, setCurrent] = usePropsValue({
      value,
      defaultValue,
      finalValue: 0,
      onChange: handleChange
    });
    const [exactValue, setExactValue] = React.useState(
      () => value || defaultValue || 0
    );
    const marksRef = React.useRef({});
    React.useEffect(() => {
      if (marks) {
        if (Array.isArray(marks)) {
          const list = marks.sort((a, b) => a.value - b.value).filter((point) => point.value >= min && point.value <= max);
          setMarksList(list.map((mark) => mark.value));
          list.forEach((mark) => {
            marksRef.current[mark.value] = mark.label !== void 0 ? mark.label : mark.value;
          });
        } else {
          const marksKeys = Object.keys(marks);
          const list = marksKeys.map(parseFloat).sort((a, b) => a - b).filter((point) => point >= min && point <= max);
          setMarksList(list);
        }
      }
    }, [marks, max, min]);
    const classes = classNames(classPrefix2, {
      [`${classPrefix2}-disabled`]: disabled,
      [`${classPrefix2}-vertical`]: vertical
    });
    const containerClasses = classNames(
      `${classPrefix2}-container`,
      {
        [`${classPrefix2}-container-vertical`]: vertical
      },
      className
    );
    const markClassName = (mark) => {
      const classPrefix22 = "nut-range-mark";
      let lowerBound = min;
      let upperBound = max;
      if (range2 && Array.isArray(current)) {
        lowerBound = current[0];
        upperBound = current[1];
      } else {
        upperBound = current;
      }
      const isActive = mark <= upperBound && mark >= lowerBound;
      return [
        `${classPrefix22}-text`,
        `${isActive ? `${classPrefix22}-text-active` : ""}`
      ].join(" ");
    };
    const isRange = (val) => {
      return !!range2 && Array.isArray(val);
    };
    const scope = React.useMemo(() => {
      if (max < min || max === min) {
        console.log("max 的值需要大于 min的值");
      }
      return max - min;
    }, [max, min]);
    const calcMainAxis = () => {
      const modelVal = current;
      return isRange(modelVal) ? `${(modelVal[1] - modelVal[0]) * 100 / scope}%` : `${(modelVal - min) * 100 / scope}%`;
    };
    const calcOffset = () => {
      const modelVal = current;
      return isRange(modelVal) ? `${(modelVal[0] - min) * 100 / scope}%` : `0%`;
    };
    const barStyle = () => {
      if (vertical) {
        return {
          height: calcMainAxis(),
          top: calcOffset(),
          transition: dragStatus ? "none" : void 0
        };
      }
      const dir = rtl ? "right" : "left";
      return {
        width: calcMainAxis(),
        [dir]: calcOffset(),
        transition: dragStatus ? "none" : void 0
      };
    };
    const marksStyle = (mark) => {
      const dir = rtl ? "right" : "left";
      let style = {
        [dir]: `${(mark - min) / scope * 100}%`
      };
      if (vertical) {
        style = {
          top: `${(mark - min) / scope * 100}%`
        };
      }
      return style;
    };
    const tickClass = (mark) => {
      if (range2 && Array.isArray(current)) {
        return mark <= current[1] && mark >= current[0];
      }
      return mark <= current;
    };
    const format2 = (value2) => {
      value2 = Math.max(+min, Math.min(value2, +max));
      return Math.round(value2 / +step) * +step;
    };
    const isSameValue = (newValue, oldValue) => {
      return JSON.stringify(newValue) === JSON.stringify(oldValue);
    };
    const handleOverlap = (value2) => {
      if (value2[0] > value2[1]) {
        return value2.slice(0).reverse();
      }
      return value2;
    };
    const updateValue = (value2, end) => {
      if (isRange(value2)) {
        value2 = handleOverlap(value2).map(format2);
      } else {
        value2 = format2(value2);
      }
      if (!isSameValue(value2, current)) {
        setCurrent(value2);
      }
      end && onEnd && onEnd(value2);
    };
    const click = (event) => {
      if (disabled || !root2.current) {
        return;
      }
      setDragStatus("");
      const rect = getRect(root2.current);
      let delta = event.clientX - rect.left;
      let total = rect.width;
      if (vertical) {
        delta = event.clientY - rect.top;
        total = rect.height;
      }
      const value2 = min + delta / total * scope;
      setExactValue(current);
      if (isRange(current)) {
        const [left, right] = current;
        const middle = (left + right) / 2;
        if (value2 <= middle) {
          updateValue([value2, right], true);
        } else {
          updateValue([left, value2], true);
        }
      } else {
        updateValue(value2, true);
      }
    };
    const onTouchStart = (event) => {
      if (disabled) {
        return;
      }
      touch.start(event);
      setExactValue(current);
      if (isRange(current)) {
        setStartValue(current.map(format2));
      } else {
        setStartValue(format2(current));
      }
      setDragStatus("start");
    };
    const onTouchMove = (event) => {
      event.stopPropagation();
      if (disabled || !root2.current) {
        return;
      }
      if (dragStatus === "start") {
        onStart && onStart();
      }
      touch.move(event);
      setDragStatus("draging");
      const rect = getRect(root2.current);
      let delta = touch.deltaX.current;
      let total = rect.width;
      let diff = delta / total * scope;
      diff = rtl ? -diff : diff;
      if (vertical) {
        delta = touch.deltaY.current;
        total = rect.height;
        diff = delta / total * scope;
      }
      let newValue;
      if (isRange(startValue)) {
        newValue = exactValue.slice();
        newValue[buttonIndex] = startValue[buttonIndex] + diff;
      } else {
        newValue = startValue + diff;
      }
      setExactValue(newValue);
      updateValue(newValue);
    };
    const onTouchEnd = () => {
      if (disabled) {
        return;
      }
      if (dragStatus === "draging") {
        updateValue(current, true);
      }
      setDragStatus("");
    };
    const curValue = (idx) => {
      const modelVal = current;
      const value2 = typeof idx === "number" ? modelVal[idx] : modelVal;
      return value2;
    };
    const renderButton = (index) => {
      return /* @__PURE__ */ React.createElement(React.Fragment, null, button || /* @__PURE__ */ React.createElement("div", { className: "nut-range-button" }, currentDescription !== null && /* @__PURE__ */ React.createElement("div", { className: "number" }, currentDescription ? currentDescription(curValue(index)) : curValue(index))));
    };
    const renderRangeButton = () => {
      return [0, 1].map((item, index) => {
        const cls = `${index === 0 ? "nut-range-button-wrapper-left" : ""}
                  ${index === 1 ? "nut-range-button-wrapper-right" : ""}`;
        return /* @__PURE__ */ React.createElement(
          "div",
          {
            key: index,
            className: cls,
            onTouchStart: (e) => {
              setButtonIndex(index);
              onTouchStart(e);
            },
            onTouchMove,
            onTouchEnd,
            onTouchCancel: onTouchEnd,
            onClick: (e) => e.stopPropagation()
          },
          renderButton(index)
        );
      });
    };
    const renderSingleButton = () => {
      return /* @__PURE__ */ React.createElement(
        "div",
        {
          className: "nut-range-button-wrapper",
          onTouchStart,
          onTouchMove,
          onTouchEnd,
          onTouchCancel: onTouchEnd,
          onClick: (e) => e.stopPropagation()
        },
        renderButton()
      );
    };
    const renderMark = () => {
      return /* @__PURE__ */ React.createElement(React.Fragment, null, marksList.length > 0 && /* @__PURE__ */ React.createElement("div", { className: "nut-range-mark" }, marksList.map((mark) => {
        return /* @__PURE__ */ React.createElement(
          "span",
          {
            key: mark,
            className: markClassName(mark),
            style: marksStyle(mark)
          },
          Array.isArray(marks) ? marksRef.current[mark] : marks[mark],
          /* @__PURE__ */ React.createElement(
            "span",
            {
              className: classNames("nut-range-tick", {
                active: tickClass(mark)
              })
            }
          )
        );
      })));
    };
    return /* @__PURE__ */ React.createElement("div", { className: containerClasses }, minDescription !== null && /* @__PURE__ */ React.createElement("div", { className: "min" }, minDescription || min), /* @__PURE__ */ React.createElement("div", { ref: root2, className: classes, onClick: (e) => click(e) }, renderMark(), /* @__PURE__ */ React.createElement("div", { className: "nut-range-bar", style: barStyle() }, range2 ? renderRangeButton() : renderSingleButton())), maxDescription !== null && /* @__PURE__ */ React.createElement("div", { className: "max" }, maxDescription || max));
  };
  Range.displayName = "NutRange";
  const defaultProps$N = {
    ...ComponentDefaults,
    count: 5,
    min: 0,
    checkedIcon: null,
    uncheckedIcon: null,
    disabled: false,
    readOnly: false,
    allowHalf: false,
    touchable: false
  };
  const Rate = (props) => {
    const {
      className,
      style,
      count,
      value,
      defaultValue,
      min,
      checkedIcon,
      uncheckedIcon,
      disabled,
      readOnly,
      allowHalf,
      touchable,
      onChange,
      onTouchEnd
    } = {
      ...defaultProps$N,
      ...props
    };
    const classPrefix2 = "nut-rate";
    const [countArray, setCountArray] = React.useState([1, 2, 3, 4, 5]);
    const [refs, setRefs] = useRefs();
    const rateRects = React.useRef([]);
    const [score, setScore] = usePropsValue({
      value,
      defaultValue: Math.max(defaultValue || 0, min),
      finalValue: 0,
      onChange
    });
    React.useEffect(() => {
      const tmp = [];
      for (let i2 = 1; i2 <= Number(count); i2++) {
        tmp.push(i2);
      }
      setCountArray(tmp);
    }, [count]);
    const renderIcon = (n2) => {
      return n2 <= score ? checkedIcon || /* @__PURE__ */ React.createElement(s$2, null) : uncheckedIcon || (checkedIcon ? React.cloneElement(checkedIcon, {
        color: void 0
      }) : /* @__PURE__ */ React.createElement(s$2, null));
    };
    const onClick = (e, index) => {
      e.preventDefault();
      e.stopPropagation();
      if (disabled || readOnly) return;
      let value2 = 0;
      if (!(index === 1 && score === index)) {
        value2 = index;
      }
      value2 = Math.max(value2, min);
      setScore(value2);
    };
    const onHalfClick = (event, n2) => {
      event.preventDefault();
      event.stopPropagation();
      const value2 = Math.max(min, n2 - 0.5);
      setScore(value2);
    };
    const getScoreByPosition = (x) => {
      var _a;
      if ((_a = rateRects.current) == null ? void 0 : _a.length) {
        for (let index = rateRects.current.length - 1; index >= 0; index--) {
          const item = rateRects.current[index];
          if (item && x > item.left) {
            return allowHalf ? index + (x > item.left + item.width / 2 ? 1 : 0.5) : index + 1;
          }
        }
        return 0;
      }
    };
    const updateRects = () => {
      for (let index = 0; index < refs.length; index++) {
        const item = refs[index];
        if (item) {
          rateRects.current[index] = getRect(item);
        }
      }
    };
    const handleTouchStart = (e) => {
      if (!touchable || readOnly || disabled) {
        return;
      }
      if (e.cancelable) {
        e.preventDefault();
      }
      e.stopPropagation();
      updateRects();
    };
    const handleTouchMove = (e) => {
      if (!touchable || readOnly || disabled) {
        return;
      }
      if (e.cancelable) {
        e.preventDefault();
      }
      e.stopPropagation();
      const val = getScoreByPosition(e.touches[0].clientX);
      if (val !== void 0) {
        setScore(Math.max(min, val));
      }
    };
    const handleTouchEnd = (e) => {
      if (!touchable || readOnly || disabled) {
        return;
      }
      if (e.cancelable) {
        e.preventDefault();
      }
      e.stopPropagation();
      const val = getScoreByPosition(e.changedTouches[0].clientX);
      if (val !== void 0) {
        setScore(Math.max(min, val));
        onTouchEnd && onTouchEnd(e, Math.max(min, val));
      }
    };
    const rateRef = React.useRef(null);
    React.useEffect(() => {
      const element = rateRef.current;
      if (element) {
        element.addEventListener("touchstart", handleTouchStart, {
          passive: false
        });
        element.addEventListener("touchmove", handleTouchMove, { passive: false });
        element.addEventListener("touchend", handleTouchEnd, { passive: false });
      }
      return () => {
        if (element) {
          element.removeEventListener("touchstart", handleTouchStart);
          element.removeEventListener("touchmove", handleTouchMove);
          element.removeEventListener("touchend", handleTouchEnd);
        }
      };
    }, []);
    return /* @__PURE__ */ React.createElement(
      "div",
      {
        className: classNames(
          classPrefix2,
          {
            disabled,
            readonly: readOnly
          },
          className
        ),
        ref: rateRef,
        style
      },
      countArray.map((n2, index) => {
        return /* @__PURE__ */ React.createElement(
          "div",
          {
            className: `${classPrefix2}-item`,
            key: n2,
            ref: setRefs(index),
            onClick: (event) => onClick(event, n2)
          },
          /* @__PURE__ */ React.createElement(
            "div",
            {
              className: classNames(`${classPrefix2}-item-icon`, {
                [`${classPrefix2}-item-icon-disabled`]: disabled || n2 > score
              })
            },
            renderIcon(n2)
          ),
          allowHalf && score > n2 - 1 && /* @__PURE__ */ React.createElement(
            "div",
            {
              className: classNames(
                `${classPrefix2}-item-half`,
                `${classPrefix2}-item-icon`,
                `${classPrefix2}-item-icon-half`
              ),
              onClick: (event) => onHalfClick(event, n2)
            },
            renderIcon(n2)
          )
        );
      })
    );
  };
  Rate.displayName = "NutRate";
  const defaultProps$M = {
    ...ComponentDefaults,
    placeholder: "",
    shape: "square",
    disabled: false,
    maxLength: 9999,
    clearable: true,
    readOnly: false,
    autoFocus: false,
    backable: false,
    left: "",
    right: "",
    rightIn: "",
    leftIn: /* @__PURE__ */ React.createElement(i$2, { width: "16", height: "16" })
  };
  const SearchBar = (props) => {
    const classPrefix2 = "nut-searchbar";
    const { locale } = useConfig();
    const searchRef = React.useRef(null);
    const {
      value: outerValue,
      style,
      placeholder,
      shape,
      className,
      disabled,
      maxLength,
      clearable,
      readOnly,
      autoFocus,
      backable,
      right,
      left,
      leftIn,
      rightIn,
      onChange,
      onFocus,
      onBlur,
      onClear,
      onSearch,
      onInputClick
    } = {
      ...defaultProps$M,
      ...props
    };
    const [value, setValue] = React.useState(() => outerValue);
    const forceFocus = () => {
      const searchSelf = searchRef.current;
      searchSelf && searchSelf.focus();
    };
    const change = (event) => {
      const { value: value2 } = event.target;
      onChange && (onChange == null ? void 0 : onChange(value2, event));
      setValue(value2);
    };
    const focus = (event) => {
      const { value: value2 } = event.target;
      onFocus && (onFocus == null ? void 0 : onFocus(value2, event));
    };
    const blur = (event) => {
      const searchSelf = searchRef.current;
      searchSelf && searchSelf.blur();
      const { value: value2 } = event.target;
      onBlur && (onBlur == null ? void 0 : onBlur(value2, event));
    };
    React.useEffect(() => {
      setValue(outerValue);
    }, [outerValue]);
    React.useEffect(() => {
      autoFocus && forceFocus();
    }, [autoFocus]);
    const renderField = () => {
      return /* @__PURE__ */ React.createElement(
        "input",
        {
          className: `${classPrefix2}-input ${clearable ? `${classPrefix2}-input-clear` : ""}`,
          ref: searchRef,
          style,
          value: value || "",
          placeholder: placeholder || locale.placeholder,
          disabled,
          readOnly,
          maxLength,
          onKeyDown: onKeydown,
          onChange: (e) => change(e),
          onFocus: (e) => focus(e),
          onBlur: (e) => blur(e),
          onClick: (e) => clickInput(e)
        }
      );
    };
    const clickInput = (e) => {
      onInputClick && onInputClick(e);
    };
    const renderLeftIn = () => {
      if (!leftIn) return null;
      return /* @__PURE__ */ React.createElement("div", { className: `${classPrefix2}-leftin ${classPrefix2}-icon` }, leftIn);
    };
    const renderLeft = () => {
      if (!backable && !left) return null;
      return /* @__PURE__ */ React.createElement("div", { className: `${classPrefix2}-left` }, backable ? /* @__PURE__ */ React.createElement(n$6, { width: "16", height: "16" }) : left);
    };
    const renderRightIn = () => {
      if (!rightIn) return null;
      return /* @__PURE__ */ React.createElement("div", { className: `${classPrefix2}-rightin ${classPrefix2}-icon` }, rightIn);
    };
    const renderRight = () => {
      if (!right) return null;
      return /* @__PURE__ */ React.createElement("div", { className: `${classPrefix2}-right` }, right);
    };
    const handleClear = () => {
      return /* @__PURE__ */ React.createElement(
        "div",
        {
          className: `${classPrefix2}-clear ${classPrefix2}-icon`,
          onClick: (e) => clearaVal(e)
        },
        /* @__PURE__ */ React.createElement(i$3, null)
      );
    };
    const clearaVal = (event) => {
      if (disabled || readOnly) {
        return;
      }
      setValue("");
      onChange && (onChange == null ? void 0 : onChange(""));
      onClear && onClear(event);
      forceFocus();
    };
    const onKeydown = (e) => {
      if (e.key === "Enter") {
        const event = e.nativeEvent;
        if (typeof event.cancelable !== "boolean" || event.cancelable) {
          event.preventDefault();
        }
        onSearch && onSearch(value);
      }
    };
    return /* @__PURE__ */ React.createElement(
      "div",
      {
        className: `${classPrefix2} ${disabled ? `${classPrefix2}-disabled` : ""}  ${className || ""}`,
        style
      },
      renderLeft(),
      /* @__PURE__ */ React.createElement(
        "div",
        {
          className: `${classPrefix2}-content ${shape === "round" ? `${classPrefix2}-round` : ""}`
        },
        renderLeftIn(),
        renderField(),
        clearable && !value && renderRightIn(),
        clearable && value && handleClear()
      ),
      renderRight()
    );
  };
  SearchBar.displayName = "NutSearchBar";
  const defaultProps$L = {
    ...ComponentDefaults,
    value: "",
    visible: false,
    plain: false,
    hideFooter: true,
    length: 6,
    // 1~6
    autoFocus: false
  };
  const InternalShortPassword = (props, ref) => {
    const { locale } = useConfig();
    const {
      title,
      description,
      tips,
      visible: outerVisible,
      value,
      error,
      hideFooter,
      length,
      plain,
      style,
      className,
      closeable,
      autoFocus,
      onFocus,
      onChange,
      onConfirm,
      onTips,
      onCancel,
      onClose,
      onComplete,
      onOverlayClick,
      onCloseIconClick,
      ...rest
    } = {
      ...defaultProps$L,
      ...props
    };
    const classPrefix2 = "nut-shortpassword";
    const comLen = React.useMemo(() => {
      return Math.min(Math.max(4, length || 4), 6);
    }, [length]);
    const format2 = (val) => {
      return val.slice(0, comLen);
    };
    const [visible, setVisible] = usePropsValue({
      value: outerVisible,
      defaultValue: false,
      finalValue: false
    });
    const handleClose = () => {
      onClose == null ? void 0 : onClose();
      setVisible(false);
    };
    const actions = {
      open: () => {
        setVisible(true);
      },
      close: () => {
        setVisible(false);
      }
    };
    React.useImperativeHandle(ref, () => actions);
    const [inputValue, setInputValue] = usePropsValue({ value, onChange });
    React.useEffect(() => {
      if (visible && autoFocus) {
        onFocus && onFocus();
      }
    }, [visible]);
    React.useEffect(() => {
      const val = format2(value);
      if (val.length >= comLen) {
        onComplete && onComplete(val);
      }
      setInputValue(format2(value));
    }, [value]);
    const sure = () => {
      onConfirm && onConfirm(inputValue);
    };
    return /* @__PURE__ */ React.createElement(
      Popup,
      {
        style: {
          padding: "32px 24px 28px 24px",
          borderRadius: "12px",
          textAlign: "center"
        },
        visible,
        closeable: true,
        onOverlayClick: handleClose,
        onCloseIconClick: handleClose,
        ...rest
      },
      /* @__PURE__ */ React.createElement("div", { className: classNames(classPrefix2, className), style }, /* @__PURE__ */ React.createElement("div", { className: `${classPrefix2}-title` }, title || locale.shortpassword.title), /* @__PURE__ */ React.createElement("div", { className: `${classPrefix2}-description` }, description || locale.shortpassword.description), /* @__PURE__ */ React.createElement("div", { className: `${classPrefix2}-input`, onClick: onFocus }, /* @__PURE__ */ React.createElement("div", { className: `${classPrefix2}-input-site` }), /* @__PURE__ */ React.createElement("div", { className: `${classPrefix2}-input-fake` }, [...new Array(comLen).keys()].map((item, index) => {
        return /* @__PURE__ */ React.createElement("div", { className: `${classPrefix2}-input-fake-li`, key: index }, inputValue.length > index && /* @__PURE__ */ React.createElement(React.Fragment, null, plain ? inputValue[index] : /* @__PURE__ */ React.createElement("div", { className: `${classPrefix2}-input-fake-li-icon` })));
      }))), /* @__PURE__ */ React.createElement("div", { className: `${classPrefix2}-message` }, /* @__PURE__ */ React.createElement("div", { className: `${classPrefix2}-message-error` }, error), /* @__PURE__ */ React.createElement("div", { className: `${classPrefix2}-message-forget`, onClick: onTips }, tips || /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(c, { width: 11, height: 11 }), locale.shortpassword.tips))), !hideFooter && /* @__PURE__ */ React.createElement("div", { className: `${classPrefix2}-footer` }, /* @__PURE__ */ React.createElement("div", { className: `${classPrefix2}-footer-cancel`, onClick: onCancel }, locale.cancel), /* @__PURE__ */ React.createElement("div", { className: `${classPrefix2}-footer-sure`, onClick: sure }, locale.confirm)))
    );
  };
  const ShortPassword = React.forwardRef(InternalShortPassword);
  const defaultProps$K = {
    ...ComponentDefaults,
    type: "png",
    lineWidth: 2,
    strokeStyle: "#1a1a1a",
    unsupported: ""
  };
  const InternalSignature = (props, ref) => {
    const { locale } = useConfig();
    const {
      type,
      lineWidth,
      strokeStyle,
      unsupported,
      className,
      style,
      onConfirm,
      onClear,
      ...rest
    } = {
      ...defaultProps$K,
      ...props
    };
    const classPrefix2 = `nut-signature`;
    const canvasRef = React.useRef(null);
    const wrapRef = React.useRef(null);
    const [canvasHeight, setCanvasHeight] = React.useState(0);
    const [canvasWidth, setCanvasWidth] = React.useState(0);
    const ctx2 = React.useRef(null);
    const checkCanvas = () => {
      const elem = document.createElement("canvas");
      return !!(elem.getContext && elem.getContext("2d"));
    };
    const [isCanvasSupported, setIsCanvasSupported] = React.useState(false);
    const isSignedRef = React.useRef(false);
    const isSupportTouch = canUseDom ? "ontouchstart" in window : false;
    const events = isSupportTouch ? ["touchstart", "touchmove", "touchend", "touchleave"] : ["mousedown", "mousemove", "mouseup", "mouseleave"];
    React.useEffect(() => {
      setIsCanvasSupported(checkCanvas);
    }, []);
    React.useEffect(() => {
      if (isCanvasSupported && canvasRef.current && wrapRef.current) {
        ctx2.current = canvasRef.current.getContext("2d");
        setCanvasWidth(wrapRef.current.offsetWidth);
        setCanvasHeight(wrapRef.current.offsetHeight);
        addEvent();
      }
    }, [isCanvasSupported]);
    const startEventHandler = (event) => {
      event.preventDefault();
      isSignedRef.current = true;
      if (ctx2.current && canvasRef.current) {
        ctx2.current.beginPath();
        ctx2.current.lineWidth = lineWidth;
        ctx2.current.strokeStyle = strokeStyle;
        canvasRef.current.addEventListener(events[1], moveEventHandler, false);
        canvasRef.current.addEventListener(events[2], endEventHandler, false);
        canvasRef.current.addEventListener(events[3], leaveEventHandler, false);
      }
    };
    const addEvent = () => {
      if (canvasRef.current) {
        canvasRef.current.addEventListener(events[0], startEventHandler, false);
      }
    };
    const moveEventHandler = (event) => {
      event.preventDefault();
      const evt = isSupportTouch ? event.touches[0] : event;
      if (canvasRef.current && ctx2.current) {
        const coverPos = canvasRef.current.getBoundingClientRect();
        const mouseX = evt.clientX - coverPos.left;
        const mouseY = evt.clientY - coverPos.top;
        ctx2.current.lineTo(mouseX, mouseY);
        ctx2.current.stroke();
      }
    };
    const endEventHandler = (event) => {
      event.preventDefault();
      if (canvasRef.current) {
        canvasRef.current.removeEventListener(events[1], moveEventHandler, false);
        canvasRef.current.removeEventListener(events[2], endEventHandler, false);
      }
    };
    const leaveEventHandler = (event) => {
      event.preventDefault();
      if (canvasRef.current) {
        canvasRef.current.removeEventListener(events[1], moveEventHandler, false);
        canvasRef.current.removeEventListener(events[2], endEventHandler, false);
      }
    };
    const handleClearBtn = () => {
      isSignedRef.current = false;
      if (canvasRef.current && ctx2.current) {
        canvasRef.current.addEventListener(events[2], endEventHandler, false);
        ctx2.current.clearRect(0, 0, canvasWidth, canvasHeight);
        ctx2.current.closePath();
      }
      onClear && onClear();
    };
    const onSave = (canvas) => {
      let dataurl = "";
      if (!isSignedRef.current) {
        onConfirm && onConfirm(canvas, dataurl, isSignedRef.current);
        return;
      }
      switch (type) {
        case "png":
          dataurl = canvas.toDataURL("image/png");
          break;
        case "jpg":
          dataurl = canvas.toDataURL("image/jpeg", 0.8);
          break;
        default:
          dataurl = canvas.toDataURL("image/png");
      }
      onConfirm && onConfirm(canvas, dataurl, isSignedRef.current);
    };
    React.useImperativeHandle(ref, () => ({
      confirm: () => {
        onSave(canvasRef.current);
      },
      clear: () => {
        handleClearBtn();
      }
    }));
    return /* @__PURE__ */ React.createElement("div", { className: `${classPrefix2} ${className}`, style, ...rest }, /* @__PURE__ */ React.createElement("div", { className: `${classPrefix2}-inner`, ref: wrapRef }, /* @__PURE__ */ React.createElement(React.Fragment, null, isCanvasSupported ? /* @__PURE__ */ React.createElement("canvas", { ref: canvasRef, height: canvasHeight, width: canvasWidth }) : unsupported ? /* @__PURE__ */ React.createElement(React.Fragment, null, unsupported) : /* @__PURE__ */ React.createElement("p", { className: `${classPrefix2}-unsupport` }, locale.signature.unsupported))));
  };
  const Signature = React.forwardRef(
    InternalSignature
  );
  Signature.displayName = "NutSignature";
  const defaultProps$J = {
    ...ComponentDefaults,
    disabled: false,
    activeText: "",
    inactiveText: ""
  };
  const Switch = (props) => {
    const {
      checked,
      defaultChecked,
      disabled,
      activeText,
      inactiveText,
      className,
      style,
      onChange,
      ...rest
    } = {
      ...defaultProps$J,
      ...props
    };
    const classPrefix2 = "nut-switch";
    const [value, setValue] = usePropsValue({
      value: checked,
      defaultValue: defaultChecked
    });
    const classes = () => {
      return `${classPrefix2} ${value ? "nut-switch-open" : "nut-switch-close"} ${disabled ? `${classPrefix2}-disabled` : ""} ${`${classPrefix2}-base`} ${className}`;
    };
    const onClick = (event) => {
      if (disabled) return;
      onChange && onChange(!value, event);
      setValue(!value);
    };
    return /* @__PURE__ */ React.createElement(
      "div",
      {
        className: classes(),
        onClick: (e) => onClick(e),
        style,
        ...rest
      },
      /* @__PURE__ */ React.createElement("div", { className: `${classPrefix2}-button` }, !value && /* @__PURE__ */ React.createElement("div", { className: `${classPrefix2}-close-line` }), activeText && /* @__PURE__ */ React.createElement(React.Fragment, null, value ? /* @__PURE__ */ React.createElement("div", { className: `${classPrefix2}-label open` }, activeText) : /* @__PURE__ */ React.createElement("div", { className: `${classPrefix2}-label close` }, inactiveText)))
    );
  };
  Switch.displayName = "NutSwitch";
  const defaultProps$I = {
    ...ComponentDefaults,
    defaultValue: "",
    showCount: false,
    rows: 2,
    maxLength: 140,
    readOnly: false,
    disabled: false,
    autoSize: false
  };
  const TextArea = (props) => {
    const { locale } = useConfig();
    const {
      className,
      value,
      defaultValue,
      showCount,
      maxLength,
      rows,
      placeholder,
      readOnly,
      disabled,
      autoSize,
      style,
      onChange,
      onBlur,
      onFocus,
      ...rest
    } = { ...defaultProps$I, ...props };
    const classPrefix2 = "nut-textarea";
    const textareaRef = React.useRef(null);
    const compositionRef = React.useRef(false);
    const format2 = (value2) => {
      if (maxLength !== -1 && value2.length > maxLength) {
        return value2.substring(0, maxLength);
      }
      return value2;
    };
    const [inputValue, setInputValue] = usePropsValue({
      value,
      defaultValue,
      finalValue: format2(defaultValue),
      onChange
    });
    React.useEffect(() => {
      if (autoSize) {
        setContentHeight();
      }
    }, [autoSize, defaultValue, inputValue]);
    const setContentHeight = () => {
      const textarea = textareaRef.current;
      if (textarea) {
        textarea.style.height = "auto";
        const height = textarea == null ? void 0 : textarea.scrollHeight;
        if (height) {
          textarea.style.height = `${height}px`;
        }
      }
    };
    const handleChange = (event) => {
      const text = event.target;
      const value2 = compositionRef.current ? text.value : format2(text.value);
      setInputValue(value2);
    };
    const handleFocus = (event) => {
      if (disabled) return;
      if (readOnly) return;
      onFocus && onFocus(event);
    };
    const handleBlur = (event) => {
      if (disabled) return;
      if (readOnly) return;
      onBlur && onBlur(event);
    };
    return /* @__PURE__ */ React.createElement(
      "div",
      {
        className: classNames(
          classPrefix2,
          {
            [`${classPrefix2}-disabled`]: disabled
          },
          className
        )
      },
      /* @__PURE__ */ React.createElement(
        "textarea",
        {
          ref: textareaRef,
          className: `${classPrefix2}-textarea`,
          style,
          disabled,
          readOnly,
          value: inputValue,
          onChange: (e) => handleChange(e),
          onBlur: (e) => handleBlur(e),
          onFocus: (e) => handleFocus(e),
          onCompositionEnd: () => {
            compositionRef.current = false;
          },
          onCompositionStart: () => {
            compositionRef.current = true;
          },
          rows,
          maxLength: maxLength === -1 ? void 0 : maxLength,
          placeholder: placeholder === void 0 ? locale.placeholder : placeholder,
          ...rest
        }
      ),
      showCount && /* @__PURE__ */ React.createElement("div", { className: `${classPrefix2}-limit` }, inputValue.length, "/", maxLength < 0 ? 0 : maxLength)
    );
  };
  TextArea.displayName = "NutTextArea";
  class UploadOptions {
    constructor() {
      this.url = "";
      this.name = "file";
      this.fileType = "image";
      this.method = "post";
      this.xhrState = 200;
      this.timeout = 30 * 1e3;
      this.headers = {};
      this.withCredentials = false;
    }
  }
  const UPLOADING = "uploading";
  const SUCCESS = "success";
  const ERROR = "error";
  class Upload {
    constructor(options2) {
      this.options = options2;
    }
    upload() {
      var _a;
      const { options: options2 } = this;
      const xhr = new XMLHttpRequest();
      xhr.timeout = options2.timeout;
      if (xhr.upload) {
        xhr.upload.addEventListener(
          "progress",
          (e) => {
            var _a2;
            (_a2 = options2.onProgress) == null ? void 0 : _a2.call(options2, e, options2);
          },
          false
        );
        xhr.onreadystatechange = () => {
          var _a2, _b;
          if (xhr.readyState === 4) {
            if (xhr.status === options2.xhrState) {
              (_a2 = options2.onSuccess) == null ? void 0 : _a2.call(options2, xhr.responseText, options2);
            } else {
              (_b = options2.onFailure) == null ? void 0 : _b.call(options2, xhr.responseText, options2);
            }
          }
        };
        xhr.withCredentials = options2.withCredentials;
        xhr.open(options2.method, options2.url, true);
        for (const [key, value] of Object.entries(options2.headers)) {
          xhr.setRequestHeader(key, value);
        }
        (_a = options2.onStart) == null ? void 0 : _a.call(options2, options2);
        if (options2.beforeXhrUpload) {
          options2.beforeXhrUpload(xhr, options2);
        } else {
          xhr.send(options2.formData);
        }
      } else {
        console.warn("浏览器不支持 XMLHttpRequest");
      }
    }
  }
  const funcInterceptor = (interceptor, {
    args = [],
    done,
    canceled
  }) => {
    if (interceptor) {
      const returnVal = interceptor.apply(null, args);
      if (isPromise(returnVal)) {
        returnVal.then((value) => {
          if (value) {
            done(value);
          } else if (canceled) {
            canceled();
          }
        }).catch(() => {
        });
      } else if (returnVal) {
        done();
      } else if (canceled) {
        canceled();
      }
    } else {
      done();
    }
  };
  const defaultProps$H = {
    ...ComponentDefaults,
    percent: 0,
    showText: false,
    animated: false,
    lazy: false,
    delay: 0
  };
  const Progress = (props) => {
    const rtl = useRtl();
    const {
      className,
      style,
      percent,
      background,
      color,
      strokeWidth,
      showText,
      animated: animated2,
      children,
      lazy,
      delay,
      ...rest
    } = {
      ...defaultProps$H,
      ...props
    };
    const classPrefix2 = "nut-progress";
    const classesInner = classNames({
      [`${classPrefix2}-inner`]: true,
      [`${classPrefix2}-active`]: animated2
    });
    const stylesOuter = {
      height: `${strokeWidth}px`,
      background
    };
    const [displayPercent, setDispalyPercent] = React.useState(0);
    const stylesInner = {
      width: `${displayPercent}%`,
      background: color
    };
    React.useEffect(() => {
      setDispalyPercent(percent);
    }, [percent]);
    const [intersecting, setIntersecting] = React.useState(false);
    const progressRef = React.useRef(null);
    const observer = React.useRef(null);
    const initObserver = () => {
      const options2 = {
        threshold: [0],
        rootMargin: "0px"
      };
      observer.current = new IntersectionObserver((entires, self2) => {
        entires.forEach((item) => {
          setIntersecting(item.isIntersecting);
        });
      }, options2);
      observer.current.observe(progressRef.current);
    };
    const resetObserver = () => {
      observer.current.disconnect && observer.current.disconnect();
    };
    React.useEffect(() => {
      if (lazy) {
        setTimeout(() => {
          if (intersecting) {
            setDispalyPercent(percent);
          } else {
            setDispalyPercent(0);
          }
        }, delay);
      }
    }, [intersecting]);
    React.useEffect(() => {
      lazy && initObserver();
      let timer = null;
      if (delay) {
        setDispalyPercent(0);
        timer = setTimeout(() => {
          setDispalyPercent(percent);
        }, delay);
      }
      return () => {
        lazy && resetObserver();
        timer && clearTimeout(timer);
      };
    }, []);
    return /* @__PURE__ */ React.createElement(
      "div",
      {
        ref: progressRef,
        className: classNames(classPrefix2, className),
        style,
        ...rest
      },
      /* @__PURE__ */ React.createElement("div", { className: `${classPrefix2}-outer`, style: stylesOuter }, /* @__PURE__ */ React.createElement("div", { className: classesInner, style: stylesInner }, showText && /* @__PURE__ */ React.createElement(
        "div",
        {
          className: `${classPrefix2}-text`,
          style: rtl ? { right: `${displayPercent}%` } : { left: `${displayPercent}%` }
        },
        children || /* @__PURE__ */ React.createElement(
          "div",
          {
            className: `${classPrefix2}-text-inner`,
            style: {
              background: color
            }
          },
          percent,
          "%"
        )
      )))
    );
  };
  Progress.displayName = "NutProgress";
  const Preview = ({
    fileList,
    previewType,
    deletable,
    onDeleteItem,
    handleItemClick,
    previewUrl,
    deleteIcon,
    children
  }) => {
    const renderIcon = (item) => {
      if (item.status === ERROR) {
        return item.failIcon || /* @__PURE__ */ React.createElement(p$3, { color: "#fff" });
      }
      return item.loadingIcon || /* @__PURE__ */ React.createElement(n$4, { className: "nut-icon-loading", color: "#fff" });
    };
    return /* @__PURE__ */ React.createElement(React.Fragment, null, fileList.length !== 0 && fileList.map((item, index) => {
      var _a;
      return /* @__PURE__ */ React.createElement(
        "div",
        {
          className: `nut-uploader-preview ${previewType}`,
          key: item.uid
        },
        previewType === "picture" && !children && deletable && /* @__PURE__ */ React.createElement(
          "div",
          {
            onClick: () => onDeleteItem(item, index),
            className: "close"
          },
          deleteIcon
        ),
        previewType === "picture" && !children && /* @__PURE__ */ React.createElement("div", { className: "nut-uploader-preview-img" }, item.status === "ready" ? /* @__PURE__ */ React.createElement("div", { className: "nut-uploader-preview-progress" }, /* @__PURE__ */ React.createElement("div", { className: "nut-uploader-preview-progress-msg" }, item.message)) : item.status !== "success" && /* @__PURE__ */ React.createElement("div", { className: "nut-uploader-preview-progress" }, renderIcon(item), /* @__PURE__ */ React.createElement("div", { className: "nut-uploader-preview-progress-msg" }, item.message)), ((_a = item.type) == null ? void 0 : _a.includes("image")) ? /* @__PURE__ */ React.createElement(React.Fragment, null, item.url && /* @__PURE__ */ React.createElement(
          Image$1,
          {
            className: "nut-uploader-preview-img-c",
            style: { objectFit: "fill" },
            src: item.url,
            alt: "",
            onClick: () => handleItemClick(item, index)
          }
        )) : /* @__PURE__ */ React.createElement(React.Fragment, null, previewUrl ? /* @__PURE__ */ React.createElement(
          Image$1,
          {
            className: "nut-uploader-preview-img-c",
            src: previewUrl,
            alt: "",
            onClick: () => handleItemClick(item, index)
          }
        ) : /* @__PURE__ */ React.createElement("div", { className: "nut-uploader-preview-img-file" }, /* @__PURE__ */ React.createElement(
          "div",
          {
            onClick: () => handleItemClick(item, index),
            className: "nut-uploader-preview-img-file-name"
          },
          /* @__PURE__ */ React.createElement(s$3, { color: "#808080" }),
          /* @__PURE__ */ React.createElement("span", null, " ", item.name)
        ))), item.status === "success" ? /* @__PURE__ */ React.createElement("div", { className: "tips" }, item.name) : null),
        previewType === "list" && /* @__PURE__ */ React.createElement("div", { className: "nut-uploader-preview-list" }, /* @__PURE__ */ React.createElement(
          "div",
          {
            className: `nut-uploader-preview-img-file-name ${item.status}`,
            onClick: () => handleItemClick(item, index)
          },
          /* @__PURE__ */ React.createElement(s$3, null),
          /* @__PURE__ */ React.createElement("span", null, " ", item.name)
        ), deletable && /* @__PURE__ */ React.createElement(
          p$4,
          {
            color: "#808080",
            className: "nut-uploader-preview-img-file-del",
            onClick: () => onDeleteItem(item, index)
          }
        ), item.status === "uploading" && /* @__PURE__ */ React.createElement(
          Progress,
          {
            percent: item.percentage,
            color: "linear-gradient(270deg, rgba(18,126,255,1) 0%,rgba(32,147,255,1) 32.815625%,rgba(13,242,204,1) 100%)",
            showText: false
          }
        ))
      );
    }));
  };
  class FileItem {
    constructor() {
      this.status = "ready";
      this.message = "";
      this.uid = (/* @__PURE__ */ new Date()).getTime().toString();
      this.percentage = 0;
      this.formData = {};
    }
  }
  const defaultProps$G = {
    ...ComponentDefaults,
    url: "",
    maxCount: 1,
    previewType: "picture",
    fit: "cover",
    name: "file",
    accept: "*",
    disabled: false,
    autoUpload: true,
    multiple: false,
    maxFileSize: Number.MAX_VALUE,
    data: {},
    headers: {},
    method: "post",
    xhrState: 200,
    timeout: 1e3 * 30,
    withCredentials: false,
    clearInput: true,
    preview: true,
    deletable: true,
    capture: false,
    uploadIcon: /* @__PURE__ */ React.createElement(c$1, { width: "20px", height: "20px", color: "#808080" }),
    deleteIcon: /* @__PURE__ */ React.createElement(p$3, { color: "rgba(0,0,0,0.6)" }),
    beforeDelete: (file, files) => {
      return true;
    }
  };
  const InternalUploader = (props, ref) => {
    const { locale } = useConfig();
    const fileListRef = React.useRef([]);
    const {
      children,
      uploadIcon,
      deleteIcon,
      uploadLabel,
      name,
      accept,
      defaultValue,
      value,
      previewType,
      fit,
      disabled,
      multiple,
      url,
      previewUrl,
      headers,
      timeout,
      method,
      xhrState,
      withCredentials,
      data,
      preview,
      deletable,
      maxCount,
      capture,
      maxFileSize,
      className,
      autoUpload,
      clearInput,
      onStart,
      onDelete,
      onChange,
      onFileItemClick,
      onProgress,
      onSuccess,
      onUpdate,
      onFailure,
      onOversize,
      beforeUpload,
      beforeXhrUpload,
      beforeDelete,
      ...restProps
    } = { ...defaultProps$G, ...props };
    const [fileList, setFileList] = usePropsValue({
      value,
      defaultValue,
      finalValue: [],
      onChange: (v) => {
        onChange == null ? void 0 : onChange(v);
      }
    });
    const [uploadQueue, setUploadQueue] = React.useState([]);
    const classes = classNames(className, "nut-uploader");
    React.useEffect(() => {
      fileListRef.current = fileList;
    }, [fileList]);
    React.useImperativeHandle(ref, () => ({
      submit: () => {
        Promise.all(uploadQueue).then((res) => {
          res.forEach((i2) => i2.upload());
        });
      },
      clear: () => {
        clearUploadQueue();
      }
    }));
    const clearUploadQueue = (index = -1) => {
      if (index > -1) {
        uploadQueue.splice(index, 1);
        setUploadQueue(uploadQueue);
      } else {
        setUploadQueue([]);
        setFileList([]);
      }
    };
    const clearInputValue = (el) => {
      el.value = "";
    };
    const executeUpload = (fileItem, index) => {
      var _a, _b;
      const uploadOption = new UploadOptions();
      uploadOption.url = url;
      for (const [key, value2] of Object.entries(data)) {
        (_a = fileItem.formData) == null ? void 0 : _a.append(key, value2);
      }
      uploadOption.formData = fileItem.formData;
      uploadOption.timeout = timeout * 1;
      uploadOption.method = method;
      uploadOption.xhrState = xhrState;
      uploadOption.headers = headers;
      uploadOption.withCredentials = withCredentials;
      uploadOption.beforeXhrUpload = beforeXhrUpload;
      try {
        uploadOption.sourceFile = (_b = fileItem.formData) == null ? void 0 : _b.get(name);
      } catch (error) {
        console.warn(error);
      }
      uploadOption.onStart = (option) => {
        clearUploadQueue(index);
        setFileList(
          fileListRef.current.map((item) => {
            if (item.uid === fileItem.uid) {
              item.status = "ready";
              item.message = locale.uploader.readyUpload;
            }
            return item;
          })
        );
        onStart == null ? void 0 : onStart(option);
      };
      uploadOption.onProgress = (e, option) => {
        setFileList(
          fileListRef.current.map((item) => {
            if (item.uid === fileItem.uid) {
              item.status = UPLOADING;
              item.message = locale.uploader.uploading;
              item.percentage = (e.loaded / e.total * 100).toFixed(0);
              onProgress == null ? void 0 : onProgress({ e, option, percentage: item.percentage });
            }
            return item;
          })
        );
      };
      uploadOption.onSuccess = (responseText, option) => {
        const list = fileListRef.current.map((item) => {
          if (item.uid === fileItem.uid) {
            item.status = SUCCESS;
            item.message = locale.uploader.success;
            item.responseText = responseText;
          }
          return item;
        });
        setFileList(list);
        onUpdate == null ? void 0 : onUpdate(list);
        onSuccess == null ? void 0 : onSuccess({
          responseText,
          option,
          files: list
        });
      };
      uploadOption.onFailure = (responseText, option) => {
        const list = fileListRef.current.map((item) => {
          if (item.uid === fileItem.uid) {
            item.status = ERROR;
            item.message = locale.uploader.error;
            item.responseText = responseText;
          }
          return item;
        });
        setFileList(list);
        onFailure == null ? void 0 : onFailure({
          responseText,
          option,
          files: list
        });
      };
      const task = new Upload(uploadOption);
      if (autoUpload) {
        task.upload();
      } else {
        uploadQueue.push(
          new Promise((resolve, reject) => {
            resolve(task);
          })
        );
        setUploadQueue(uploadQueue);
      }
    };
    const readFile = (files) => {
      const results = [];
      files.forEach((file, index) => {
        var _a;
        const formData = new FormData();
        formData.append(name, file);
        const fileItem = new FileItem();
        fileItem.name = file.name;
        fileItem.status = "ready";
        fileItem.type = file.type;
        fileItem.formData = formData;
        fileItem.uid = file.lastModified + fileItem.uid;
        fileItem.message = autoUpload ? locale.uploader.readyUpload : locale.uploader.waitingUpload;
        executeUpload(fileItem, index);
        if (preview && ((_a = file.type) == null ? void 0 : _a.includes("image"))) {
          const reader = new FileReader();
          reader.onload = (event) => {
            fileItem.url = event.target.result;
            results.push(fileItem);
          };
          reader.readAsDataURL(file);
        } else {
          results.push(fileItem);
        }
      });
      setFileList([...fileList, ...results]);
    };
    const filterFiles = (files) => {
      const maximum = maxCount * 1;
      const oversizes = new Array();
      const filterFile = files.filter((file) => {
        if (file.size > maxFileSize) {
          oversizes.push(file);
          return false;
        }
        return true;
      });
      oversizes.length && (onOversize == null ? void 0 : onOversize(files));
      if (filterFile.length > maximum) {
        filterFile.splice(maximum, filterFile.length - maximum);
      }
      if (fileList.length !== 0) {
        const index = maximum - fileList.length;
        filterFile.splice(index, filterFile.length - index);
      }
      return filterFile;
    };
    const deleted = (file, index) => {
      const deletedFileList = fileList.filter((file2, idx) => idx !== index);
      onDelete == null ? void 0 : onDelete(file, deletedFileList);
      setFileList(deletedFileList);
    };
    const onDeleteItem = (file, index) => {
      clearUploadQueue(index);
      funcInterceptor(beforeDelete, {
        args: [file, fileList],
        done: () => deleted(file, index)
      });
    };
    const fileChange = (event) => {
      if (disabled) return;
      const $el = event.target;
      const { files } = $el;
      if (beforeUpload) {
        beforeUpload(new Array().slice.call(files)).then(
          (f) => {
            const _files = filterFiles(new Array().slice.call(f));
            if (!_files.length) $el.value = "";
            readFile(_files);
          }
        );
      } else {
        const _files = filterFiles(new Array().slice.call(files));
        readFile(_files);
      }
      if (clearInput) {
        clearInputValue($el);
      }
    };
    const handleItemClick = (file, index) => {
      onFileItemClick == null ? void 0 : onFileItemClick(file, index);
    };
    return /* @__PURE__ */ React.createElement("div", { className: classes, ...restProps }, (children || previewType === "list") && /* @__PURE__ */ React.createElement("div", { className: "nut-uploader-slot" }, children || /* @__PURE__ */ React.createElement(Button, { size: "small", type: "primary" }, locale.uploader.list), Number(maxCount) > fileList.length && /* @__PURE__ */ React.createElement(
      "input",
      {
        className: "nut-uploader-input",
        type: "file",
        capture,
        name,
        accept,
        disabled,
        multiple,
        onChange: fileChange
      }
    )), /* @__PURE__ */ React.createElement(
      Preview,
      {
        ...{
          fileList,
          previewType,
          deletable,
          onDeleteItem,
          handleItemClick,
          previewUrl,
          children,
          deleteIcon
        }
      }
    ), Number(maxCount) > fileList.length && previewType === "picture" && !children && /* @__PURE__ */ React.createElement(
      "div",
      {
        className: classNames("nut-uploader-upload", previewType, {
          "nut-uploader-upload-disabled": disabled
        })
      },
      /* @__PURE__ */ React.createElement("div", { className: "nut-uploader-icon" }, uploadIcon, /* @__PURE__ */ React.createElement("span", { className: "nut-uploader-icon-tip" }, uploadLabel)),
      /* @__PURE__ */ React.createElement(
        "input",
        {
          className: "nut-uploader-input",
          type: "file",
          capture,
          name,
          accept,
          disabled,
          multiple,
          onChange: fileChange
        }
      )
    ));
  };
  const Uploader = React.forwardRef(InternalUploader);
  Uploader.displayName = "NutUploader";
  function mergeProps(...items) {
    const ret = {};
    items.forEach((item) => {
      if (item) {
        Object.keys(item).forEach((key) => {
          if (item[key] !== void 0) {
            ret[key] = item[key];
          }
        });
      }
    });
    return ret;
  }
  const defaultProps$F = {
    ...ComponentDefaults,
    visible: false,
    description: "",
    options: [],
    optionKey: { name: "name", description: "description" },
    cancelText: "",
    onCancel: () => {
    },
    onSelect: () => {
    }
  };
  const ActionSheet = (props) => {
    const {
      children,
      cancelText,
      optionKey,
      title,
      description,
      options: options2,
      onCancel,
      onSelect,
      visible,
      className,
      style,
      ...rest
    } = mergeProps(defaultProps$F, props);
    const classPrefix2 = "nut-actionsheet";
    const cancelActionSheet = () => {
      onCancel && onCancel();
    };
    const chooseItem = (item, index) => {
      if (!item.disabled) {
        onSelect && onSelect(item, index);
      }
    };
    return /* @__PURE__ */ React.createElement(
      Popup,
      {
        ...rest,
        round: true,
        visible,
        position: "bottom",
        title,
        description,
        className: classPrefix2,
        onClose: () => {
          onCancel && onCancel();
        }
      },
      /* @__PURE__ */ React.createElement("div", { className: `${className}`, style }, options2.length ? /* @__PURE__ */ React.createElement("div", { className: `${classPrefix2}-list` }, options2.map((item, index) => {
        return /* @__PURE__ */ React.createElement(
          "div",
          {
            className: `${classPrefix2}-item ${item.disabled ? "disabled" : ""} ${item.danger ? "danger" : ""}`,
            key: index,
            onClick: () => chooseItem(item, index)
          },
          item[optionKey.name],
          /* @__PURE__ */ React.createElement("div", { className: `${classPrefix2}-item-description` }, item[optionKey.description])
        );
      })) : children, cancelText && /* @__PURE__ */ React.createElement(
        "div",
        {
          className: `${classPrefix2}-cancel`,
          onClick: () => cancelActionSheet()
        },
        cancelText
      )),
      /* @__PURE__ */ React.createElement("div", { className: `${classPrefix2}-safe-area` })
    );
  };
  ActionSheet.displayName = "NutActionSheet";
  const fullClone = {
    ...ReactDOM__namespace
  };
  const { version, render: reactRender, unmountComponentAtNode } = fullClone;
  let createRoot;
  try {
    const mainVersion = Number((version || "").split(".")[0]);
    if (mainVersion >= 18 && fullClone.createRoot) {
      createRoot = fullClone.createRoot;
    }
  } catch (e) {
  }
  function toggleWarning(skip) {
    const { __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED } = fullClone;
    if (__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED && typeof __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED === "object") {
      __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.usingClientEntryPoint = skip;
    }
  }
  const MARK = "__nutui_react_root__";
  function legacyRender(node, container) {
    reactRender(node, container);
  }
  function concurrentRender(node, container) {
    toggleWarning(true);
    const root2 = container[MARK] || createRoot(container);
    toggleWarning(false);
    root2.render(node);
    container[MARK] = root2;
  }
  function render(node, container) {
    if (createRoot) {
      concurrentRender(node, container);
      return;
    }
    legacyRender(node, container);
  }
  function legacyUnmount(container) {
    return unmountComponentAtNode(container);
  }
  async function concurrentUnmount(container) {
    return Promise.resolve().then(() => {
      var _a;
      (_a = container[MARK]) == null ? void 0 : _a.unmount();
      delete container[MARK];
    });
  }
  function unmount(container) {
    if (createRoot) {
      return concurrentUnmount(container);
    }
    return legacyUnmount(container);
  }
  function ConfirmDialog(props) {
    return /* @__PURE__ */ React.createElement(Dialog, { ...props }, props.content);
  }
  const normalizeConfig = (config2) => {
    if (config2.isNotice) {
      let { icon } = config2;
      if (!icon && icon !== null) {
        switch (config2.noticeType) {
          case "alert":
            icon = "";
            break;
        }
      }
      config2.hideCancelButton = true;
    }
    return config2;
  };
  const confirm = (config2, renderFunc) => {
    const div = document.createElement("div");
    document.body.appendChild(div);
    let dialogConfig = {
      ...config2,
      visible: false
    };
    const render$1 = (props, callback) => {
      render(/* @__PURE__ */ React.createElement(ConfirmDialog, { ...props, onCancel: () => onCancel() }), div);
      callback && callback();
    };
    const renderFunction = render$1;
    const onConfirm = () => {
      const _onConfirm = config2.onConfirm || config2.onConfirm;
      const ret = _onConfirm == null ? void 0 : _onConfirm();
      if (ret && ret.then) {
        renderFunction(dialogConfig);
        return ret.then(
          () => {
            onCancel(true);
          },
          (e) => {
            console.error(e);
            renderFunction(dialogConfig);
          }
        );
      }
      if (!ret) {
        onCancel(true);
      }
    };
    dialogConfig.onConfirm = onConfirm;
    dialogConfig = normalizeConfig(dialogConfig);
    dialogConfig.visible = true;
    renderFunction(dialogConfig);
    const destroy = () => {
      unmount(div);
      if (div == null ? void 0 : div.parentNode) {
        div.parentNode.removeChild(div);
      }
    };
    const onCancel = (confirm2) => {
      !confirm2 && config2.onCancel && config2.onCancel();
      dialogConfig.visible = false;
      dialogConfig.onClose = () => {
        config2.onClose && config2.onClose();
      };
      renderFunction(dialogConfig, () => {
        destroy();
      });
    };
    const update2 = (newConfig) => {
      dialogConfig = {
        ...dialogConfig,
        title: config2.title,
        // 避免 newConfig 未传递 title 时，icon 出现多个的问题
        ...newConfig
      };
      dialogConfig = normalizeConfig(dialogConfig);
      renderFunction(dialogConfig);
    };
    const close = () => {
      dialogConfig.visible = false;
      dialogConfig.onClose = () => {
        config2.onClose && config2.onClose();
        destroy();
      };
      renderFunction(dialogConfig);
    };
    return {
      close,
      update: update2
    };
  };
  const Content = (props) => {
    const {
      visible,
      title,
      header,
      footer,
      close,
      footerDirection,
      onClick,
      children
    } = props;
    const classPrefix2 = "nut-dialog";
    const renderHeader = () => {
      return title ? /* @__PURE__ */ React.createElement("div", { className: `${classPrefix2}-header` }, title) : null;
    };
    const renderFooter = () => {
      return footer ? /* @__PURE__ */ React.createElement(
        "div",
        {
          className: classNames(`${classPrefix2}-footer`, {
            [footerDirection]: footerDirection
          })
        },
        footer
      ) : null;
    };
    const handleClick2 = (e) => {
      onClick && onClick(e);
    };
    return /* @__PURE__ */ React.createElement(
      "div",
      {
        className: classNames(`${classPrefix2}-outer`, props.className),
        style: props.style,
        onClick: (e) => handleClick2(e)
      },
      close,
      header,
      /* @__PURE__ */ React.createElement(
        "div",
        {
          className: classPrefix2,
          style: { display: visible ? "flex" : "none" }
        },
        renderHeader(),
        /* @__PURE__ */ React.createElement("div", { className: `${classPrefix2}-content` }, /* @__PURE__ */ React.createElement(React.Fragment, null, children)),
        renderFooter()
      )
    );
  };
  Content.displayName = "NutContent";
  const defaultDialogProps = {
    ...ComponentDefaults,
    overlay: true,
    overlayStyle: {},
    overlayClassName: "",
    onCancel: () => {
    },
    onClose: () => {
    },
    onOverlayClick: (e) => true,
    ...defaultOverlayProps
  };
  const DialogWrap = (props) => {
    const {
      visible,
      overlay,
      overlayStyle,
      overlayClassName,
      closeOnOverlayClick,
      lockScroll,
      onClose,
      onCancel,
      onOverlayClick
    } = mergeProps(defaultDialogProps, props);
    const onHandleClickOverlay = (e) => {
      if (closeOnOverlayClick && visible && e.target === e.currentTarget) {
        const closed = onOverlayClick && onOverlayClick(e);
        closed && (onClose == null ? void 0 : onClose());
        closed && (onCancel == null ? void 0 : onCancel());
      }
    };
    return /* @__PURE__ */ React.createElement(React.Fragment, null, overlay ? /* @__PURE__ */ React.createElement(
      Overlay,
      {
        style: overlayStyle,
        className: classNames("nut-dialog-overlay", overlayClassName),
        visible,
        closeOnOverlayClick,
        lockScroll,
        onClick: onHandleClickOverlay
      }
    ) : null, /* @__PURE__ */ React.createElement(
      CSSTransition,
      {
        in: visible,
        timeout: 300,
        classNames: "fadeDialog",
        unmountOnExit: true,
        appear: true
      },
      /* @__PURE__ */ React.createElement(Content, { ...props, visible })
    ));
  };
  DialogWrap.displayName = "NutDialogWrap";
  const defaultProps$E = {
    ...ComponentDefaults,
    confirmText: "",
    cancelText: "",
    overlay: true,
    closeOnOverlayClick: true,
    hideConfirmButton: false,
    hideCancelButton: false,
    disableConfirmButton: false,
    footerDirection: "horizontal",
    lockScroll: true,
    closeIconPosition: "bottom",
    closeIcon: false,
    beforeCancel: () => true,
    beforeClose: () => true
  };
  const BaseDialog = (props, ref) => {
    const { locale } = useConfig();
    const {
      visible,
      footer,
      hideConfirmButton,
      hideCancelButton,
      lockScroll,
      disableConfirmButton,
      closeOnOverlayClick,
      confirmText,
      cancelText,
      closeIconPosition,
      closeIcon,
      onClose,
      onCancel,
      onConfirm,
      beforeCancel,
      beforeClose,
      ...restProps
    } = mergeProps(defaultProps$E, props);
    const classPrefix2 = "nut-dialog";
    const [loading, setLoading] = React.useState(false);
    const renderFooter = () => {
      if (footer === null) return "";
      const handleCancel = (e) => {
        e.stopPropagation();
        if (!(beforeCancel == null ? void 0 : beforeCancel())) return;
        if (!(beforeClose == null ? void 0 : beforeClose())) return;
        onClose == null ? void 0 : onClose();
        onCancel == null ? void 0 : onCancel();
      };
      const handleOk = async (e) => {
        e.stopPropagation();
        setLoading(true);
        try {
          await (onConfirm == null ? void 0 : onConfirm(e));
          setLoading(false);
          onClose == null ? void 0 : onClose();
        } catch {
          setLoading(false);
        }
      };
      return footer || /* @__PURE__ */ React.createElement(React.Fragment, null, !hideCancelButton && /* @__PURE__ */ React.createElement(
        Button,
        {
          type: "default",
          className: `${classPrefix2}-footer-cancel`,
          onClick: (e) => handleCancel(e)
        },
        cancelText || locale.cancel
      ), !hideConfirmButton && /* @__PURE__ */ React.createElement(
        Button,
        {
          type: "primary",
          className: classNames(`${classPrefix2}-footer-ok`, {
            disabled: disableConfirmButton
          }),
          disabled: disableConfirmButton,
          onClick: (e) => handleOk(e),
          loading
        },
        confirmText || locale.confirm
      ));
    };
    const renderCloseIcon = () => {
      if (!closeIcon) return null;
      const handleCancel = () => {
        if (!(beforeCancel == null ? void 0 : beforeCancel())) return;
        if (!(beforeClose == null ? void 0 : beforeClose())) return;
        onClose == null ? void 0 : onClose();
        onCancel == null ? void 0 : onCancel();
      };
      const closeClasses = classNames({
        [`${classPrefix2}-close`]: true,
        [`${classPrefix2}-close-${closeIconPosition}`]: true
      });
      return /* @__PURE__ */ React.createElement("div", { className: closeClasses, onClick: handleCancel }, React.isValidElement(closeIcon) ? closeIcon : /* @__PURE__ */ React.createElement(n$5, null));
    };
    return /* @__PURE__ */ React.createElement("div", { style: { display: visible ? "block" : "none" } }, /* @__PURE__ */ React.createElement(
      DialogWrap,
      {
        ...props,
        visible,
        lockScroll,
        footer: renderFooter(),
        close: renderCloseIcon(),
        onClose,
        onCancel
      }
    ));
  };
  const Dialog = React.forwardRef(BaseDialog);
  Dialog.confirm = (props) => {
    return confirm(props);
  };
  ["alert"].forEach((type) => {
    Dialog[type] = (props) => {
      return confirm({
        ...props,
        isNotice: false,
        noticeType: type
      });
    };
  });
  Dialog.displayName = "NutDialog";
  const defaultProps$D = {
    ...ComponentDefaults,
    attract: false,
    direction: void 0,
    boundary: {
      top: 0,
      left: 0,
      right: 0,
      bottom: 0
    }
  };
  const Drag = (props) => {
    const {
      attract,
      direction,
      boundary,
      onDrag,
      onDragStart,
      onDragEnd,
      children,
      className,
      style,
      ...reset
    } = {
      ...defaultProps$D,
      ...props
    };
    const classPrefix2 = "nut-drag";
    const [boundaryState, setBoundaryState] = React.useState(boundary);
    const myDrag = React.useRef(null);
    const [currstyle, api] = useSpring(() => ({
      x: 0,
      y: 0
    }));
    const middleLine = React.useRef(0);
    const getInfo = () => {
      const el = myDrag.current;
      if (el) {
        const { offsetTop, offsetLeft } = el;
        const { offsetWidth, offsetHeight } = el.querySelector(
          `.${classPrefix2}-inner`
        );
        const { clientWidth, clientHeight } = document.documentElement;
        const { top, left, bottom, right } = boundary;
        setBoundaryState({
          top: -offsetTop + top,
          left: -offsetLeft + left,
          bottom: clientHeight - offsetHeight - offsetTop - bottom,
          right: clientWidth - offsetWidth - offsetLeft - right
        });
        middleLine.current = clientWidth - offsetWidth - offsetLeft - (clientWidth - offsetWidth) / 2;
      }
    };
    const bind = useDrag(
      (state) => {
        const {
          down,
          last,
          offset: [x, y],
          first
        } = state;
        first && (onDragStart == null ? void 0 : onDragStart());
        onDrag == null ? void 0 : onDrag({ offset: [x, y] });
        last && (onDragEnd == null ? void 0 : onDragEnd({ offset: [x, y] }));
        api.start({ x, y, immediate: down });
        if (last) {
          if (direction !== "y" && attract) {
            if (x < middleLine.current) {
              api.start({ x: boundaryState.left, y, immediate: down });
            } else {
              api.start({
                x: boundaryState.right,
                y,
                immediate: down
              });
            }
          }
        }
      },
      {
        from: () => [currstyle.x.get(), currstyle.y.get()],
        axis: direction,
        bounds: boundaryState
      }
    );
    React.useEffect(() => {
      getInfo();
    }, [myDrag]);
    return /* @__PURE__ */ React.createElement(
      "div",
      {
        style,
        className: `${classPrefix2} ${className}`,
        ...reset,
        ref: myDrag
      },
      /* @__PURE__ */ React.createElement(
        animated.div,
        {
          style: currstyle,
          ...bind(),
          className: `${classPrefix2}-inner`
        },
        children
      )
    );
  };
  Drag.displayName = "NutDrag";
  const getButtonType = (actions, index) => {
    if (!actions || actions.length === 0) return "default";
    const action = actions[index];
    if (action.type) return action.type;
    return actions.length > 1 && index === 0 ? "default" : "primary";
  };
  const defaultStatus = {
    empty: "https://storage.360buyimg.com/imgtools/30186cfda0-0d3eee40-c0ac-11ee-9382-9125782aa3b8.png",
    error: "https://storage.360buyimg.com/imgtools/f3278d0ebb-0ce360c0-c0ac-11ee-8375-193101bb1a46.png",
    network: "https://storage.360buyimg.com/imgtools/43c30f7e29-0d483d10-c0ac-11ee-bec4-eb4d2a09a51d.png"
  };
  const defaultProps$C = {
    ...ComponentDefaults,
    title: "",
    description: "",
    imageSize: "",
    size: "base",
    status: "empty",
    actions: []
  };
  const classPrefix$e = `nut-empty`;
  const Empty = (props) => {
    const {
      image,
      imageSize,
      title,
      description,
      children,
      className,
      size,
      status,
      actions,
      ...rest
    } = {
      ...defaultProps$C,
      ...props
    };
    const [imgStyle, setImgStyle] = React.useState({});
    const imageUrl = image || defaultStatus[status];
    const imageNode = typeof imageUrl === "string" ? /* @__PURE__ */ React.createElement("img", { className: "img", src: imageUrl, alt: "empty" }) : imageUrl;
    React.useEffect(() => {
      setImgStyle(() => {
        if (typeof imageSize !== "number" && typeof imageSize !== "string") {
          return {};
        }
        if (typeof imageSize === "number") {
          return {
            width: `${imageSize}px`,
            height: `${imageSize}px`
          };
        }
        return {
          width: imageSize,
          height: imageSize
        };
      });
    }, [imageSize]);
    const classes = classNames({
      [`${classPrefix$e}-${size}`]: size !== "base"
    });
    const cls = classNames(classPrefix$e, classes, className);
    return /* @__PURE__ */ React.createElement("div", { className: cls, ...rest }, /* @__PURE__ */ React.createElement("div", { className: `${classPrefix$e}-image`, style: imgStyle }, imageNode), typeof title === "string" && title ? /* @__PURE__ */ React.createElement("div", { className: `${classPrefix$e}-title` }, title) : title, typeof description === "string" ? /* @__PURE__ */ React.createElement("div", { className: `${classPrefix$e}-description` }, description) : description, actions.length > 0 && /* @__PURE__ */ React.createElement("div", { className: `${classPrefix$e}-actions` }, actions.map((item, index) => {
      return /* @__PURE__ */ React.createElement(
        Button,
        {
          className: classNames({
            [`${classPrefix$e}-actions-right`]: actions.length === 1,
            [`${classPrefix$e}-actions-left`]: actions.length > 1 && index === 0
          }),
          style: item.style,
          type: getButtonType(actions, index),
          size: item.size || "small",
          fill: item.fill || "outline",
          disabled: item.disabled || false,
          key: `action-${index}`,
          onClick: item.onClick || (() => void 0)
        },
        item == null ? void 0 : item.text
      );
    })), children);
  };
  Empty.displayName = "NutEmpty";
  const defaultProps$B = {
    ...ComponentDefaults,
    type: "default",
    hasMore: true,
    threshold: 200,
    target: "",
    capture: false,
    pullRefresh: false
  };
  const classPrefix$d = `nut-infiniteloading`;
  const InfiniteLoading = (props) => {
    const { locale } = useConfig();
    const {
      children,
      type,
      hasMore,
      threshold,
      target,
      capture,
      pullRefresh,
      pullingText,
      loadingText,
      loadMoreText,
      className,
      onRefresh,
      onLoadMore,
      onScroll,
      ...restProps
    } = {
      ...defaultProps$B,
      ...props
    };
    const [isInfiniting, setIsInfiniting] = React.useState(false);
    const scroller = React.useRef(null);
    const refreshTop = React.useRef(null);
    const scrollEl = React.useRef(null);
    const isTouching = React.useRef(false);
    const beforeScrollTop = React.useRef(0);
    const refreshMaxH = React.useRef(0);
    const y = React.useRef(0);
    const distance = React.useRef(0);
    const classes = classNames(classPrefix$d, className, `${classPrefix$d}-${type}`);
    React.useEffect(() => {
      var _a;
      if (target && document.getElementById(target)) {
        scrollEl.current = document.getElementById(target);
      } else {
        scrollEl.current = window;
      }
      (_a = scrollEl.current) == null ? void 0 : _a.addEventListener("scroll", handleScroll, capture);
      return () => {
        var _a2;
        (_a2 = scrollEl.current) == null ? void 0 : _a2.removeEventListener("scroll", handleScroll, capture);
      };
    }, [hasMore, isInfiniting, onLoadMore]);
    React.useEffect(() => {
      const element = scroller.current;
      element.addEventListener("touchmove", touchMove, { passive: false });
      return () => {
        element.removeEventListener("touchmove", touchMove, {
          passive: false
        });
      };
    }, []);
    const getStyle = () => {
      return {
        height: distance.current < 0 ? `0px` : `${distance.current}px`,
        transition: isTouching.current ? `height 0s cubic-bezier(0.25,0.1,0.25,1)` : `height 0.2s cubic-bezier(0.25,0.1,0.25,1)`
      };
    };
    const handleScroll = async () => {
      if (!isScrollAtBottom() || !hasMore || isInfiniting) {
        return;
      }
      setIsInfiniting(true);
      await (onLoadMore == null ? void 0 : onLoadMore());
      infiniteDone();
    };
    const infiniteDone = () => {
      setIsInfiniting(false);
    };
    const getRefreshTop = () => {
      return refreshTop.current;
    };
    const refreshDone = () => {
      distance.current = 0;
      getRefreshTop().style.height = `${distance.current}px`;
      isTouching.current = false;
    };
    const touchStart = (event) => {
      if (beforeScrollTop.current === 0 && !isTouching.current && pullRefresh) {
        y.current = event.touches[0].pageY;
        isTouching.current = true;
        const childHeight = getRefreshTop().firstElementChild.offsetHeight;
        refreshMaxH.current = Math.floor(childHeight * 1 + 10);
      }
    };
    const touchMove = (event) => {
      distance.current = event.touches[0].pageY - y.current;
      if (distance.current > 0 && isTouching.current) {
        event.preventDefault();
        if (distance.current >= refreshMaxH.current) {
          distance.current = refreshMaxH.current;
          getRefreshTop().style.height = `${distance.current}px`;
        } else {
          getRefreshTop().style.height = `${distance.current}px`;
        }
      } else {
        distance.current = 0;
        getRefreshTop().style.height = `${distance.current}px`;
        isTouching.current = false;
      }
    };
    const touchEnd = async () => {
      if (distance.current < refreshMaxH.current) {
        distance.current = 0;
        getRefreshTop().style.height = `${distance.current}px`;
        isTouching.current = false;
      } else {
        await (onRefresh == null ? void 0 : onRefresh());
        refreshDone();
      }
    };
    const getWindowScrollTop = () => {
      return window.scrollY !== void 0 ? window.scrollY : (document.documentElement || document.body.parentNode || document.body).scrollTop;
    };
    const calculateTopPosition = (el) => {
      return !el ? 0 : el.offsetTop + calculateTopPosition(el.offsetParent);
    };
    const isScrollAtBottom = () => {
      let offsetDistance = 0;
      let resScrollTop = 0;
      let direction = "down";
      const windowScrollTop = getWindowScrollTop();
      if (!target || !document.getElementById(target)) {
        if (scroller.current) {
          offsetDistance = calculateTopPosition(scroller.current) + scroller.current.offsetHeight - windowScrollTop - window.innerHeight;
        }
        resScrollTop = windowScrollTop;
      } else {
        const { scrollHeight, clientHeight, scrollTop } = scrollEl.current;
        offsetDistance = scrollHeight - clientHeight - scrollTop;
        resScrollTop = scrollTop;
      }
      if (beforeScrollTop.current > resScrollTop) {
        direction = "up";
      } else {
        direction = "down";
      }
      beforeScrollTop.current = resScrollTop;
      onScroll && onScroll(resScrollTop);
      return offsetDistance <= threshold && direction === "down";
    };
    return /* @__PURE__ */ React.createElement(
      "div",
      {
        className: classes,
        ref: scroller,
        onTouchStart: touchStart,
        onTouchEnd: touchEnd,
        ...restProps
      },
      /* @__PURE__ */ React.createElement("div", { className: "nut-infinite-top", ref: refreshTop, style: getStyle() }, /* @__PURE__ */ React.createElement("div", { className: "nut-infinite-top-tips" }, pullingText || locale.infiniteloading.pullRefreshText)),
      /* @__PURE__ */ React.createElement("div", { className: "nut-infinite-container" }, children),
      /* @__PURE__ */ React.createElement("div", { className: "nut-infinite-bottom" }, isInfiniting ? /* @__PURE__ */ React.createElement("div", { className: "nut-infinite-bottom-tips" }, loadingText || locale.infiniteloading.loadText) : !hasMore && /* @__PURE__ */ React.createElement("div", { className: "nut-infinite-bottom-tips" }, loadMoreText || locale.infiniteloading.loadMoreText))
    );
  };
  InfiniteLoading.displayName = "NutInfiniteLoading";
  const loadingMap = {
    circular: n$3,
    spinner: n$4
  };
  const defaultProps$A = {
    ...ComponentDefaults,
    // 对比一下,个人感觉还是Loading1比较好看一些,所以用它作为了默认的loading图标
    type: "circular",
    direction: "horizontal"
  };
  const Loading = (props) => {
    const { className, style, children, direction, icon, ...rest } = {
      ...defaultProps$A,
      ...props
    };
    const classPrefix2 = "nut-loading";
    const CurLoadingIcon = loadingMap[rest.type] || n$3;
    return /* @__PURE__ */ React.createElement(
      "div",
      {
        className: classNames(
          classPrefix2,
          direction === "vertical" ? `${classPrefix2}-vertical` : "",
          className
        ),
        style
      },
      /* @__PURE__ */ React.createElement("div", { className: `${classPrefix2}-icon-box` }, icon || /* @__PURE__ */ React.createElement(CurLoadingIcon, { className: `${classPrefix2}-icon` })),
      children ? /* @__PURE__ */ React.createElement("div", { className: `${classPrefix2}-text` }, children) : ""
    );
  };
  Loading.displayName = "NutLoading";
  const defaultProps$z = {
    ...ComponentDefaults,
    align: "left",
    direction: "horizontal",
    list: [],
    duration: 1e3,
    height: 40,
    content: "",
    closeable: false,
    wrap: false,
    leftIcon: /* @__PURE__ */ React.createElement(c$2, { width: 16, height: 16 }),
    rightIcon: null,
    right: null,
    delay: 1,
    scrollable: null,
    speed: 50
  };
  const NoticeBar = (props) => {
    const rtl = useRtl();
    const {
      children,
      className,
      style,
      align,
      direction,
      list,
      duration,
      height,
      content,
      closeable,
      wrap,
      leftIcon,
      rightIcon,
      right,
      delay,
      scrollable,
      speed,
      close,
      click,
      onClose,
      onClick,
      onItemClick
    } = {
      ...defaultProps$z,
      ...props
    };
    const classPrefix2 = "nut-noticebar";
    const wrapRef = React.useRef(null);
    const contentRef = React.useRef(null);
    const [showNoticeBar, SetShowNoticeBar] = React.useState(true);
    const scrollList = React.useRef([]);
    const [wrapWidth, SetWrapWidth] = React.useState(0);
    const [firstRound, SetFirstRound] = React.useState(true);
    const [animationDuration, SetAnimationDuration] = React.useState(0);
    const [offsetWidth, SetOffsetW] = React.useState(0);
    const [animationClass, SetAnimationClass] = React.useState("");
    const [animate, SetAnimate] = React.useState(false);
    const [timer, SetTimer] = React.useState(0);
    const [isCanScroll, SetIsCanScroll] = React.useState(null);
    const isVertical = direction === "vertical";
    const [rect, setRect] = React.useState(null);
    let active = 0;
    const [ready, setReady] = React.useState(false);
    const container = React.useRef(null);
    const innerRef = React.useRef(null);
    const swiperRef = React.useRef({
      moving: false,
      autoplayTimer: null,
      width: 0,
      height: 0,
      offset: 0,
      size: 0
    });
    const [childOffset, setChildOffset] = React.useState([]);
    const [offset, setOffset] = React.useState(0);
    const { childs, childCount } = React.useMemo(() => {
      let childCount2 = 0;
      const childs2 = React.Children.map(children, (child) => {
        if (!React.isValidElement(child)) return null;
        childCount2++;
        return child;
      });
      return {
        childs: childs2,
        childCount: childCount2
      };
    }, [children]);
    let trackSize = childCount * Number(height);
    const minOffset = (() => {
      if (rect) {
        const base = isVertical ? rect.height : rect.width;
        return base - Number(height) * childCount;
      }
      return 0;
    })();
    React.useEffect(() => {
      if (isVertical) {
        if (children) {
          scrollList.current = [].concat(childs);
        } else {
          scrollList.current = [].concat(list);
          startRollEasy();
        }
      } else {
        initScrollWrap();
      }
      return () => {
        clearInterval(timer);
      };
    }, []);
    React.useEffect(() => {
      initScrollWrap();
    }, [content]);
    React.useEffect(() => {
      if (list && list.length) {
        scrollList.current = [].concat(list);
      }
    }, [list]);
    const initScrollWrap = (value) => {
      if (showNoticeBar === false) {
        return;
      }
      setTimeout(() => {
        if (!wrapRef.current || !contentRef.current) {
          return;
        }
        const wrapW = getRect(wrapRef.current).width;
        const offsetW = getRect(contentRef.current).width;
        const canScroll = align === "left" && scrollable == null ? offsetW > wrapW : scrollable;
        SetIsCanScroll(canScroll);
        if (canScroll) {
          SetWrapWidth(wrapW);
          SetOffsetW(offsetW);
          SetAnimationDuration(offsetW / speed);
          SetAnimationClass("play");
        } else {
          SetAnimationClass("");
        }
      }, 0);
    };
    const handleClick2 = (event) => {
      click && click(event);
      onClick && onClick(event);
    };
    const onClickIcon = (event) => {
      event.stopPropagation();
      SetShowNoticeBar(!closeable);
      close && close(event);
      onClose && onClose(event);
    };
    const onAnimationEnd = () => {
      SetFirstRound(false);
      setTimeout(() => {
        SetAnimationDuration((offsetWidth + wrapWidth) / speed);
        SetAnimationClass("play-infinite");
      }, 0);
    };
    const time = height / speed / 4 < 1 ? Number((height / speed / 4).toFixed(1)) * 1e3 : ~~(height / speed / 4) * 1e3;
    const startRollEasy = () => {
      showhorseLamp();
      const timerCurr = window.setInterval(showhorseLamp, time + Number(duration));
      SetTimer(timerCurr);
    };
    const showhorseLamp = () => {
      SetAnimate(true);
      setTimeout(() => {
        scrollList.current.push(scrollList.current[0]);
        scrollList.current.shift();
        SetAnimate(false);
      }, time);
    };
    const handleClickIcon = (event) => {
      event.stopPropagation();
      SetShowNoticeBar(!closeable);
      close && close(event);
      onClose && onClose(event);
    };
    const isEllipsis = () => {
      if (isCanScroll == null && align === "left") {
        return wrap;
      }
      return !isCanScroll && !wrap;
    };
    const contentStyle = {
      animationDelay: `${firstRound ? delay : 0}s`,
      animationDuration: `${animationDuration}s`,
      transform: `translateX(${firstRound ? 0 : `${rtl ? -wrapWidth : wrapWidth}px`})`
    };
    const barStyle = {
      height: isVertical ? `${height}px` : ""
    };
    const duringTime = height / speed / 4 < 1 ? Number((height / speed / 4).toFixed(1)) : ~~(height / speed / 4);
    const noDuring = height / speed < 1 ? (height / speed).toFixed(1) : ~~(height / speed);
    const horseLampStyle = {
      transition: animate ? `all ${duringTime === 0 ? noDuring : duringTime}s` : "",
      marginTop: animate ? `-${height}px` : ""
    };
    const init = (active2 = 0) => {
      const rects = getRect(container == null ? void 0 : container.current);
      const _active = Math.max(Math.min(childCount - 1, active2), 0);
      const _height = rects.height;
      trackSize = childCount * Number(_height);
      const targetOffset = getOffset(_active);
      swiperRef.current.moving = true;
      if (ready) {
        swiperRef.current.moving = false;
      }
      active2 = _active;
      setRect(rects);
      setOffset(targetOffset);
      setReady(true);
    };
    React.useEffect(() => {
      if (ready) {
        stopAutoPlay();
        autoplay();
      }
      return () => {
        setReady(false);
      };
    }, [ready]);
    React.useEffect(() => {
      if (isVertical && children) {
        init();
        stopAutoPlay();
        autoplay();
      }
    }, [children, container == null ? void 0 : container.current]);
    const stopAutoPlay = () => {
      clearTimeout(swiperRef.current.autoplayTimer);
      swiperRef.current.autoplayTimer = null;
    };
    const autoplay = () => {
      if (childCount <= 1) return;
      stopAutoPlay();
      swiperRef.current.autoplayTimer = setTimeout(
        () => {
          next();
          autoplay();
        },
        Number(duration) + 100 * speed
      );
    };
    const move = ({ pace = 0, offset: offset2 = 0 }) => {
      if (childCount <= 1) return;
      const targetActive = getActive(pace);
      const targetOffset = getOffset(targetActive, offset2);
      if (Array.isArray(children) && children[0] && targetOffset !== minOffset) {
        const rightBound = targetOffset < minOffset;
        childOffset[0] = rightBound ? trackSize : 0;
      }
      if (Array.isArray(children) && children[childCount - 1] && targetOffset !== 0) {
        const leftBound = targetOffset > 0;
        childOffset[childCount - 1] = leftBound ? -trackSize : 0;
      }
      setChildOffset(childOffset);
      active = targetActive;
      setOffset(targetOffset);
      getStyle(targetOffset);
    };
    const next = () => {
      resettPosition();
      requestFrame(() => {
        requestFrame(() => {
          swiperRef.current.moving = false;
          move({
            pace: 1
          });
        });
      });
    };
    const handleItemClick = (event, value) => {
      onItemClick && onItemClick(event, value);
    };
    const getStyle = (moveOffset = offset) => {
      const target = innerRef.current;
      if (!target) {
        return;
      }
      let _offset = 0;
      const val = rect.height - height;
      _offset = moveOffset + Number(active === childCount - 1 && val / 2);
      target.style.transitionDuration = `${swiperRef.current.moving ? 0 : duration}ms`;
      target.style.height = `${Number(height) * childCount}px`;
      target.style.transform = `translate3D(0,${_offset}px,0)`;
    };
    const itemStyle = (index) => {
      const style2 = {};
      if (height) {
        style2.height = `${height}px`;
        style2.lineHeight = `${height}px`;
      }
      const offset2 = childOffset[index];
      if (offset2) {
        style2.transform = `translate3D(0,${offset2}px,0)`;
      }
      return style2;
    };
    const getActive = (pace) => {
      if (pace) {
        const _active = active + pace;
        return range2(_active, -1, childCount);
      }
      return active;
    };
    const getOffset = (active2, offset2 = 0) => {
      const currentPosition = active2 * Number(height);
      const targetOffset = offset2 - currentPosition;
      return targetOffset;
    };
    const requestFrame = (fn) => {
      window.requestAnimationFrame.call(window, fn);
    };
    const range2 = (num, min, max) => {
      return Math.min(Math.max(num, min), max);
    };
    const resettPosition = () => {
      swiperRef.current.moving = true;
      if (active <= -1) {
        move({ pace: childCount });
      }
      if (active >= childCount) {
        move({ pace: -childCount });
      }
    };
    const noticebarClass = classNames({
      [`${classPrefix2}-box`]: true,
      [`${classPrefix2}-box-wrapable`]: wrap,
      [`${classPrefix2}-box-${align}`]: true
    });
    const cls = classNames(classPrefix2, className);
    React.useEffect(() => {
      return () => {
        stopAutoPlay();
      };
    }, []);
    return /* @__PURE__ */ React.createElement("div", { className: cls, style }, showNoticeBar && direction === "horizontal" ? /* @__PURE__ */ React.createElement("div", { className: noticebarClass, style: barStyle, onClick: handleClick2 }, leftIcon ? /* @__PURE__ */ React.createElement("div", { className: "nut-noticebar-box-left-icon" }, leftIcon) : null, /* @__PURE__ */ React.createElement("div", { ref: wrapRef, className: "nut-noticebar-box-wrap" }, /* @__PURE__ */ React.createElement(
      "div",
      {
        ref: contentRef,
        className: `nut-noticebar-box-wrap-content ${animationClass} ${isEllipsis() ? "nut-ellipsis" : ""}`,
        style: contentStyle,
        onAnimationEnd
      },
      children,
      content
    )), right ? /* @__PURE__ */ React.createElement("div", { className: "nut-noticebar-box-right" }, right) : null, closeable || rightIcon ? /* @__PURE__ */ React.createElement("div", { className: "nut-noticebar-box-right-icon", onClick: onClickIcon }, rightIcon || /* @__PURE__ */ React.createElement(n$5, { width: 12, height: 12 })) : null) : null, showNoticeBar && scrollList.current.length > 0 && isVertical ? /* @__PURE__ */ React.createElement(
      "div",
      {
        className: "nut-noticebar-vertical",
        style: barStyle,
        ref: container,
        onClick: handleClick2
      },
      leftIcon ? /* @__PURE__ */ React.createElement("div", { className: "nut-noticebar-box-left-icon" }, leftIcon) : null,
      children ? /* @__PURE__ */ React.createElement("div", { className: "nut-noticebar-box-wrap", ref: innerRef }, scrollList.current.map((item, index) => {
        return /* @__PURE__ */ React.createElement(
          "div",
          {
            style: itemStyle(index),
            key: index,
            onClick: (e) => {
              handleItemClick(e, item);
            }
          },
          item
        );
      })) : /* @__PURE__ */ React.createElement(
        "div",
        {
          className: "nut-noticebar-box-horseLamp-list",
          style: horseLampStyle
        },
        scrollList.current.map((item, index) => {
          return (
            // eslint-disable-next-line jsx-a11y/no-noninteractive-element-interactions
            /* @__PURE__ */ React.createElement(
              "div",
              {
                className: "nut-noticebar-box-horseLamp-list-item",
                style: { height },
                key: index,
                onClick: (e) => {
                  handleItemClick(e, item);
                }
              },
              item
            )
          );
        })
      ),
      /* @__PURE__ */ React.createElement(
        "div",
        {
          className: "nut-noticebar-box-right-icon",
          onClick: (e) => {
            handleClickIcon(e);
          }
        },
        rightIcon || (closeable ? /* @__PURE__ */ React.createElement(n$5, { width: 12, height: 12 }) : null)
      )
    ) : null);
  };
  NoticeBar.displayName = "NutNoticeBar";
  const classPrefix$c = "nut-notify";
  let Notification$1 = class Notification extends React__namespace.PureComponent {
    constructor(props) {
      super(props);
      this.close = this.close.bind(this);
      this.startCloseTimer = this.startCloseTimer.bind(this);
      this.clearCloseTimer = this.clearCloseTimer.bind(this);
      this.clickCover = this.clickCover.bind(this);
      this.state = {
        show: true
      };
    }
    close() {
      this.setState({
        show: false
      });
      this.clearCloseTimer();
      if (this.props.id) {
        const element = document.getElementById(this.props.id);
        element && element.parentNode && element.parentNode.removeChild(element);
      }
      this.props.onClose();
    }
    startCloseTimer() {
      const { duration } = this.props;
      if (duration) {
        this.closeTimer = window.setTimeout(() => {
          this.close();
        }, duration);
      }
    }
    clearCloseTimer() {
      if (this.closeTimer) {
        clearTimeout(this.closeTimer);
        this.closeTimer = -1;
      }
    }
    clickCover() {
      this.props.onClick();
    }
    componentDidMount() {
      this.startCloseTimer();
    }
    componentWillUnmount() {
      this.clearCloseTimer();
    }
    render() {
      const { style, message, type, className, position } = this.props;
      const { show: show2 } = this.state;
      const classes = classNames({
        [`${classPrefix$c}-popup-top`]: position === "top",
        [`${classPrefix$c}-popup-bottom`]: position === "bottom",
        [`${classPrefix$c}`]: true,
        [`${classPrefix$c}-${type}`]: true
      });
      return /* @__PURE__ */ React__namespace.createElement(React__namespace.Fragment, null, /* @__PURE__ */ React__namespace.createElement(
        CSSTransition,
        {
          in: show2,
          timeout: 300,
          classNames: "fade",
          unmountOnExit: true,
          appear: true,
          position
        },
        /* @__PURE__ */ React__namespace.createElement(
          "div",
          {
            className: `${classes} ${className}`,
            style,
            onClick: this.clickCover
          },
          message
        )
      ));
    }
  };
  Notification$1.newInstance = (properties, callback) => {
    const element = document.createElement("div");
    const id = properties.id ? properties.id : `${(/* @__PURE__ */ new Date()).getTime()}`;
    element.id = id;
    properties.id = id;
    document.body.appendChild(element);
    let called = false;
    function ref(instance) {
      if (called) {
        return;
      }
      called = true;
      callback({
        component: instance,
        destroy() {
          setTimeout(() => {
            unmount(element);
            element && element.parentNode && element.parentNode.removeChild(element);
          }, 300);
        }
      });
    }
    render(/* @__PURE__ */ React__namespace.createElement(Notification$1, { ...properties, ref }), element);
  };
  let messageInstance$1 = null;
  const options$1 = {
    ...ComponentDefaults,
    id: "",
    duration: 3e3,
    type: "danger",
    position: "top",
    onClose: () => {
    },
    onClick: () => {
    }
  };
  function getInstance$1(props, callback) {
    if (messageInstance$1) {
      messageInstance$1.destroy();
      messageInstance$1 = null;
    }
    Notification$1.newInstance(props, (notification) => {
      return callback && callback(notification);
    });
  }
  function notice$1(opts) {
    opts = { ...options$1, ...opts };
    getInstance$1(opts, (notification) => {
      messageInstance$1 = notification;
    });
  }
  const errorMsg$1 = (message) => {
    if (!message) {
      console.warn("[NutUI Notify]: message不能为空");
    }
  };
  const Notify = {
    text(message, option = {}) {
      errorMsg$1(message);
      return notice$1({ message, type: "base", ...option });
    },
    success(message, option = {}) {
      errorMsg$1(message);
      return notice$1({ message, type: "success", ...option });
    },
    primary(message, option = {}) {
      errorMsg$1(message);
      return notice$1({ message, type: "primary", ...option });
    },
    danger(message, option = {}) {
      errorMsg$1(message);
      return notice$1({ message, type: "danger", ...option });
    },
    warn(message, option = {}) {
      errorMsg$1(message);
      return notice$1({ message, type: "warning", ...option });
    },
    hide() {
      if (messageInstance$1) {
        messageInstance$1.destroy();
        messageInstance$1 = null;
      }
    }
  };
  const defaultProps$y = {
    ...ComponentDefaults,
    list: [],
    theme: "light",
    location: "bottom",
    visible: false,
    offset: [0, 12],
    arrowOffset: 0,
    targetId: "",
    showArrow: true,
    closeOnOutsideClick: true,
    closeOnActionClick: true,
    overlay: false,
    onClick: () => {
    },
    onOpen: () => {
    },
    onClose: () => {
    }
  };
  const classPrefix$b = `nut-popover`;
  const Popover = (props) => {
    const rtl = useRtl();
    const {
      children,
      list,
      theme,
      location,
      visible,
      offset,
      arrowOffset,
      targetId,
      overlay,
      closeOnOutsideClick,
      closeOnActionClick,
      className,
      showArrow,
      style,
      onClick,
      onOpen,
      onClose,
      onSelect,
      ...rest
    } = {
      ...defaultProps$y,
      ...props
    };
    const popoverRef = React.useRef(null);
    const popoverContentRef = React.useRef(null);
    const [showPopup, setShowPopup] = React.useState(false);
    const [rootPosition, setRootPosition] = React.useState();
    React.useEffect(() => {
      setShowPopup(visible);
      if (visible) {
        setTimeout(() => {
          getContentWidth();
        }, 0);
      }
    }, [visible, location]);
    const update2 = React.useRef((e) => {
      getContentWidth();
    });
    React.useEffect(() => {
      if (visible) {
        scrollableParents.forEach((parent) => {
          parent.addEventListener("scroll", update2.current, { passive: true });
        });
      } else {
        scrollableParents.forEach(
          (parent) => parent.removeEventListener("scroll", update2.current)
        );
      }
    }, [visible]);
    let element = null;
    let targetSet = [];
    if (canUseDom && targetId) {
      element = document.querySelector(`#${targetId}`);
      targetSet = [element, popoverContentRef.current];
    } else {
      targetSet = [popoverRef.current, popoverContentRef.current];
    }
    useClickAway(
      () => {
        onClick == null ? void 0 : onClick();
        onClose == null ? void 0 : onClose();
      },
      targetSet,
      "touchstart",
      true,
      visible,
      closeOnOutsideClick
    );
    const scrollableParents = React.useMemo(() => {
      return getAllScrollableParents(element || popoverRef.current);
    }, [element, popoverRef.current]);
    const getContentWidth = () => {
      const rect = getRect(
        targetId ? document.querySelector(`#${targetId}`) : popoverRef.current
      );
      setRootPosition({
        width: rect.width,
        height: rect.height,
        left: rtl ? rect.right : rect.left,
        top: rect.top + Math.max(document.documentElement.scrollTop, document.body.scrollTop),
        right: rtl ? rect.left : rect.right
      });
    };
    const classes = classNames(
      {
        [`${classPrefix$b}`]: true,
        [`${classPrefix$b}-${theme}`]: theme === "dark"
      },
      className
    );
    const popoverArrow = () => {
      const prefixCls2 = "nut-popover-arrow";
      const direction = location.split("-")[0];
      return `${prefixCls2} ${prefixCls2}-${direction} ${prefixCls2}-${location}`;
    };
    const getRootPosition = () => {
      var _a, _b;
      const styles = {};
      if (!rootPosition) return {};
      const contentWidth = (_a = popoverContentRef.current) == null ? void 0 : _a.clientWidth;
      const contentHeight = (_b = popoverContentRef.current) == null ? void 0 : _b.clientHeight;
      const { width, height, left, top, right } = rootPosition;
      const direction = location.split("-")[0];
      const skew = location.split("-")[1];
      let cross = 0;
      let parallel = 0;
      if (Array.isArray(offset) && offset.length === 2) {
        const rtloffset = rtl ? -offset[0] : offset[0];
        cross += +offset[1];
        parallel += +rtloffset;
      }
      if (width) {
        const dir = rtl ? "right" : "left";
        if (["bottom", "top"].includes(direction)) {
          const h = direction === "bottom" ? height + cross : -(contentHeight + cross);
          styles.top = `${top + h}px`;
          if (!skew) {
            styles[dir] = `${-(contentWidth - width) / 2 + rootPosition[dir] + parallel}px`;
          }
          if (skew === "start") {
            styles.left = `${left + parallel}px`;
          }
          if (skew === "end") {
            styles.left = `${right + parallel}px`;
          }
        }
        if (["left", "right"].includes(direction)) {
          const contentW = direction === "left" ? -(contentWidth + cross) : width + cross;
          styles.left = `${left + contentW}px`;
          if (!skew) {
            styles.top = `${top - contentHeight / 2 + height / 2 - 4 + parallel}px`;
          }
          if (skew === "start") {
            styles.top = `${top + parallel}px`;
          }
          if (skew === "end") {
            styles.top = `${top + height + parallel}px`;
          }
        }
      }
      return styles;
    };
    const arrowStyle = () => {
      const styles = {};
      const direction = location.split("-")[0];
      const skew = location.split("-")[1];
      const base = 16;
      if (arrowOffset !== 0) {
        const dir = rtl ? "right" : "left";
        const dir2 = rtl ? "left" : "right";
        if (["bottom", "top"].includes(direction)) {
          if (!skew) {
            styles[dir] = `calc(50% + ${arrowOffset}px)`;
          }
          if (skew === "start") {
            styles[dir] = `${base + arrowOffset}px`;
          }
          if (skew === "end") {
            styles[dir2] = `${base - arrowOffset}px`;
          }
        }
        if (["left", "right"].includes(direction)) {
          if (!skew) {
            styles.top = `calc(50% - ${arrowOffset}px)`;
          }
          if (skew === "start") {
            styles.top = `${base - arrowOffset}px`;
          }
          if (skew === "end") {
            styles.bottom = `${base + arrowOffset}px`;
          }
        }
      }
      return styles;
    };
    const handleSelect = (item, index) => {
      if (!item.disabled) {
        onSelect == null ? void 0 : onSelect(item, index);
      }
      if (closeOnActionClick) {
        onClick == null ? void 0 : onClick();
        onClose == null ? void 0 : onClose();
      }
    };
    return /* @__PURE__ */ React.createElement(React.Fragment, null, !targetId && /* @__PURE__ */ React.createElement(
      "div",
      {
        className: "nut-popover-wrapper",
        ref: popoverRef,
        onClick: () => {
          onClick == null ? void 0 : onClick();
          if (!visible) {
            onOpen == null ? void 0 : onOpen();
          } else {
            onClose == null ? void 0 : onClose();
          }
        },
        style
      },
      Array.isArray(children) ? children[0] : children
    ), ReactDOM.createPortal(
      /* @__PURE__ */ React.createElement("div", { className: classes, style: getRootPosition() }, /* @__PURE__ */ React.createElement(
        Popup,
        {
          className: `nut-popover-content nut-popover-content-${location}`,
          visible: showPopup,
          overlay,
          position: "default",
          lockScroll: false,
          ...rest
        },
        /* @__PURE__ */ React.createElement(
          "div",
          {
            className: "nut-popover-content-group",
            ref: popoverContentRef
          },
          showArrow && /* @__PURE__ */ React.createElement("div", { className: popoverArrow(), style: arrowStyle() }),
          Array.isArray(children) ? children[1] : null,
          list.map((item, index) => {
            return /* @__PURE__ */ React.createElement(
              "div",
              {
                className: classNames(
                  {
                    "nut-popover-menu-item": true,
                    "nut-popover-menu-disabled": item.disabled
                  },
                  item.className
                ),
                key: item.key || index,
                onClick: () => handleSelect(item, index)
              },
              item.icon ? /* @__PURE__ */ React.createElement("div", { className: "nut-popover-menu-item-icon" }, item.icon) : null,
              /* @__PURE__ */ React.createElement("div", { className: "nut-popover-menu-item-name" }, item.name),
              item.action && item.action.icon ? /* @__PURE__ */ React.createElement(
                "div",
                {
                  className: "nut-popover-menu-item-action-icon",
                  onClick: (e) => {
                    var _a, _b;
                    return (_b = (_a = item.action) == null ? void 0 : _a.onClick) == null ? void 0 : _b.call(_a, e);
                  }
                },
                item.action.icon
              ) : null
            );
          })
        )
      )),
      document.body
    ));
  };
  Popover.displayName = "NutPopover";
  function bound(position, min, max) {
    let ret = position;
    {
      ret = Math.max(position, min);
    }
    {
      ret = Math.min(ret, max);
    }
    return ret;
  }
  function rubberband(distance, dimension, constant) {
    return distance * dimension * constant / (dimension + constant * distance);
  }
  function rubberbandIfOutOfBounds(position, min, max, dimension, constant = 0.15) {
    if (constant === 0) return bound(position, min, max);
    if (position < min)
      return -rubberband(min - position, dimension, constant) + min;
    if (position > max)
      return +rubberband(position - max, dimension, constant) + max;
    return position;
  }
  const sleep = (time) => new Promise((resolve) => setTimeout(resolve, time));
  const defaultProps$x = {
    ...ComponentDefaults,
    type: "default",
    pullingText: "",
    canReleaseText: "",
    refreshingText: "",
    completeText: "",
    completeDelay: 500,
    disabled: false,
    headHeight: 50,
    threshold: 60,
    onRefresh: () => {
    }
  };
  const PullToRefresh = (p2) => {
    const classPrefix2 = "nut-pulltorefresh";
    const { locale } = useConfig();
    const props = {
      ...defaultProps$x,
      ...p2,
      ...{
        pullingText: p2.pullingText || locale.pullToRefresh.pullingText,
        canReleaseText: p2.canReleaseText || locale.pullToRefresh.canReleaseText,
        refreshingText: p2.refreshingText || locale.pullToRefresh.refreshingText,
        completeText: p2.completeText || locale.pullToRefresh.completeText
      }
    };
    const classes = classNames(
      classPrefix2,
      props.className,
      `${classPrefix2}-${props.type}`
    );
    const headHeight = props.headHeight;
    const threshold = props.threshold;
    const [status, setStatus] = React.useState("pulling");
    const [springStyles, api] = useSpring(() => ({
      from: { height: 0 },
      config: {
        tension: 300,
        friction: 30,
        clamp: true
      }
    }));
    const elementRef = React.useRef(null);
    const pullingRef = React.useRef(false);
    React.useEffect(() => {
      var _a;
      (_a = elementRef.current) == null ? void 0 : _a.addEventListener("touchmove", () => {
      });
    }, []);
    async function doRefresh() {
      api.start({ height: headHeight });
      setStatus("refreshing");
      try {
        await props.onRefresh();
        setStatus("complete");
      } catch (e) {
        api.start({
          to: async (next) => {
            await next({ height: 0 });
            setStatus("pulling");
          }
        });
        throw e;
      }
      if (props.completeDelay > 0) {
        await sleep(props.completeDelay);
      }
      api.start({
        to: async (next) => {
          await next({ height: 0 });
          setStatus("pulling");
        }
      });
    }
    useDrag(
      (state) => {
        if (status === "refreshing" || status === "complete") return;
        const { event } = state;
        if (state.last) {
          pullingRef.current = false;
          if (status === "canRelease") {
            doRefresh();
          } else {
            api.start({ height: 0 });
          }
          return;
        }
        function getScrollTop(element) {
          return "scrollTop" in element ? element.scrollTop : element.scrollY;
        }
        const [, y] = state.movement;
        if (state.first && y > 0) {
          const target = state.event.target;
          if (!target || !(target instanceof Element)) return;
          let scrollParent = getScrollParent(target);
          while (true) {
            if (!scrollParent) return;
            const scrollTop = getScrollTop(scrollParent);
            if (scrollTop > 0) {
              return;
            }
            if (scrollParent instanceof Window) {
              break;
            }
            scrollParent = getScrollParent(scrollParent.parentNode);
          }
          pullingRef.current = true;
        }
        if (!pullingRef.current) return;
        if (event.cancelable) {
          event.preventDefault();
        }
        event.stopPropagation();
        const height = Math.max(
          rubberbandIfOutOfBounds(y, 0, 0, headHeight * 5, 0.5),
          0
        );
        api.start({ height });
        setStatus(height > threshold ? "canRelease" : "pulling");
      },
      {
        pointer: { touch: true },
        axis: "y",
        target: elementRef,
        enabled: !props.disabled,
        eventOptions: passiveSupported ? { passive: false } : false
      }
    );
    const renderIcons = (status2) => {
      return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement("i", { className: `${classPrefix2}-head-content-icons` }, (status2 === "pulling" || status2 === "complete") && /* @__PURE__ */ React.createElement(n$4, null), (status2 === "canRelease" || status2 === "refreshing") && /* @__PURE__ */ React.createElement(m, null)));
    };
    const renderStatusIcon = () => {
      var _a;
      if (props.renderIcon) {
        return (_a = props.renderIcon) == null ? void 0 : _a.call(props, status);
      }
      return renderIcons(status);
    };
    const renderStatusText = () => {
      var _a;
      if (props.renderText) {
        return (_a = props.renderText) == null ? void 0 : _a.call(props, status);
      }
      if (status === "pulling") return props.pullingText;
      if (status === "canRelease") return props.canReleaseText;
      if (status === "refreshing") return props.refreshingText;
      if (status === "complete") return props.completeText;
      return "";
    };
    return /* @__PURE__ */ React.createElement(animated.div, { ref: elementRef, className: classes, style: props.style }, /* @__PURE__ */ React.createElement(animated.div, { style: springStyles, className: `${classPrefix2}-head` }, /* @__PURE__ */ React.createElement(
      "div",
      {
        className: `${classPrefix2}-head-content`,
        style: { height: headHeight }
      },
      /* @__PURE__ */ React.createElement("div", null, renderStatusIcon()),
      /* @__PURE__ */ React.createElement("div", null, renderStatusText())
    )), /* @__PURE__ */ React.createElement("div", { className: `${classPrefix2}-content` }, props.children));
  };
  PullToRefresh.displayName = "NutPullToRefresh";
  const AvatarContext = React.createContext({});
  const defaultProps$w = {
    ...ComponentDefaults,
    maxContent: "",
    max: "",
    maxBackground: "#eee",
    maxColor: "#666",
    gap: "-8",
    level: "left"
  };
  const classPrefix$a = `nut-avatar-group`;
  const AvatarGroup = (props) => {
    const propAvatarGroup = { ...defaultProps$w, ...props };
    const { className, style, children } = propAvatarGroup;
    const avatarGroupRef = React.useRef(null);
    const cls = classNames(classPrefix$a, className);
    const parentAvatar = {
      propAvatarGroup,
      avatarGroupRef
    };
    return /* @__PURE__ */ React.createElement(AvatarContext.Provider, { value: parentAvatar }, /* @__PURE__ */ React.createElement("div", { className: cls, style, ref: avatarGroupRef }, children));
  };
  AvatarGroup.displayName = "NutAvatarGroup";
  const defaultProps$v = {
    ...ComponentDefaults,
    size: "",
    shape: "round",
    icon: "",
    background: "#eee",
    color: "#666",
    fit: "cover",
    src: "",
    alt: ""
  };
  const classPrefix$9 = `nut-avatar`;
  const Avatar = (props) => {
    const {
      children,
      size,
      shape,
      background,
      color,
      src,
      alt,
      icon,
      fit,
      className,
      style,
      onClick,
      onError,
      ...rest
    } = {
      ...defaultProps$v,
      ...props
    };
    const [maxSum, setMaxSum] = React.useState(0);
    const [showMax, setShowMax] = React.useState(false);
    const [avatarIndex, setAvatarIndex] = React.useState(1);
    const avatarRef = React.useRef(null);
    const parent = React.useContext(AvatarContext);
    const sizeValue = ["large", "normal", "small"];
    const { propAvatarGroup, avatarGroupRef } = parent;
    const classes = classNames({
      [`nut-avatar-${(propAvatarGroup == null ? void 0 : propAvatarGroup.size) || size || "normal"}`]: true,
      [`nut-avatar-${(propAvatarGroup == null ? void 0 : propAvatarGroup.shape) || shape}`]: true
    });
    const cls = classNames(classPrefix$9, classes, className);
    const styles = {
      width: sizeValue.indexOf(size) > -1 ? "" : `${size}px`,
      height: sizeValue.indexOf(size) > -1 ? "" : `${size}px`,
      backgroundColor: `${background}`,
      color,
      marginLeft: avatarIndex !== 1 && (propAvatarGroup == null ? void 0 : propAvatarGroup.gap) ? `${propAvatarGroup == null ? void 0 : propAvatarGroup.gap}px` : "",
      zIndex: (propAvatarGroup == null ? void 0 : propAvatarGroup.level) === "right" ? `${Math.abs(maxSum - avatarIndex)}` : "",
      ...style
    };
    const maxStyles = {
      backgroundColor: `${propAvatarGroup == null ? void 0 : propAvatarGroup.maxBackground}`,
      color: `${propAvatarGroup == null ? void 0 : propAvatarGroup.maxColor}`
    };
    const avatarLength = React.useCallback(
      (children2) => {
        var _a, _b;
        for (let i2 = 0; i2 < children2.length; i2++) {
          if (children2[i2] && children2[i2].classList && children2[i2].classList[0] === "nut-avatar") {
            children2[i2].setAttribute("data-index", i2 + 1);
          }
        }
        const index = Number((_b = (_a = avatarRef.current) == null ? void 0 : _a.dataset) == null ? void 0 : _b.index);
        const maxCount = propAvatarGroup == null ? void 0 : propAvatarGroup.max;
        setMaxSum(children2.length);
        setAvatarIndex(index);
        if (index === children2.length && index !== maxCount && children2.length > maxCount) {
          setShowMax(true);
        }
      },
      [propAvatarGroup == null ? void 0 : propAvatarGroup.max]
    );
    React.useEffect(() => {
      const avatarChildren = avatarGroupRef == null ? void 0 : avatarGroupRef.current.children;
      if (avatarChildren) {
        avatarLength(avatarChildren);
      }
    }, [avatarLength, avatarGroupRef]);
    const errorEvent = () => {
      onError && onError();
    };
    const clickAvatar = (e) => {
      onClick && onClick(e);
    };
    return /* @__PURE__ */ React.createElement(React.Fragment, null, (showMax || !(propAvatarGroup == null ? void 0 : propAvatarGroup.max) || avatarIndex <= (propAvatarGroup == null ? void 0 : propAvatarGroup.max)) && /* @__PURE__ */ React.createElement(
      "div",
      {
        className: cls,
        ...rest,
        style: !showMax ? styles : maxStyles,
        onClick: clickAvatar,
        ref: avatarRef
      },
      (!(propAvatarGroup == null ? void 0 : propAvatarGroup.max) || avatarIndex <= (propAvatarGroup == null ? void 0 : propAvatarGroup.max)) && /* @__PURE__ */ React.createElement(React.Fragment, null, src && /* @__PURE__ */ React.createElement(
        Image$1,
        {
          className: "avatar-img",
          src,
          alt,
          style: { objectFit: fit },
          onError: errorEvent
        }
      ), React.isValidElement(icon) ? React.cloneElement(icon, {
        ...icon.props,
        className: `${icon.props.className || ""} icon`
      }) : null, children && /* @__PURE__ */ React.createElement("span", { className: "text" }, children), !src && !icon && !children && /* @__PURE__ */ React.createElement(i, { className: "icon" })),
      showMax && /* @__PURE__ */ React.createElement("div", { className: "text" }, (propAvatarGroup == null ? void 0 : propAvatarGroup.maxContent) ? propAvatarGroup == null ? void 0 : propAvatarGroup.maxContent : `+ ${avatarIndex - Number((propAvatarGroup == null ? void 0 : propAvatarGroup.max) || 0)}`)
    ));
  };
  Avatar.displayName = "NutAvatar";
  Avatar.Group = AvatarGroup;
  const defaultProps$u = {
    ...ComponentDefaults,
    rows: 1,
    animated: false,
    title: false,
    avatar: false,
    avatarSize: "50px",
    visible: false,
    avatarShape: "round"
  };
  const Skeleton = (props) => {
    const {
      className,
      animated: animated2,
      rows,
      title,
      avatar,
      avatarSize,
      visible,
      children,
      avatarShape,
      ...rest
    } = {
      ...defaultProps$u,
      ...props
    };
    const classPrefix2 = "nut-skeleton";
    const classes = classNames(classPrefix2, className);
    const avatarClass = classNames({
      [`nut-avatar`]: true,
      [`avatar-${avatarShape}`]: avatarShape
    });
    const repeatLines = (num) => {
      return Array.from({ length: num }, (v, i2) => i2);
    };
    const getStyle = () => {
      if (avatarSize) {
        return {
          width: avatarSize,
          height: avatarSize
        };
      }
      return {
        width: "50px",
        height: "50px"
      };
    };
    return /* @__PURE__ */ React.createElement(React.Fragment, null, visible ? /* @__PURE__ */ React.createElement(React.Fragment, null, children) : /* @__PURE__ */ React.createElement("div", { className: classes, ...rest }, animated2 && /* @__PURE__ */ React.createElement("div", { className: `${classPrefix2}-animation` }), /* @__PURE__ */ React.createElement("div", { className: `${classPrefix2}-content` }, avatar && /* @__PURE__ */ React.createElement(
      Avatar,
      {
        className: avatarClass,
        shape: avatarShape,
        style: getStyle(),
        icon: "null"
      }
    ), rows === 1 ? /* @__PURE__ */ React.createElement("div", { className: `${classPrefix2}-block` }) : /* @__PURE__ */ React.createElement("div", { className: `${classPrefix2}-content-line` }, title && /* @__PURE__ */ React.createElement("div", { className: `${classPrefix2}-title` }), repeatLines(rows).map((item, index) => {
      return /* @__PURE__ */ React.createElement("div", { className: `${classPrefix2}-block`, key: index });
    })))));
  };
  Skeleton.displayName = "NutSkeleton";
  function preventDefault(event, isStopPropagation) {
    if (typeof event.cancelable !== "boolean" || event.cancelable) {
      event.preventDefault();
    }
    {
      event.stopPropagation();
    }
  }
  const defaultProps$t = {
    name: ""
  };
  const Swipe = React.forwardRef((props, instanceRef) => {
    const classPrefix2 = "nut-swipe";
    const touch = useTouch();
    const { children, className, style } = { ...defaultProps$t, ...props };
    const root2 = React.useRef();
    const opened = React.useRef(false);
    const lockClick = React.useRef(false);
    const startOffset = React.useRef(0);
    const [state, setState] = React.useState({
      offset: 0,
      dragging: false
    });
    const [actionWidth, setActionWidth] = React.useState({
      left: 0,
      right: 0
    });
    const wrapperStyle = {
      transform: `translate3d(${state.offset}px, 0, 0)`,
      transitionDuration: state.dragging ? "0s" : ".6s"
    };
    const leftWidth = actionWidth.left;
    const rightWidth = actionWidth.right;
    const onTouchStart = (event) => {
      var _a;
      if (!props.disabled) {
        startOffset.current = state.offset;
        touch.start(event);
        (_a = props.onTouchStart) == null ? void 0 : _a.call(props, event);
      }
    };
    const onTouchMove = (event) => {
      var _a;
      if (props.disabled) {
        return;
      }
      touch.move(event);
      (_a = props.onTouchMove) == null ? void 0 : _a.call(props, event);
      if (touch.isHorizontal()) {
        lockClick.current = true;
        const newState = { ...state, dragging: true };
        const isEdge = !opened || touch.deltaX.current * startOffset.current < 0;
        if (isEdge) {
          preventDefault(event);
        }
        newState.offset = rangeCalculation(
          touch.deltaX.current + startOffset.current,
          -rightWidth,
          leftWidth
        );
        setState(newState);
      }
    };
    const onTouchEnd = (event) => {
      var _a;
      if (state.dragging) {
        setState((v) => ({ ...v, dragging: false }));
        toggle(state.offset > 0 ? "left" : "right");
        setTimeout(() => {
          lockClick.current = false;
        }, 0);
        (_a = props.onTouchEnd) == null ? void 0 : _a.call(props, event);
      }
    };
    const toggle = (side) => {
      const offset = Math.abs(state.offset);
      const base = 0.3;
      const baseNum = opened ? 1 - base : base;
      const width = side === "left" ? leftWidth : rightWidth;
      if (width && offset > Number(width) * baseNum) {
        open(side);
      } else {
        close(side);
      }
    };
    const open = (side) => {
      var _a;
      opened.current = true;
      const offset = side === "left" ? leftWidth : -rightWidth;
      const name = props.name;
      (_a = props.onOpen) == null ? void 0 : _a.call(props, { name, position: side });
      setState((v) => ({ ...v, offset: Number(offset) || 0 }));
    };
    const close = (position) => {
      var _a;
      if (opened.current) {
        opened.current = false;
        (_a = props.onClose) == null ? void 0 : _a.call(props, {
          name: props.name,
          position: position || "left"
        });
      }
      setState((v) => ({ ...v, offset: 0 }));
    };
    const rangeCalculation = (num, min, max) => {
      return Math.min(Math.max(Number(num), Number(min)), Number(max));
    };
    const getNodeWidth = (node) => {
      if (node) {
        const ele = getRect(node);
        return ele.width;
      }
      return 0;
    };
    const leftRef = React.useCallback(
      (node) => {
        if (node !== null) {
          setActionWidth((v) => ({ ...v, left: getNodeWidth(node) }));
        }
      },
      [props.leftAction]
    );
    const rightRef = React.useCallback(
      (node) => {
        if (node !== null) {
          setActionWidth((v) => ({ ...v, right: getNodeWidth(node) }));
        }
      },
      [props.rightAction]
    );
    const renderActionContent = (side, measuredRef) => {
      if (props[`${side}Action`]) {
        return /* @__PURE__ */ React.createElement(
          "div",
          {
            ref: measuredRef,
            className: `${classPrefix2}-${side}`,
            onClick: (e) => handleOperate(e, side)
          },
          props[`${side}Action`]
        );
      }
      return null;
    };
    const handleOperate = (event, position) => {
      event.stopPropagation();
      if (props.beforeClose) {
        props.beforeClose(position);
      } else {
        props.onActionClick && props.onActionClick(event, position);
      }
    };
    React.useImperativeHandle(instanceRef, () => ({
      open,
      close: () => close()
    }));
    React.useEffect(() => {
      const handler = (event) => {
        const targets = [root2];
        if (targets.some((targetItem) => {
          const targetElement = targetItem.current || targetItem;
          return !targetElement || (targetElement == null ? void 0 : targetElement.contains(event.target));
        })) {
          return;
        }
        close();
      };
      document.addEventListener("touchstart", handler);
      return () => {
        document.removeEventListener("touchstart", handler);
      };
    }, []);
    return /* @__PURE__ */ React.createElement(
      "div",
      {
        ref: root2,
        className: classNames(classPrefix2, className),
        onTouchStart: (e) => onTouchStart(e),
        onTouchMove: (e) => onTouchMove(e),
        onTouchEnd: (e) => onTouchEnd(e),
        style
      },
      /* @__PURE__ */ React.createElement("div", { className: `${classPrefix2}-wrapper`, style: wrapperStyle }, renderActionContent("left", leftRef), children, renderActionContent("right", rightRef))
    );
  });
  Swipe.displayName = "NutSwipe";
  const classPrefix$8 = "nut-toast";
  class Notification extends React__namespace.PureComponent {
    constructor(props) {
      super(props);
      this.close = this.close.bind(this);
      this.startCloseTimer = this.startCloseTimer.bind(this);
      this.clearCloseTimer = this.clearCloseTimer.bind(this);
      this.clickCover = this.clickCover.bind(this);
      this.state = {
        show: true
      };
    }
    close() {
      this.setState({
        show: false
      });
      this.clearCloseTimer();
      if (this.props.id) {
        const element = document.getElementById(this.props.id);
        element && element.parentNode && element.parentNode.removeChild(element);
      }
      this.props.onClose();
    }
    startCloseTimer() {
      const { duration } = this.props;
      if (duration) {
        this.closeTimer = window.setTimeout(() => {
          this.close();
        }, duration * 1e3);
      }
    }
    clearCloseTimer() {
      if (this.closeTimer) {
        clearTimeout(this.closeTimer);
        this.closeTimer = -1;
      }
    }
    clickCover() {
      const { closeOnOverlayClick } = this.props;
      if (closeOnOverlayClick) {
        this.close();
      }
    }
    renderIcon() {
      const { icon } = this.props;
      if (typeof icon === "string") {
        let iconNode = null;
        switch (icon) {
          case "success":
            iconNode = /* @__PURE__ */ React__namespace.createElement(i$5, null);
            break;
          case "loading":
            iconNode = /* @__PURE__ */ React__namespace.createElement(n$4, { className: "nut-icon-loading" });
            break;
          case "fail":
            iconNode = /* @__PURE__ */ React__namespace.createElement(p$3, null);
            break;
          case "warn":
            iconNode = /* @__PURE__ */ React__namespace.createElement(c, null);
            break;
        }
        return /* @__PURE__ */ React__namespace.createElement("p", { className: `${classPrefix$8}-icon-wrapper` }, iconNode);
      }
      return icon;
    }
    componentDidMount() {
      this.startCloseTimer();
    }
    componentWillUnmount() {
      this.clearCloseTimer();
    }
    render() {
      const {
        id,
        icon,
        title,
        content,
        position,
        size,
        closeOnOverlayClick,
        lockScroll,
        style,
        className,
        contentClassName,
        contentStyle,
        wordBreak
      } = this.props;
      const { show: show2 } = this.state;
      const classes = classNames({
        "nut-toast-has-icon": icon,
        [`nut-toast-${size}`]: true
      });
      return /* @__PURE__ */ React__namespace.createElement(React__namespace.Fragment, null, /* @__PURE__ */ React__namespace.createElement(
        Overlay,
        {
          visible: show2,
          style,
          className: `${classPrefix$8}-overlay-default ${className}`,
          onClick: () => {
            this.clickCover();
          },
          closeOnOverlayClick,
          lockScroll
        },
        /* @__PURE__ */ React__namespace.createElement("div", { className: `${classPrefix$8} ${classes}`, id: `toast-${id}` }, /* @__PURE__ */ React__namespace.createElement(
          "div",
          {
            className: `${classPrefix$8}-inner ${classPrefix$8}-${position} ${contentClassName} ${wordBreak}`,
            style: contentStyle
          },
          this.renderIcon(),
          title ? /* @__PURE__ */ React__namespace.createElement("div", { className: `${classPrefix$8}-title` }, title) : null,
          /* @__PURE__ */ React__namespace.createElement("span", { className: `${classPrefix$8}-text` }, content)
        ))
      ));
    }
  }
  Notification.newInstance = (properties, callback) => {
    const element = document.createElement("div");
    const id = properties.id ? properties.id : `${(/* @__PURE__ */ new Date()).getTime()}`;
    element.id = id;
    properties.id = id;
    document.body.appendChild(element);
    let called = false;
    function ref(instance) {
      if (called) {
        return;
      }
      called = true;
      callback({
        component: instance,
        destroy() {
          unmount(element);
          element && element.parentNode && element.parentNode.removeChild(element);
        }
      });
    }
    render(/* @__PURE__ */ React__namespace.createElement(Notification, { ...properties, ref }), element);
  };
  let messageInstance = null;
  let options = {
    ...ComponentDefaults,
    id: "",
    duration: 2,
    // 时长,duration为0则一直展示
    position: "center",
    title: "",
    size: "base",
    // 设置字体大小，默认base,可选large\small\base
    icon: null,
    onClose: () => {
    },
    closeOnOverlayClick: false,
    // 是否点击遮罩可关闭
    lockScroll: false,
    contentClassName: "",
    wordBreak: "break-all"
  };
  function getInstance(props, callback) {
    if (messageInstance) {
      messageInstance.destroy();
      messageInstance = null;
    }
    Notification.newInstance(props, (notification) => {
      return callback && callback(notification);
    });
  }
  function notice(opts) {
    function close() {
      if (messageInstance) {
        messageInstance.destroy();
        messageInstance = null;
        opts.onClose && opts.onClose();
      }
    }
    const opts2 = { ...options, ...opts, onClose: close };
    getInstance(opts2, (notification) => {
      messageInstance = notification;
    });
  }
  const errorMsg = (msg) => {
    if (!msg) {
      console.warn("[NutUI Toast]: msg cannot be null");
    }
  };
  function show(option) {
    if (typeof option === "string") {
      errorMsg(option);
      return notice({ content: option });
    }
    errorMsg(option.content);
    return notice({
      ...option
    });
  }
  function config(config2) {
    options = { ...options, ...config2 };
  }
  const Toast = {
    show,
    config,
    clear() {
      if (messageInstance) {
        messageInstance.destroy();
        messageInstance = null;
      }
    }
  };
  const defaultProps$s = {
    ...ComponentDefaults,
    type: "shake",
    action: "initial",
    loop: false,
    onClick: (event) => {
    }
  };
  const classPrefix$7 = "nut-animate";
  const Animate = (props) => {
    const { className, type, action, loop: loop2, onClick, children, ...rest } = {
      ...defaultProps$s,
      ...props
    };
    const [clicked, setClicked] = React.useState(false);
    const classes = classNames(
      {
        "nut-ani-container": true,
        [`${classPrefix$7}-${type}`]: action === "initial" || clicked,
        loop: loop2
      },
      className
    );
    const handleClick2 = (event) => {
      setClicked(true);
      if (!loop2) {
        setTimeout(() => setClicked(false), 1e3);
      }
      onClick(event);
    };
    return /* @__PURE__ */ React.createElement("div", { className: "nut-animate" }, /* @__PURE__ */ React.createElement("div", { className: classes, onClick: handleClick2, ...rest }, children));
  };
  Animate.displayName = "NutAnimate";
  const defaultProps$r = {
    ...ComponentDefaults,
    length: 0,
    value: "",
    delay: 300,
    duration: 1,
    thousands: false
  };
  const CountUp = (props) => {
    const {
      length,
      value,
      delay,
      duration,
      className,
      thousands,
      style,
      ...rest
    } = mergeProps(defaultProps$r, props);
    const classPrefix2 = "nut-countup";
    const countupRef = React.useRef(null);
    const timerRef = React.useRef(0);
    const numbers = Array.from({ length: 10 }, (v, i2) => i2);
    const getShowNumber = () => {
      const splitArr = value.split(".");
      const intNumber = length && splitArr[0].length < length ? (Array(length).join("0") + splitArr[0]).slice(-length) : splitArr[0];
      const currNumber = `${thousands ? intNumber.replace(/(\d)(?=(?:\d{3})+$)/g, "$1,") : intNumber}${splitArr[1] ? "." : ""}${splitArr[1] || ""}`;
      return currNumber.split("");
    };
    const numerArr = React.useMemo(getShowNumber, [value, length, thousands]);
    const setNumberTransform = React.useCallback(() => {
      if (countupRef.current) {
        const numberItems = countupRef.current.querySelectorAll(
          ".nut-countup-number"
        );
        const numberFilterArr = numerArr.filter(
          (item) => !Number.isNaN(Number(item))
        );
        Object.keys(numberItems).forEach((key) => {
          const elem = numberItems[Number(key)];
          const idx = Number(numberFilterArr[Number(key)]);
          if ((idx || idx === 0) && elem) {
            const transform = `translate(0, -${(idx === 0 ? 10 : idx) * 5}%)`;
            elem.style.transform = transform;
            elem.style.webkitTransform = transform;
          }
        });
      }
    }, [numerArr]);
    const numberEaseStyle = {
      transition: `transform ${duration}s ease-in-out`
    };
    React.useEffect(() => {
      timerRef.current = window.setTimeout(() => {
        setNumberTransform();
      }, delay);
      return () => {
        window.clearTimeout(timerRef.current);
      };
    }, [numerArr, delay, setNumberTransform]);
    return /* @__PURE__ */ React.createElement("div", { className: `${classPrefix2} ${className}`, ref: countupRef }, /* @__PURE__ */ React.createElement("ul", { className: `${classPrefix2}-list` }, numerArr.map((item, idx) => {
      return /* @__PURE__ */ React.createElement(
        "li",
        {
          className: `${classPrefix2}-listitem ${!Number.isNaN(Number(item)) ? `${classPrefix2}-listitem-number` : ""}`,
          key: idx
        },
        !Number.isNaN(Number(item)) ? /* @__PURE__ */ React.createElement(
          "span",
          {
            className: `${classPrefix2}-number`,
            style: numberEaseStyle
          },
          [...numbers, ...numbers].map((number, subidx) => {
            return /* @__PURE__ */ React.createElement("span", { key: subidx }, number);
          })
        ) : /* @__PURE__ */ React.createElement("span", { className: `${classPrefix2}-separator` }, item)
      );
    })));
  };
  CountUp.displayName = "NutCountUp";
  const defaultProps$q = {};
  const _AnimatingNumbers = class _AnimatingNumbers extends React.Component {
    constructor(props) {
      super(props);
      this.state = {};
    }
    render() {
      return /* @__PURE__ */ React.createElement("div", { className: "nut-animatingnumbers" });
    }
  };
  _AnimatingNumbers.defaultProps = defaultProps$q;
  _AnimatingNumbers.displayName = "NutAnimatingNumbers";
  _AnimatingNumbers.CountUp = CountUp;
  let AnimatingNumbers = _AnimatingNumbers;
  AnimatingNumbers.CountUp = CountUp;
  const defaultProps$p = {
    ...ComponentDefaults,
    src: "",
    muted: false,
    autoPlay: false,
    loop: false,
    preload: "auto",
    type: "progress",
    onBack: (e) => {
    },
    // type 为 progress时生效
    onForward: (e) => {
    },
    // type 为 progress时生效
    onPause: (e) => {
    },
    onEnd: (e) => {
    },
    onMute: (e) => {
    },
    onCanPlay: (e) => {
    }
  };
  const Audio = (props) => {
    const { locale } = useConfig();
    const {
      className,
      src,
      style,
      muted,
      autoPlay,
      loop: loop2,
      preload,
      type,
      onBack,
      onForward,
      onPause,
      onEnd,
      onMute,
      onCanPlay,
      children,
      ...rest
    } = {
      ...defaultProps$p,
      ...props
    };
    const [playing, setPlaying] = React.useState(false);
    const [percent, setPercent] = React.useState(0);
    const [isCanPlay, setIsCanPlay] = React.useState(false);
    const [currentDuration, setCurrentDuration] = React.useState("00:00:00");
    const AudioRef = React.useRef(null);
    const statusRef = React.useRef({
      currentTime: 0,
      currentDuration: "00:00:00",
      percent: 0,
      duration: "00:00:00",
      second: 0,
      hanMuted: muted,
      playing: autoPlay,
      handPlaying: false
    });
    const classPrefix2 = "nut-audio";
    const handleEnded = (e) => {
      if (loop2) {
        console.warn(locale.audio.tips || "onPlayEnd事件在loop=false时才会触发");
      } else {
        onEnd == null ? void 0 : onEnd(e);
      }
    };
    function watch() {
      if (AudioRef && AudioRef.current) {
        const current = AudioRef.current;
        current.addEventListener("play", () => {
          setPlaying(true);
        });
      }
    }
    React.useEffect(() => {
      watch();
    }, []);
    React.useEffect(() => {
    }, [currentDuration]);
    const handleStatusChange = () => {
      setPlaying(!playing);
      if (playing) {
        AudioRef && AudioRef.current && AudioRef.current.pause();
      } else {
        AudioRef && AudioRef.current && AudioRef.current.play();
      }
    };
    const renderIcon = () => {
      return /* @__PURE__ */ React.createElement("div", { className: `${classPrefix2}-icon` }, /* @__PURE__ */ React.createElement(
        "div",
        {
          className: classNames(
            `${classPrefix2}-icon-box`,
            playing ? `${classPrefix2}-icon-play` : `${classPrefix2}-icon-stop`
          ),
          onClick: handleStatusChange
        },
        /* @__PURE__ */ React.createElement(i$1, { className: playing ? "nut-icon-loading" : "" })
      ));
    };
    const handleBack = () => {
      if (statusRef.current.currentTime > 0 && AudioRef.current) {
        statusRef.current.currentTime--;
        AudioRef.current.currentTime = statusRef.current.currentTime;
        onBack == null ? void 0 : onBack(AudioRef.current);
      }
    };
    const handleForward = () => {
      if (AudioRef.current) {
        statusRef.current.currentTime++;
        AudioRef.current.currentTime = statusRef.current.currentTime;
        onForward == null ? void 0 : onForward(AudioRef.current);
      }
    };
    const handleMute = () => {
      if (AudioRef.current) {
        AudioRef.current.muted = !AudioRef.current.muted;
        onMute == null ? void 0 : onMute(AudioRef.current);
      }
    };
    const handlePause = (e) => {
      setPlaying(false);
      onPause == null ? void 0 : onPause(e);
    };
    const formatSeconds = (value) => {
      if (!value) {
        return "00:00:00";
      }
      const time = parseInt(value);
      const hours = Math.floor(time / 3600);
      const minutes = Math.floor((time - hours * 3600) / 60);
      const seconds = time - hours * 3600 - minutes * 60;
      let result = "";
      result += `${`0${hours.toString()}`.slice(-2)}:`;
      result += `${`0${minutes.toString()}`.slice(-2)}:`;
      result += `0${seconds.toString()}`.slice(-2);
      return result;
    };
    const renderProgerss = () => {
      return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement("div", { className: `${classPrefix2}-progress` }, /* @__PURE__ */ React.createElement("div", { className: "time" }, currentDuration), /* @__PURE__ */ React.createElement("div", { className: `${classPrefix2}-progress-bar-wrapper` }, /* @__PURE__ */ React.createElement(
        Range,
        {
          value: percent,
          onChange: (val) => setPercent(val),
          currentDescription: null,
          maxDescription: null,
          minDescription: null,
          "inactive-color": "#cccccc",
          "active-color": "#fa2c19"
        }
      )), /* @__PURE__ */ React.createElement("div", { className: "time" }, AudioRef.current ? formatSeconds(`${statusRef.current.second}`) : "00:00:00")), /* @__PURE__ */ React.createElement(
        "div",
        {
          className: isCanPlay ? "custom-button-group" : "custom-button-group-disable"
        },
        /* @__PURE__ */ React.createElement(
          Button,
          {
            type: "primary",
            size: "small",
            className: "back",
            onClick: handleBack
          },
          locale.audio.back || "快退"
        ),
        /* @__PURE__ */ React.createElement(
          Button,
          {
            type: "primary",
            size: "small",
            className: "start",
            onClick: handleStatusChange
          },
          playing ? `${locale.audio.pause || "暂停"}` : `${locale.audio.start || "开始"}`
        ),
        /* @__PURE__ */ React.createElement(Button, { type: "primary", size: "small", onClick: handleForward }, locale.audio.forward || "快进"),
        /* @__PURE__ */ React.createElement(
          Button,
          {
            type: AudioRef.current && AudioRef.current.muted ? "default" : "primary",
            size: "small",
            onClick: handleMute
          },
          locale.audio.mute || "静音"
        )
      ));
    };
    const renderNone = () => {
      return /* @__PURE__ */ React.createElement(
        "div",
        {
          className: `${classPrefix2}-none-container`,
          onClick: handleStatusChange
        },
        children
      );
    };
    const renderAudio = () => {
      switch (type) {
        case "icon":
          return renderIcon();
        case "progress":
          return renderProgerss();
        case "none":
          return renderNone();
        default:
          return null;
      }
    };
    const handleCanplay = (e) => {
      setIsCanPlay(true);
      if (autoPlay && !playing) {
        AudioRef && AudioRef.current && AudioRef.current.play();
      }
      if (AudioRef.current) {
        statusRef.current.second = AudioRef.current.duration || 0;
        onCanPlay == null ? void 0 : onCanPlay(e);
      }
    };
    const onTimeupdate = (e) => {
      const time = parseInt(String(e.target.currentTime));
      const formated = formatSeconds(`${time}`);
      statusRef.current.currentDuration = formated;
      setPercent(time / statusRef.current.second * 100);
      setCurrentDuration(formated);
      statusRef.current.currentTime = time;
    };
    return /* @__PURE__ */ React.createElement("div", { className: classNames(classPrefix2, className), style, ...rest }, renderAudio(), /* @__PURE__ */ React.createElement(
      "audio",
      {
        className: "audioMain",
        controls: type === "controls",
        ref: AudioRef,
        src,
        muted,
        preload,
        loop: loop2,
        onPause: (e) => handlePause(e),
        onEnded: (e) => handleEnded(e),
        onCanPlay: (e) => handleCanplay(e),
        onTimeUpdate: (e) => onTimeupdate(e)
      },
      /* @__PURE__ */ React.createElement("track", { kind: "captions" })
    ));
  };
  Audio.displayName = "NutAudio";
  const defaultProps$o = {
    ...ComponentDefaults,
    strokeWidth: 5,
    radius: 50,
    strokeLinecap: "round",
    color: "#fa2c19",
    background: "#e5e9f2",
    clockwise: true
  };
  const classPrefix$6 = `nut-circleprogress`;
  const CircleProgress = (props) => {
    var _a;
    const {
      children,
      percent,
      className,
      radius,
      clockwise,
      strokeWidth,
      color,
      background,
      style,
      strokeLinecap,
      ...restProps
    } = {
      ...defaultProps$o,
      ...props
    };
    const classes = classNames(classPrefix$6, className);
    const refRandomId = Math.random().toString(36).slice(-8);
    const styles = {
      height: `${Number(radius) * 2}px`,
      width: `${Number(radius) * 2}px`,
      ...style
    };
    const pathStyle = {
      stroke: background
    };
    const hoverStyle = () => {
      const perimeter = 283;
      const offset = perimeter * Number(percent) / 100;
      return {
        stroke: isObject(color) ? `url(#${refRandomId})` : color,
        strokeDasharray: `${offset}px ${perimeter}px`
      };
    };
    const path = () => {
      const isWise = clockwise ? 1 : 0;
      return `M 50 50 m -45 0 a 45 45 0 1 ${isWise} 90 0  a 45 45 0 1 ${isWise} -90 0`;
    };
    const stop2 = () => {
      if (!isObject(color)) {
        return;
      }
      const colorArr = Object.keys(color).sort(
        (a, b) => parseFloat(a) - parseFloat(b)
      );
      const stopArr = [];
      colorArr.forEach((item) => {
        const obj = {
          key: "",
          value: ""
        };
        obj.key = item;
        obj.value = color[item];
        stopArr.push(obj);
      });
      return stopArr;
    };
    return /* @__PURE__ */ React.createElement("div", { className: classes, style: styles, ...restProps }, /* @__PURE__ */ React.createElement("svg", { viewBox: "0 0 100 100" }, /* @__PURE__ */ React.createElement("defs", null, /* @__PURE__ */ React.createElement("linearGradient", { id: refRandomId, x1: "100%", y1: "0%", x2: "0%", y2: "0%" }, (_a = stop2()) == null ? void 0 : _a.map((item, index) => {
      return /* @__PURE__ */ React.createElement("stop", { key: index, offset: item.key, stopColor: item.value });
    }))), /* @__PURE__ */ React.createElement(
      "path",
      {
        className: "nut-circleprogress-path",
        d: path(),
        style: pathStyle,
        fill: "none",
        strokeWidth
      }
    ), /* @__PURE__ */ React.createElement(
      "path",
      {
        className: "nut-circleprogress-hover",
        style: hoverStyle(),
        d: path(),
        fill: "none",
        strokeLinecap,
        transform: "rotate(90,50,50)",
        strokeWidth
      }
    )), /* @__PURE__ */ React.createElement("div", { className: "nut-circleprogress-text" }, children));
  };
  CircleProgress.displayName = "NutCircleProgress";
  const collapseContext = {
    isOpen: (name) => {
      return true;
    },
    updateValue: (name) => {
    },
    expandIcon: null,
    rotate: 180
  };
  const CollapseContext = React.createContext(collapseContext);
  const defaultProps$n = {
    ...ComponentDefaults,
    title: null,
    name: "",
    expandIcon: null,
    disabled: false,
    extra: null
  };
  const CollapseItem = (props) => {
    const {
      children,
      title,
      name,
      disabled,
      expandIcon,
      rotate,
      extra,
      style,
      className,
      ...rest
    } = {
      ...defaultProps$n,
      ...props
    };
    const classPrefix2 = "nut-collapse-item";
    const context = React.useContext(CollapseContext);
    const wrapperRef = React.useRef(null);
    const contentRef = React.useRef(null);
    const expanded = React.useMemo(() => {
      if (context) {
        return context.isOpen(name);
      }
      return false;
    }, [name, context.isOpen]);
    const iconStyle = React.useMemo(() => {
      return expanded ? { transform: `translateY(-50%) rotate(${rotate || context.rotate}deg)` } : { transform: "translateY(-50%)" };
    }, [expanded, rotate]);
    const handleClick2 = () => {
      if (!disabled) {
        context.updateValue(name);
      }
    };
    const onTransitionEnd = () => {
      if (expanded) {
        if (wrapperRef.current) {
          wrapperRef.current.style.height = "";
        }
      }
    };
    const getOffsetHeight = () => {
      var _a;
      const height = (_a = contentRef.current) == null ? void 0 : _a.offsetHeight;
      return height ? `${height}px` : "";
    };
    const toggle = () => {
      const start2 = expanded ? "0px" : getOffsetHeight();
      if (wrapperRef.current) {
        wrapperRef.current.style.height = start2;
      }
      requestAnimationFrame(() => {
        requestAnimationFrame(() => {
          const end = expanded ? getOffsetHeight() : "0px";
          if (wrapperRef.current) {
            wrapperRef.current.style.height = end;
          }
        });
      });
    };
    const init = React.useRef(true);
    React.useEffect(() => {
      if (init.current) {
        init.current = false;
        if (!expanded) {
          wrapperRef.current.style.height = "0px";
        }
      } else {
        toggle();
      }
    }, [expanded]);
    return /* @__PURE__ */ React.createElement("div", { className: classNames(classPrefix2, className), style, ...rest }, /* @__PURE__ */ React.createElement(
      "div",
      {
        className: classNames(`${classPrefix2}-header`, { disabled }),
        onClick: handleClick2
      },
      /* @__PURE__ */ React.createElement("div", { className: `${classPrefix2}-title` }, title),
      /* @__PURE__ */ React.createElement("div", { className: `${classPrefix2}-extra` }, extra),
      /* @__PURE__ */ React.createElement("div", { className: `${classPrefix2}-icon-box` }, /* @__PURE__ */ React.createElement("div", { className: `${classPrefix2}-icon`, style: iconStyle }, expandIcon || context.expandIcon))
    ), /* @__PURE__ */ React.createElement(
      "div",
      {
        className: `${classPrefix2}-content`,
        onTransitionEnd,
        ref: wrapperRef
      },
      /* @__PURE__ */ React.createElement("div", { ref: contentRef, className: `${classPrefix2}-content-text` }, children)
    ));
  };
  CollapseItem.displayName = "NutCollapseItem";
  const defaultProps$m = {
    ...ComponentDefaults,
    defaultActiveName: [],
    accordion: false,
    expandIcon: null,
    rotate: 180
  };
  const Collapse = (props) => {
    const {
      className,
      style,
      children,
      activeName,
      defaultActiveName,
      accordion,
      expandIcon,
      rotate,
      onChange
    } = {
      ...defaultProps$m,
      ...props
    };
    const classPrefix2 = "nut-collapse";
    const [value, setValue] = usePropsValue({
      value: activeName,
      defaultValue: defaultActiveName,
      finalValue: []
    });
    const changeVal = (newValue, name, isOpen2) => {
      setValue(newValue);
      onChange && onChange(newValue, name, isOpen2);
    };
    const updateValue = (name) => {
      if (accordion) {
        if (value === name) {
          changeVal("", name, false);
        } else {
          changeVal(name, name, true);
        }
      } else if (Array.isArray(value)) {
        if (value.includes(name)) {
          const newValue = value.filter((v) => v !== name);
          changeVal(newValue, name, false);
        } else {
          const newValue = value.concat([name]);
          changeVal(newValue, name, true);
        }
      } else {
        console.warn("[NutUI] <Collapse> 未开启手风琴模式时 activeName 应为数组");
      }
    };
    const isOpen = React.useCallback(
      (name) => {
        if (accordion) {
          return value === name;
        }
        if (Array.isArray(value)) {
          return value.includes(name);
        }
        return false;
      },
      [accordion, value]
    );
    return /* @__PURE__ */ React.createElement(
      CollapseContext.Provider,
      {
        value: {
          isOpen,
          updateValue,
          expandIcon,
          rotate
        }
      },
      /* @__PURE__ */ React.createElement("div", { className: classNames(classPrefix2, className), style }, children)
    );
  };
  Collapse.displayName = "NutCollapse";
  Collapse.Item = CollapseItem;
  const defaultProps$l = {
    ...ComponentDefaults,
    paused: false,
    startTime: Date.now(),
    endTime: Date.now(),
    remainingTime: 0,
    millisecond: false,
    format: "HH:mm:ss",
    autoStart: true,
    time: 0,
    destroy: false
  };
  const InternalCountDown = (props, ref) => {
    const {
      paused,
      startTime,
      endTime,
      remainingTime,
      millisecond,
      format: format2,
      autoStart,
      time,
      destroy,
      className,
      style,
      onEnd,
      onPaused,
      onRestart,
      onUpdate,
      children,
      ...rest
    } = { ...defaultProps$l, ...props };
    const classPrefix2 = "nut-countdown";
    const [restTimeStamp, setRestTime] = React.useState(0);
    const stateRef = React.useRef({
      pauseTime: 0,
      curr: 0,
      isPaused: paused,
      isIninted: false,
      timer: 0,
      restTime: 0,
      // 倒计时剩余时间时间
      counting: !paused && autoStart,
      // 是否处于倒计时中
      handleEndTime: Date.now(),
      // 最终截止时间
      diffTime: 0
      // 设置了 startTime 时，与 date.now() 的差异
    });
    const getTimeStamp = (timeStr) => {
      if (!timeStr) return Date.now();
      let t = timeStr;
      t = Number(t) > 0 ? +t : t.toString().replace(/-/g, "/");
      return new Date(t).getTime();
    };
    const initTime = () => {
      if (remainingTime) {
        stateRef.current.handleEndTime = Date.now() + Number(remainingTime);
      } else {
        stateRef.current.handleEndTime = endTime;
        stateRef.current.diffTime = Date.now() - getTimeStamp(startTime);
      }
      if (!stateRef.current.counting) stateRef.current.counting = true;
      tick();
    };
    const tick = () => {
      stateRef.current.timer = requestAnimationFrame(() => {
        if (stateRef.current.counting) {
          const currentTime = Date.now() - stateRef.current.diffTime;
          const remainTime = Math.max(
            stateRef.current.handleEndTime - currentTime,
            0
          );
          stateRef.current.restTime = remainTime;
          setRestTime(remainTime);
          if (!remainTime) {
            stateRef.current.counting = false;
            pause();
            onEnd && onEnd();
          }
          if (remainTime > 0) {
            tick();
          }
        }
      });
    };
    const formatRemainTime = (t, type) => {
      const ts2 = t;
      const rest2 = {
        d: 0,
        h: 0,
        m: 0,
        s: 0,
        ms: 0
      };
      const SECOND = 1e3;
      const MINUTE = 60 * SECOND;
      const HOUR = 60 * MINUTE;
      const DAY = 24 * HOUR;
      if (ts2 > 0) {
        rest2.d = ts2 >= SECOND ? Math.floor(ts2 / DAY) : 0;
        rest2.h = Math.floor(ts2 % DAY / HOUR);
        rest2.m = Math.floor(ts2 % HOUR / MINUTE);
        rest2.s = Math.floor(ts2 % MINUTE / SECOND);
        rest2.ms = Math.floor(ts2 % SECOND);
      }
      return type === "custom" ? rest2 : parseFormat({ ...rest2 });
    };
    const parseFormat = (time2) => {
      const { d: d2 } = time2;
      let { h, m: m2, s: s2, ms } = time2;
      let formatCache = format2;
      if (formatCache.includes("DD")) {
        formatCache = formatCache.replace("DD", padZero(d2));
      } else {
        h += Number(d2) * 24;
      }
      if (formatCache.includes("HH")) {
        formatCache = formatCache.replace("HH", padZero(h));
      } else {
        m2 += Number(h) * 60;
      }
      if (formatCache.includes("mm")) {
        formatCache = formatCache.replace("mm", padZero(m2));
      } else {
        s2 += Number(m2) * 60;
      }
      if (formatCache.includes("ss")) {
        formatCache = formatCache.replace("ss", padZero(s2));
      } else {
        ms += Number(s2) * 1e3;
      }
      if (formatCache.includes("S")) {
        const msC = padZero(ms, 3).toString();
        if (formatCache.includes("SSS")) {
          formatCache = formatCache.replace("SSS", msC);
        } else if (formatCache.includes("SS")) {
          formatCache = formatCache.replace("SS", msC.slice(0, 2));
        } else if (formatCache.includes("S")) {
          formatCache = formatCache.replace("SS", msC.slice(0, 1));
        }
      }
      return formatCache;
    };
    const pause = () => {
      cancelAnimationFrame(stateRef.current.timer);
      stateRef.current.counting = false;
      onPaused && onPaused(stateRef.current.restTime);
    };
    React.useImperativeHandle(ref, () => ({
      start: () => {
        if (!stateRef.current.counting && !autoStart) {
          stateRef.current.counting = true;
          stateRef.current.handleEndTime = Date.now() + Number(stateRef.current.restTime);
          tick();
          onRestart && onRestart(stateRef.current.restTime);
        }
      },
      pause: () => {
        cancelAnimationFrame(stateRef.current.timer);
        stateRef.current.counting = false;
        onPaused && onPaused(stateRef.current.restTime);
      },
      reset: () => {
        if (!autoStart) {
          pause();
          stateRef.current.restTime = time;
          setRestTime(time);
        }
      }
    }));
    React.useEffect(() => {
      const tranTime = formatRemainTime(stateRef.current.restTime, "custom");
      onUpdate && onUpdate(tranTime);
    }, [restTimeStamp]);
    React.useEffect(() => {
      if (stateRef.current.isIninted) {
        if (paused) {
          if (stateRef.current.counting) {
            pause();
          }
        } else {
          if (!stateRef.current.counting) {
            stateRef.current.counting = true;
            stateRef.current.handleEndTime = Date.now() + Number(stateRef.current.restTime);
            tick();
          }
          onRestart && onRestart(stateRef.current.restTime);
        }
      }
    }, [paused]);
    React.useEffect(() => {
      if (stateRef.current.isIninted) {
        initTime();
      }
    }, [endTime, startTime, remainingTime]);
    React.useEffect(() => {
      if (autoStart) {
        initTime();
      } else {
        stateRef.current.restTime = time;
        setRestTime(time);
      }
      if (!stateRef.current.isIninted) {
        stateRef.current.isIninted = true;
      }
      return componentWillUnmount;
    }, []);
    const componentWillUnmount = () => {
      destroy && cancelAnimationFrame(stateRef.current.timer);
    };
    const renderTime = (() => {
      return formatRemainTime(stateRef.current.restTime);
    })();
    return /* @__PURE__ */ React.createElement(
      "div",
      {
        className: `${classPrefix2} ${className}`,
        style: { ...style },
        ...rest
      },
      children || /* @__PURE__ */ React.createElement(
        "div",
        {
          className: `${classPrefix2}-block`,
          dangerouslySetInnerHTML: {
            __html: `${renderTime}`
          }
        }
      )
    );
  };
  const CountDown = React.forwardRef(
    InternalCountDown
  );
  CountDown.displayName = "NutCountDown";
  const useIsomorphicLayoutEffect = canUseDom ? React.useLayoutEffect : React.useEffect;
  const defaultProps$k = {
    ...ComponentDefaults,
    content: "",
    direction: "end",
    rows: 1,
    expandText: "",
    collapseText: "",
    symbol: "...",
    lineHeight: "20"
  };
  const classPrefix$5 = `nut-ellipsis`;
  const Ellipsis = (props) => {
    var _a, _b;
    const {
      children,
      content,
      className,
      direction,
      rows,
      expandText,
      collapseText,
      symbol,
      lineHeight,
      onClick,
      onChange,
      ...rest
    } = { ...defaultProps$k, ...props };
    const rtl = useRtl();
    let container = null;
    let maxHeight = 0;
    const [exceeded, setExceeded] = React.useState(false);
    const [expanded, setExpanded] = React.useState(false);
    const ellipsis = React.useRef();
    const root2 = React.useRef(null);
    const rtlClasses = classNames({
      [`${classPrefix$5}-rtl`]: rtl
    });
    const classes = classNames(classPrefix$5, rtlClasses, className);
    useIsomorphicLayoutEffect(() => {
      if (content) {
        createContainer();
      }
    }, [content]);
    const createContainer = () => {
      if (!root2.current) return;
      const originStyle = window.getComputedStyle(root2.current);
      container = document.createElement("div");
      const styleNames = Array.prototype.slice.apply(originStyle);
      styleNames.forEach((name) => {
        container.style.setProperty(name, originStyle.getPropertyValue(name));
      });
      container.style.position = "fixed";
      container.style.left = "999999px";
      container.style.top = "999999px";
      container.style.zIndex = "-1000";
      container.style.height = "auto";
      container.style.minHeight = "auto";
      container.style.maxHeight = "auto";
      container.style.textOverflow = "clip";
      container.style.whiteSpace = "normal";
      container.style.webkitLineClamp = "unset";
      container.style.display = "block";
      const lineH = pxToNumber(
        originStyle.lineHeight === "normal" ? lineHeight : originStyle.lineHeight
      );
      maxHeight = Math.floor(
        lineH * (Number(rows) + 0.5) + pxToNumber(originStyle.paddingTop) + pxToNumber(originStyle.paddingBottom)
      );
      container.innerText = content;
      document.body.appendChild(container);
      calcEllipse();
      document.body.removeChild(container);
    };
    const calcEllipse = () => {
      if (container.offsetHeight <= maxHeight) {
        setExceeded(false);
      } else {
        setExceeded(true);
        const end = content.length;
        const middle = Math.floor((0 + end) / 2);
        const ellipsised = direction === "middle" ? tailorMiddle([0, middle], [middle, end]) : tailor(0, end);
        ellipsis.current = ellipsised;
      }
    };
    const tailor = (left, right) => {
      const actionText = expanded ? collapseText : expandText;
      const end = content.length;
      if (right - left <= 1) {
        if (direction === "end") {
          return {
            leading: content.slice(0, left) + symbol
          };
        }
        return {
          tailing: symbol + content.slice(right, end)
        };
      }
      const middle = Math.round((left + right) / 2);
      if (direction === "end") {
        container.innerText = content.slice(0, middle) + symbol + actionText;
      } else {
        container.innerText = actionText + symbol + content.slice(middle, end);
      }
      if (container.offsetHeight <= maxHeight) {
        if (direction === "end") {
          return tailor(middle, right);
        }
        return tailor(left, middle);
      }
      if (direction === "end") {
        return tailor(left, middle);
      }
      return tailor(middle, right);
    };
    const tailorMiddle = (leftPart, rightPart) => {
      const actionText = expanded ? collapseText : expandText;
      const end = content.length;
      if (leftPart[1] - leftPart[0] <= 1 && rightPart[1] - rightPart[0] <= 1) {
        return {
          leading: content.slice(0, leftPart[0]) + symbol,
          tailing: symbol + content.slice(rightPart[1], end)
        };
      }
      const leftPartMiddle = Math.floor((leftPart[0] + leftPart[1]) / 2);
      const rightPartMiddle = Math.ceil((rightPart[0] + rightPart[1]) / 2);
      container.innerText = content.slice(0, leftPartMiddle) + symbol + actionText + symbol + content.slice(rightPartMiddle, end);
      if (container.offsetHeight <= maxHeight) {
        return tailorMiddle(
          [leftPartMiddle, leftPart[1]],
          [rightPart[0], rightPartMiddle]
        );
      }
      return tailorMiddle(
        [leftPart[0], leftPartMiddle],
        [rightPartMiddle, rightPart[1]]
      );
    };
    const pxToNumber = (value) => {
      if (!value) return 0;
      const match = value.match(/^\d*(\.\d*)?/);
      return match ? Number(match[0]) : 0;
    };
    const clickHandle = (type) => {
      if (type === 1) {
        setExpanded(true);
        onChange && onChange("expand");
      } else {
        setExpanded(false);
        onChange && onChange("collapse");
      }
    };
    const handleClick2 = () => {
      onClick && onClick();
    };
    return /* @__PURE__ */ React.createElement("div", { className: classes, onClick: handleClick2, ref: root2, ...rest }, !exceeded ? content : null, exceeded && !expanded ? /* @__PURE__ */ React.createElement("span", null, (_a = ellipsis.current) == null ? void 0 : _a.leading, expandText ? /* @__PURE__ */ React.createElement(
      "span",
      {
        className: "nut-ellipsis-text",
        onClick: (e) => {
          e.stopPropagation();
          clickHandle(1);
        }
      },
      expandText
    ) : null, (_b = ellipsis.current) == null ? void 0 : _b.tailing) : null, exceeded && expanded ? /* @__PURE__ */ React.createElement("span", null, content, expandText ? /* @__PURE__ */ React.createElement(
      "span",
      {
        className: "nut-ellipsis-text",
        onClick: (e) => {
          e.stopPropagation();
          clickHandle(2);
        }
      },
      collapseText
    ) : null) : null);
  };
  Ellipsis.displayName = "NutEllipsis";
  const defaultProps$j = {
    ...ComponentDefaults,
    source: {
      type: {},
      src: ""
    },
    options: {
      controls: true,
      muted: false,
      // 默认不是静音
      autoplay: false,
      poster: "",
      playsinline: false,
      loop: false
    }
  };
  const classPrefix$4 = `nut-video`;
  const Video = React.forwardRef((props, ref) => {
    const {
      children,
      source,
      options: options2,
      className,
      onPlay,
      onPause,
      onPlayEnd,
      ...restProps
    } = {
      ...defaultProps$j,
      ...props
    };
    const rootRef = React.useRef(null);
    const classes = classNames(classPrefix$4, className);
    React.useEffect(() => {
      init();
    }, []);
    const init = () => {
      if (rootRef.current) {
        const videoRef = rootRef.current;
        if (options2.autoplay) {
          setTimeout(() => {
            videoRef.play();
          }, 200);
        }
        if (options2.playsinline) {
          videoRef.setAttribute("playsinline", String(options2.playsinline));
          videoRef.setAttribute("webkit-playsinline", String(options2.playsinline));
          videoRef.setAttribute("x5-video-player-type", "h5-page");
          videoRef.setAttribute("x5-video-player-fullscreen", "false");
        }
        videoRef.addEventListener("play", () => {
          onPlay && onPlay(videoRef);
        });
        videoRef.addEventListener("pause", () => {
          onPause && onPause(videoRef);
        });
        videoRef.addEventListener("ended", () => {
          videoRef.currentTime = 0;
          onPlayEnd && onPlayEnd(videoRef);
        });
      }
    };
    const pause = () => {
      var _a;
      (_a = rootRef == null ? void 0 : rootRef.current) == null ? void 0 : _a.pause();
    };
    const play = () => {
      var _a;
      (_a = rootRef == null ? void 0 : rootRef.current) == null ? void 0 : _a.play();
    };
    React.useImperativeHandle(ref, () => ({
      pause,
      play
    }));
    return /* @__PURE__ */ React.createElement("div", { className: classes, ...restProps }, /* @__PURE__ */ React.createElement(
      "video",
      {
        className: "nut-video-player",
        muted: options2.muted,
        autoPlay: options2.autoplay,
        loop: options2.loop,
        poster: options2.poster,
        controls: options2.controls,
        ref: rootRef,
        src: source.src
      },
      /* @__PURE__ */ React.createElement("source", { src: source.src, type: source.type }),
      /* @__PURE__ */ React.createElement("track", { kind: "captions" })
    ));
  });
  Video.displayName = "NutVideo";
  const defaultProps$i = {
    total: 3,
    current: 0,
    direction: "horizontal"
  };
  const classPrefix$3 = `nut-indicator`;
  const Indicator = (props) => {
    const { total, current, children, className, direction, ...rest } = {
      ...defaultProps$i,
      ...props
    };
    const classes = classNames({
      [`${classPrefix$3}-vertical`]: direction === "vertical"
    });
    const renderElement = () => {
      const childs = [];
      for (let item = 0; item < total; item++) {
        childs.push(
          item === current ? children || /* @__PURE__ */ React.createElement(
            "div",
            {
              key: item,
              className: `${classPrefix$3}-dot ${classPrefix$3}-active`
            }
          ) : /* @__PURE__ */ React.createElement("div", { key: item, className: `${classPrefix$3}-dot` })
        );
      }
      return childs;
    };
    return /* @__PURE__ */ React.createElement("div", { className: classNames(classPrefix$3, classes, className), ...rest }, renderElement());
  };
  Indicator.displayName = "NutIndicator";
  const getRefValue = (ref) => {
    return ref.current;
  };
  const useRefState = (param) => {
    const ref = React.useRef(param);
    const [, setState] = React.useState(param);
    const updateState = (p2) => {
      ref.current = p2;
      setState(p2);
    };
    return [ref, updateState];
  };
  const getPerSlidePosition$1 = (index, position, loop2, count) => {
    const currentPosition = index * 100 + position;
    if (loop2) {
      const cycle = count * 100;
      const shift = cycle / 2;
      const nextPosition = (currentPosition + shift) % cycle;
      const shiftedPosition = (nextPosition < 0 ? nextPosition + cycle : nextPosition) - shift;
      return `${shiftedPosition}%`;
    }
    return `${currentPosition}%`;
  };
  const defaultEffect = (args) => {
    return React.Children.map(args.children, (child, index) => {
      const { isVertical, getSpringsAxis, loop: loop2, count } = args;
      const rtl = useRtl();
      const position = rtl ? "right" : "left";
      return /* @__PURE__ */ React.createElement(
        animated.div,
        {
          className: "nut-swiper-slide",
          style: {
            [isVertical ? "y" : "x"]: getSpringsAxis().to((position2) => {
              return getPerSlidePosition$1(index, position2, loop2, count);
            }),
            [isVertical ? "top" : position]: `-${index * 100}%`
          }
        },
        child
      );
    });
  };
  const getPerSlidePosition = (index, position, loop2, count) => {
    const currentPosition = index * 100 + position;
    if (loop2) {
      const cycle = count * 100;
      const shift = cycle / 2;
      const nextPosition = (currentPosition + shift) % cycle;
      const shiftedPosition = (nextPosition < 0 ? nextPosition + cycle : nextPosition) - shift;
      return `${shiftedPosition}%`;
    }
    return `${currentPosition}%`;
  };
  const focusEffect = (args) => {
    return React.Children.map(args.children, (child, index) => {
      const rtl = useRtl();
      const position = rtl ? "right" : "left";
      const {
        isVertical,
        springs,
        transforms,
        loop: loop2,
        count,
        swiperDirection,
        dragging,
        current,
        effect
      } = args;
      return /* @__PURE__ */ React.createElement(
        animated.div,
        {
          className: "nut-swiper-slide",
          style: {
            [isVertical ? "y" : "x"]: springs[isVertical ? "y" : "x"].to(
              (position2) => {
                return getPerSlidePosition(index, position2, loop2, count);
              }
            ),
            [isVertical ? "top" : position]: `-${index * 100}%`,
            scale: springs.s.to((ss) => {
              const scales = getRefValue(transforms);
              if (!scales) return 1;
              const scale = scales[index];
              const currentRefValue = getRefValue(current);
              if (dragging === false) ss = 0;
              const ps = ss * scale;
              if (index === currentRefValue) {
                return Math.max(scale - ps, effect.scale);
              }
              if (index === currentRefValue + swiperDirection.current) {
                return Math.min(scale + ps, 1);
              }
              return scale;
            })
          }
        },
        child
      );
    });
  };
  const useList = (effect, count, current) => {
    const [transforms, setTransforms] = useRefState([]);
    React.useEffect(() => {
      setTransforms(
        Array.from({ length: count }).fill(1).map(
          (scale, index) => index !== getRefValue(current) ? scale * (effect ? effect.scale : 1) : scale
        )
      );
    }, [count]);
    return [transforms, setTransforms];
  };
  const updateTransform = (transforms, setTransforms, effect, page) => {
    setTransforms(
      getRefValue(transforms).map(
        (s2, index) => (
          // eslint-disable-next-line no-nested-ternary
          page === index ? 1 : effect ? effect.scale : 1
        )
      )
    );
  };
  const defaultProps$h = {
    direction: "horizontal",
    indicator: false,
    loop: false,
    duration: 3e3,
    autoPlay: false,
    defaultValue: 0,
    touchable: true,
    effect: void 0
  };
  const Swiper = React.forwardRef(
    (props, ref) => {
      const classPrefix2 = "nut-swiper";
      const {
        children,
        direction,
        indicator,
        loop: loop2,
        effect,
        autoPlay,
        touchable,
        defaultValue,
        duration,
        style,
        className
      } = { ...defaultProps$h, ...props };
      const isVertical = direction === "vertical";
      const count = React.useMemo(() => {
        let c6 = 0;
        React.Children.map(children, (child, index) => {
          c6 += 1;
        });
        return c6;
      }, [children]);
      const getSlideSize = () => {
        if (props.slideSize) return props.slideSize;
        if (stageRef.current) {
          if (isVertical) return stageRef.current.offsetHeight;
          return stageRef.current.offsetWidth;
        }
        return 0;
      };
      const getSwiperSize = () => {
        if (swiperRef.current) {
          if (isVertical) return swiperRef.current.offsetHeight;
          return swiperRef.current.offsetWidth;
        }
        return 0;
      };
      const bound2 = (v, min, max) => {
        if (min !== void 0) {
          v = Math.max(v, min);
        }
        if (max !== void 0) {
          v = Math.min(v, max);
        }
        return v;
      };
      const timeoutRef = React.useRef(null);
      const [dragging, setDragging] = React.useState(false);
      const [current, setCurrent] = useRefState(defaultValue);
      const stageRef = React.useRef(null);
      const swiperRef = React.useRef(null);
      const [springs, api] = useSpring(() => ({
        x: !isVertical ? current.current * 100 * -1 : 0,
        y: isVertical ? current.current * 100 * -1 : 0,
        s: 0,
        reset: () => {
        },
        config: { tension: 200, friction: 30 }
      }));
      React.useEffect(() => {
        api.start({
          [isVertical ? "y" : "x"]: boundIndex(current.current) * -1 * 100,
          immediate: true
        });
      }, [swiperRef.current]);
      const swiperDirection = React.useRef(1);
      const [transforms, setTransforms] = useList(effect, count, current);
      const runTimeSwiper = () => {
        const durationNumber = typeof duration === "string" ? parseInt(duration) : duration;
        const d2 = typeof autoPlay === "number" ? autoPlay : durationNumber;
        timeoutRef.current = window.setTimeout(() => {
          next();
          runTimeSwiper();
        }, d2);
      };
      React.useEffect(() => {
        if (!autoPlay || dragging) return;
        runTimeSwiper();
        return () => {
          if (timeoutRef.current) window.clearTimeout(timeoutRef.current);
        };
      }, [autoPlay, duration, dragging, count]);
      function boundIndex(current2) {
        const min = 0;
        const max = count - 1;
        if (current2 === max && !loop2 && props.slideSize) {
          const slideSize = props.slideSize;
          const swiperSize = getSwiperSize();
          const ratio = (swiperSize - slideSize) / slideSize;
          return bound2(current2, min, max - ratio);
        }
        return current2;
      }
      const to2 = (index, immediate = false) => {
        var _a;
        let targetIndex = bound2(index, 0, count - 1);
        if (loop2) {
          const cycleIndex = index % count;
          targetIndex = cycleIndex < 0 ? cycleIndex + count : cycleIndex;
        }
        setCurrent(targetIndex);
        (_a = props.onChange) == null ? void 0 : _a.call(props, targetIndex);
        if (effect) {
          updateTransform(transforms, setTransforms, effect, targetIndex);
        }
        api.start({
          // 这里需要统一成百分比
          [isVertical ? "y" : "x"]: (loop2 ? -index : boundIndex(targetIndex) * -1) * 100,
          s: 0,
          immediate
        });
      };
      const getSpringsAxis = () => {
        return springs[isVertical ? "y" : "x"];
      };
      const next = () => {
        to2(Math.round(-getSpringsAxis().get() / 100) + 1);
      };
      const prev = () => {
        to2(Math.round(-getSpringsAxis().get() / 100) - 1);
      };
      React.useImperativeHandle(ref, () => ({
        to: to2,
        next,
        prev
      }));
      const bind = useDrag(
        (state) => {
          const axis = Number(isVertical);
          const slideSize = getSlideSize();
          const offset = state.offset[axis];
          setDragging(!!state.dragging);
          const distance = state.distance[axis];
          swiperDirection.current = state.direction[axis];
          if (state.last) {
            const swipeDirection = state.direction[axis];
            const velocity = state.velocity[axis];
            const minIndex = Math.floor(offset / slideSize);
            const maxIndex = minIndex + 1;
            const index = Math.round(
              (offset + velocity * 2e3 * swipeDirection) / slideSize
            );
            to2(bound2(index, minIndex, maxIndex));
          } else {
            api.start({
              [isVertical ? "y" : "x"]: -(offset / slideSize * 100),
              s: distance / slideSize,
              immediate: true
            });
          }
        },
        {
          enabled: touchable,
          transform: ([x, y]) => [-x, -y],
          from: () => {
            const slideSize = getSlideSize();
            const x = springs.x.get() / 100 * slideSize;
            const y = springs.y.get() / 100 * slideSize;
            return [-x, -y];
          },
          bounds: () => {
            if (loop2) return {};
            const slideSize = getSlideSize();
            if (isVertical) {
              return { top: 0, bottom: (count - 1) * slideSize };
            }
            return { left: 0, right: (count - 1) * slideSize };
          },
          rubberband: true,
          triggerAllEvents: true,
          preventScroll: isVertical,
          axis: isVertical ? "y" : "x",
          pointer: {
            touch: true
          }
        }
      );
      const renderIndicator = () => {
        if (React.isValidElement(indicator)) return indicator;
        if (!indicator) return null;
        return /* @__PURE__ */ React.createElement(
          "div",
          {
            className: classNames({
              [`${classPrefix2}-indicator`]: true,
              [`${classPrefix2}-indicator-vertical`]: isVertical,
              [`${classPrefix2}-indicator-horizontal`]: !isVertical
            })
          },
          /* @__PURE__ */ React.createElement(
            Indicator,
            {
              current: getRefValue(current),
              total: count,
              direction
            }
          )
        );
      };
      const renderEffect = () => {
        if (!effect)
          return defaultEffect({
            children,
            getSpringsAxis,
            loop: loop2,
            count,
            isVertical
          });
        if (effect && effect.name === "focus") {
          return focusEffect({
            children,
            springs,
            loop: loop2,
            count,
            isVertical,
            effect,
            current,
            swiperDirection,
            dragging,
            transforms
          });
        }
      };
      const renderSlides = () => {
        return /* @__PURE__ */ React.createElement(
          "div",
          {
            ref: stageRef,
            className: classNames("nut-swiper-inner", {
              [`${classPrefix2}-inner-vertical`]: isVertical,
              [`${classPrefix2}-inner-horizontal`]: !isVertical
            }),
            style: {
              ...props.slideSize ? { [isVertical ? "height" : "width"]: `${props.slideSize}px` } : {}
            }
          },
          renderEffect()
        );
      };
      return /* @__PURE__ */ React.createElement(
        "div",
        {
          className: classNames(
            classPrefix2,
            `${classPrefix2}-canmove-${direction}`,
            className
          ),
          style,
          ref: swiperRef,
          ...bind()
        },
        renderSlides(),
        renderIndicator()
      );
    }
  );
  Swiper.displayName = "NutSwiper";
  const defaultProps$g = {
    onClick: (e) => void 0
  };
  const SwiperItem = (props) => {
    const classPrefix2 = "nut-swiper-item";
    const { className, style, children } = { ...defaultProps$g, ...props };
    const classes = classNames(classPrefix2, className);
    return /* @__PURE__ */ React.createElement("div", { className: classes, onClick: props.onClick, style }, children);
  };
  SwiperItem.displayName = "NutSwiperItem";
  const InnerSwiper = Swiper;
  InnerSwiper.Item = SwiperItem;
  const defaultProps$f = {
    ...ComponentDefaults,
    images: [],
    videos: [],
    visible: false,
    autoPlay: 3e3,
    defaultValue: 0,
    closeOnContentClick: false,
    pagination: true,
    indicator: false,
    indicatorColor: "#fff",
    closeIcon: false,
    closeIconPosition: "top-right",
    onChange: (value) => {
    },
    onClose: () => {
    }
  };
  const ImagePreview = (props) => {
    const {
      value,
      className,
      style,
      images,
      videos,
      visible,
      defaultValue,
      indicatorColor,
      pagination,
      indicator,
      autoPlay,
      closeOnContentClick,
      closeIcon,
      closeIconPosition,
      onClose,
      onChange
    } = { ...defaultProps$f, ...props };
    const classPrefix2 = "nut-imagepreview";
    const ref = React.useRef(null);
    const [innerNo, setInnerNo] = usePropsValue({
      value,
      defaultValue,
      finalValue: defaultValue,
      onChange: (val) => {
        onChange == null ? void 0 : onChange(val);
      }
    });
    const [showPop, setShowPop] = React.useState(visible);
    const [active, setActive] = React.useState(0);
    const [maxNo, setMaxNo] = React.useState(
      (images == null ? void 0 : images.length) || 0 + ((videos == null ? void 0 : videos.length) || 0)
    );
    const [store, setStore] = React.useState({
      scale: 1,
      moveable: false
    });
    const [lastTouchEndTime, setLastTouchEndTime] = React.useState(0);
    const onTouchStart = (event) => {
      const touches = event.touches;
      const events = touches[0];
      const events2 = touches[1];
      const curTouchTime = (/* @__PURE__ */ new Date()).getTime();
      if (curTouchTime - lastTouchEndTime < 300) {
        const store12 = store;
        if (store12.scale > 1) {
          store12.scale = 1;
        } else if (store12.scale === 1) {
          store12.scale = 2;
        }
        scaleNow();
      }
      const store1 = store;
      store1.moveable = true;
      if (events2) {
        store1.oriDistance = getDistance(
          {
            x: events.pageX,
            y: events.pageY
          },
          {
            x: events2.pageX,
            y: events2.pageY
          }
        );
      }
      store1.originScale = store1.scale || 1;
    };
    const onTouchMove = (event) => {
      const touches = event.touches;
      const events = touches[0];
      const events2 = touches[1];
      if (!store.moveable) {
        return;
      }
      const store1 = store;
      if (events2) {
        const curDistance = getDistance(
          {
            x: events.pageX,
            y: events.pageY
          },
          {
            x: events2.pageX,
            y: events2.pageY
          }
        );
        const curScale = curDistance / store1.oriDistance;
        store1.scale = store1.originScale * curScale;
        if (store1.scale > 3) {
          store1.scale = 3;
        }
        scaleNow();
      }
    };
    const onTouchEnd = () => {
      setLastTouchEndTime((/* @__PURE__ */ new Date()).getTime());
      const store1 = store;
      store1.moveable = false;
      if (store1.scale < 1.1 && store1.scale > 1 || store1.scale < 1) {
        store1.scale = 1;
        scaleNow();
      }
    };
    React.useEffect(() => {
      init();
    }, []);
    const init = () => {
      document.addEventListener("touchmove", onTouchMove);
      document.addEventListener("touchend", onTouchEnd);
      document.addEventListener("touchcancel", onTouchEnd);
    };
    React.useEffect(() => {
      setShowPop(visible);
    }, [visible]);
    React.useEffect(() => {
      setInnerNo(defaultValue || 1);
    }, [defaultValue]);
    React.useEffect(() => {
      setActive(innerNo);
    }, [innerNo]);
    React.useEffect(() => {
      setMaxNo((images == null ? void 0 : images.length) || 0 + ((videos == null ? void 0 : videos.length) || 0));
    }, [images, videos]);
    const scaleNow = () => {
      if (ref.current) {
        ref.current.style.transform = `scale(${store.scale})`;
      }
    };
    const getDistance = (first, second) => {
      return Math.hypot(
        Math.abs(second.x - first.x),
        Math.abs(second.y - first.y)
      );
    };
    const slideChangeEnd = (page) => {
      setActive(page + 1);
      onChange == null ? void 0 : onChange(page + 1);
    };
    const onCloseInner = (e) => {
      e.stopPropagation();
      setShowPop(false);
      setActive(innerNo);
      scaleNow();
      onClose && onClose();
      setStore({
        ...store,
        scale: 1
      });
    };
    const closeOnImg = (e) => {
      e.stopPropagation();
      if (closeOnContentClick) {
        onCloseInner(e);
      }
    };
    const duration = typeof autoPlay === "string" ? parseInt(autoPlay) : autoPlay;
    return /* @__PURE__ */ React.createElement(
      Popup,
      {
        visible: showPop,
        className: `${classPrefix2}-pop`,
        style: { width: "100%" },
        onClick: onCloseInner
      },
      /* @__PURE__ */ React.createElement(
        "div",
        {
          className: classNames(classPrefix2, className),
          style,
          ref,
          onTouchStart
        },
        showPop ? /* @__PURE__ */ React.createElement(
          InnerSwiper,
          {
            autoPlay: !!duration,
            duration,
            className: `${classPrefix2}-swiper`,
            loop: true,
            style: {
              "--nutui-indicator-color": indicatorColor
            },
            direction: "horizontal",
            onChange: (page) => slideChangeEnd(page),
            defaultValue: innerNo && (innerNo > maxNo ? maxNo - 1 : innerNo - 1),
            indicator
          },
          (videos ?? []).map(
            (item) => ({ type: "video", data: item })
          ).concat(
            (images ?? []).map((item) => ({ type: "image", data: item }))
          ).sort((a, b) => {
            var _a, _b;
            return (((_a = a.data) == null ? void 0 : _a.index) ?? 0) - (((_b = b.data) == null ? void 0 : _b.index) ?? 0);
          }).map((item, index) => {
            if (item.type === "video") {
              const { source, options: options2 } = item.data;
              return /* @__PURE__ */ React.createElement(SwiperItem, { key: index }, /* @__PURE__ */ React.createElement(
                Video,
                {
                  source,
                  options: options2,
                  onClick: closeOnImg
                }
              ));
            }
            if (item.type === "image") {
              const { src } = item.data;
              return /* @__PURE__ */ React.createElement(SwiperItem, { key: index }, /* @__PURE__ */ React.createElement(Image$1, { src, draggable: false, onClick: closeOnImg }));
            }
            return null;
          })
        ) : null
      ),
      pagination ? /* @__PURE__ */ React.createElement("div", { className: `${classPrefix2}-index` }, active, "/", (images ? images.length : 0) + (videos ? videos.length : 0)) : null,
      closeIcon !== false ? /* @__PURE__ */ React.createElement(
        "div",
        {
          className: `${classPrefix2}-close ${closeIconPosition}`,
          onClick: onCloseInner
        },
        closeIcon === true ? /* @__PURE__ */ React.createElement(n$5, null) : closeIcon
      ) : null
    );
  };
  ImagePreview.displayName = "NutImagePreview";
  const defaultProps$e = {
    ...ComponentDefaults,
    defaultValue: 1,
    mode: "multi",
    prev: null,
    next: null,
    total: 50,
    pageSize: 10,
    itemSize: 5,
    ellipse: false
  };
  const Pagination = (props) => {
    const { locale } = useConfig();
    const {
      value,
      mode,
      prev,
      next,
      total,
      pageSize,
      itemSize,
      onChange,
      ellipse,
      itemRender,
      defaultValue,
      className,
      ...rest
    } = {
      ...defaultProps$e,
      ...props
    };
    const classPrefix2 = "nut-pagination";
    const [currentPage, setCurrentPage] = usePropsValue({
      value,
      defaultValue,
      finalValue: 1,
      onChange
    });
    const pageCount = React.useMemo(() => {
      const num = Math.ceil(total / pageSize);
      return Number.isNaN(num) ? 1 : Math.max(1, num);
    }, [total, pageSize]);
    const pages = React.useMemo(() => {
      const items = [];
      let startPage = 1;
      let endPage = pageCount;
      const partialShow = pageCount > itemSize;
      if (partialShow) {
        startPage = Math.max(currentPage - Math.floor(itemSize / 2), 1);
        endPage = startPage + itemSize - 1;
        if (endPage > pageCount) {
          endPage = pageCount;
          startPage = endPage - itemSize + 1;
        }
      }
      for (let i2 = startPage; i2 <= endPage; i2++) {
        items.push({ number: i2, text: i2 });
      }
      if (partialShow && itemSize > 0 && ellipse) {
        if (startPage > 1) {
          items.unshift({ number: startPage - 1, text: "..." });
        }
        if (endPage < pageCount) {
          items.push({ number: endPage + 1, text: "..." });
        }
      }
      return items;
    }, [currentPage, itemSize, pageCount]);
    const handleSelectPage = (curPage) => {
      if (curPage > pageCount || curPage < 1) return;
      setCurrentPage(curPage);
    };
    return /* @__PURE__ */ React.createElement("div", { className: classNames(classPrefix2, className), ...rest }, (mode === "multi" || mode === "simple") && /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(
      "div",
      {
        className: classNames(
          `${classPrefix2}-prev`,
          mode === "multi" ? "" : "simple-border",
          currentPage === 1 ? "disabled" : ""
        ),
        onClick: (e) => handleSelectPage(currentPage - 1)
      },
      prev || locale.pagination.prev
    ), mode === "multi" && /* @__PURE__ */ React.createElement("div", { className: `${classPrefix2}-contain` }, pages.map((item, index) => {
      return /* @__PURE__ */ React.createElement(
        "div",
        {
          key: `${index}pagination`,
          className: classNames(`${classPrefix2}-item`, {
            active: item.number === currentPage
          }),
          onClick: (e) => {
            item.number !== currentPage && handleSelectPage(item.number);
          }
        },
        itemRender ? itemRender(item) : item.text
      );
    })), mode === "simple" && /* @__PURE__ */ React.createElement("div", { className: `${classPrefix2}-contain` }, /* @__PURE__ */ React.createElement("div", { className: `${classPrefix2}-simple` }, currentPage, "/", pageCount)), /* @__PURE__ */ React.createElement(
      "div",
      {
        className: classNames(
          `${classPrefix2}-next`,
          currentPage >= pageCount ? "disabled" : ""
        ),
        onClick: (e) => handleSelectPage(currentPage + 1)
      },
      next || locale.pagination.next
    )), mode === "lite" && /* @__PURE__ */ React.createElement("div", { className: `${classPrefix2}-lite` }, /* @__PURE__ */ React.createElement("div", { className: `${classPrefix2}-lite-active` }, 2), /* @__PURE__ */ React.createElement("div", { className: `${classPrefix2}-lite-default` }, 8)));
  };
  Pagination.displayName = "NutPagination";
  const defaultProps$d = {
    ...ComponentDefaults,
    price: 0,
    symbol: "&yen;",
    digits: 2,
    thousands: false,
    position: "before",
    size: "large",
    line: false
  };
  const Price = (props) => {
    const {
      price,
      symbol,
      digits,
      thousands,
      position,
      size,
      line,
      className,
      style,
      ...rest
    } = {
      ...defaultProps$d,
      ...props
    };
    const classPrefix2 = "nut-price";
    const showSymbol = () => {
      return { __html: symbol || "" };
    };
    const checkPoint = (price2) => {
      return String(price2).indexOf(".") > 0;
    };
    const formatThousands = (num) => {
      if (Number(num) === 0) {
        num = 0;
      }
      if (checkPoint(num)) {
        num = Number(num).toFixed(digits);
        num = typeof num.split(".") === "string" ? num.split(".") : num.split(".")[0];
      } else {
        num = num.toString();
      }
      if (thousands) {
        return (num || 0).toString().replace(/(\d)(?=(?:\d{3})+$)/g, "$1,");
      }
      return num;
    };
    const formatDecimal = (decimalNum) => {
      if (Number(decimalNum) === 0) {
        decimalNum = 0;
      }
      if (checkPoint(decimalNum)) {
        decimalNum = Number(decimalNum).toFixed(digits);
        decimalNum = typeof decimalNum.split(".") === "string" ? 0 : decimalNum.split(".")[1] || 0;
      } else {
        decimalNum = 0;
      }
      const result = `0.${decimalNum}`;
      const resultFixed = Number(result).toFixed(digits);
      return String(resultFixed).substring(2, resultFixed.length);
    };
    const renderSymbol = () => {
      return /* @__PURE__ */ React.createElement(
        "div",
        {
          className: `${classPrefix2}-symbol ${classPrefix2}-symbol-${size}`,
          dangerouslySetInnerHTML: showSymbol()
        }
      );
    };
    return /* @__PURE__ */ React.createElement(
      "div",
      {
        className: `${classPrefix2} ${line ? `${classPrefix2}-line` : ""} ${className}`,
        style,
        ...rest
      },
      symbol && position === "before" ? renderSymbol() : null,
      /* @__PURE__ */ React.createElement("div", { className: `${classPrefix2}-integer ${classPrefix2}-integer-${size}` }, formatThousands(price)),
      digits !== 0 ? /* @__PURE__ */ React.createElement(
        "div",
        {
          className: `${classPrefix2}-decimal ${classPrefix2}-decimal-${size}`
        },
        "."
      ) : null,
      /* @__PURE__ */ React.createElement("div", { className: `${classPrefix2}-decimal ${classPrefix2}-decimal-${size}` }, formatDecimal(price)),
      symbol && position === "after" ? renderSymbol() : null
    );
  };
  Price.displayName = "NutPrice";
  const DataContext = React.createContext({});
  const defaultProps$c = {
    ...ComponentDefaults,
    title: "",
    description: "",
    value: 0,
    icon: null
  };
  const Step = (props) => {
    const { children, title, description, value, icon, className, ...restProps } = {
      ...defaultProps$c,
      ...props
    };
    const parent = React.useContext(DataContext);
    const dot = parent.propSteps.dot;
    const getCurrentStatus = () => {
      const index = value;
      if (index < +parent.propSteps.value) return "finish";
      return index === +parent.propSteps.value ? "process" : "wait";
    };
    const handleClickStep = () => {
      var _a, _b;
      ((_a = parent.propSteps) == null ? void 0 : _a.onStepClick) && ((_b = parent.propSteps) == null ? void 0 : _b.onStepClick(value));
    };
    const classPrefix2 = `nut-step`;
    const classes = classNames(
      classPrefix2,
      {
        [`${classPrefix2}-${getCurrentStatus()}`]: true
      },
      className
    );
    const renderIconClass = () => {
      if (icon) {
        return `${classPrefix2}-icon is-icon`;
      }
      if (!dot && !icon) {
        return `${classPrefix2}-icon is-text`;
      }
      return `${classPrefix2}-icon`;
    };
    return /* @__PURE__ */ React.createElement("div", { className: classes, ...restProps, onClick: handleClickStep }, /* @__PURE__ */ React.createElement("div", { className: "nut-step-head" }, /* @__PURE__ */ React.createElement("div", { className: "nut-step-line" }), /* @__PURE__ */ React.createElement("div", { className: renderIconClass() }, icon || !dot && /* @__PURE__ */ React.createElement("span", { className: "nut-step-inner" }, value))), (title || description) && /* @__PURE__ */ React.createElement("div", { className: "nut-step-main" }, /* @__PURE__ */ React.createElement("span", { className: "nut-step-title" }, title), description && /* @__PURE__ */ React.createElement("span", { className: "nut-step-description" }, description)));
  };
  Step.displayName = "NutStep";
  const defaultProps$b = {
    ...ComponentDefaults,
    value: 0,
    direction: "horizontal",
    dot: false
  };
  const Steps = (props) => {
    const propSteps = { ...defaultProps$b, ...props };
    const {
      children,
      value,
      direction,
      className,
      dot,
      onStepClick,
      ...restProps
    } = propSteps;
    const parentSteps = {
      propSteps
    };
    const classPrefix2 = `nut-steps`;
    const classes = classNames(
      classPrefix2,
      {
        [`${classPrefix2}-${direction}`]: true,
        [`${classPrefix2}-dot`]: !!dot
      },
      className
    );
    return /* @__PURE__ */ React.createElement(DataContext.Provider, { value: parentSteps }, /* @__PURE__ */ React.createElement("div", { className: classes, ...restProps }, children));
  };
  Steps.displayName = "NutSteps";
  function useTableSticky(columns, rtl = false) {
    const [isSticky, setIsSticky] = React.useState(false);
    const [stickyColumnStyleMap, setStickyColumnStyleMap] = React.useState({});
    const [stickyColumnClassMap, setStickyColumnClassMap] = React.useState({});
    const [stickyLeftWidth, setStickyLeftWidth] = React.useState(0);
    const [stickyRightWidth, setStickyRightWidth] = React.useState(0);
    React.useEffect(() => {
      const leftColumns = columns.filter((item) => item.fixed === "left") || [];
      const rightColumns = columns.filter((item) => item.fixed === "right") || [];
      const middleColumns = columns.filter((item) => !item.fixed) || [];
      const _columnStyleMap = {};
      const _columnClassMap = {};
      let _stickyLeftWidth = 0;
      let _stickyRightWidth = 0;
      leftColumns.forEach((curr, index) => {
        const dir = rtl ? "right" : "left";
        _columnStyleMap[curr.key] = {
          [dir]: _stickyLeftWidth || 0,
          width: curr.width || "auto"
        };
        _columnClassMap[curr.key] = {
          "nut-table-fixed-left": true,
          "nut-table-fixed-left-last": index === leftColumns.length - 1
        };
        _stickyLeftWidth += curr.width || 0;
      });
      middleColumns.forEach((curr) => {
        _columnStyleMap[curr.key] = {
          width: curr.width || "auto"
        };
      });
      for (let i2 = rightColumns.length - 1; i2 >= 0; i2--) {
        const curr = rightColumns[i2];
        const dir = rtl ? "left" : "right";
        _columnStyleMap[curr.key] = {
          [dir]: _stickyRightWidth || 0,
          width: curr.width || "auto"
        };
        _columnClassMap[curr.key] = {
          "nut-table-fixed-right": true,
          "nut-table-fixed-right-first": i2 === 0
        };
        _stickyRightWidth += curr.width || 0;
      }
      setIsSticky(leftColumns.length > 0 || rightColumns.length > 0);
      setStickyColumnStyleMap(_columnStyleMap);
      setStickyColumnClassMap(_columnClassMap);
      setStickyLeftWidth(_stickyLeftWidth);
      setStickyRightWidth(_stickyRightWidth);
    }, [columns]);
    const getStickyStyle = React.useCallback(
      (key) => {
        return stickyColumnStyleMap[key];
      },
      [stickyColumnStyleMap]
    );
    const getStickyClass = React.useCallback(
      (key) => {
        return stickyColumnClassMap[key];
      },
      [stickyColumnClassMap]
    );
    return {
      isSticky,
      stickyLeftWidth,
      stickyRightWidth,
      getStickyClass,
      getStickyStyle
    };
  }
  const defaultProps$a = {
    ...ComponentDefaults,
    columns: [],
    data: [],
    bordered: true,
    striped: false,
    noData: "",
    sorterIcon: null,
    showHeader: true
  };
  const Table = (props) => {
    const { locale } = useConfig();
    const rtl = useRtl();
    defaultProps$a.noData = locale.noData;
    const {
      children,
      className,
      style,
      columns,
      data,
      bordered,
      summary,
      striped,
      noData,
      sorterIcon,
      showHeader,
      onSort,
      ...rest
    } = {
      ...defaultProps$a,
      ...props
    };
    const sortedMapping = React.useRef({});
    const [innerValue, setValue] = usePropsValue({
      defaultValue: data,
      finalValue: []
    });
    const {
      isSticky,
      stickyLeftWidth,
      stickyRightWidth,
      getStickyClass,
      getStickyStyle
    } = useTableSticky(columns, rtl);
    React.useEffect(() => {
      setValue(data);
    }, [data]);
    const classPrefix2 = "nut-table";
    const headerClassPrefix = `${classPrefix2}-main-head-tr`;
    const bodyClassPrefix = `${classPrefix2}-main-body-tr`;
    const cls = classNames(classPrefix2, className);
    const handleSorterClick = (item) => {
      if (item.sorter && !sortedMapping.current[item.key]) {
        const copied = [...innerValue];
        if (typeof item.sorter === "function") {
          copied.sort(item.sorter);
        } else if (item.sorter === "default") {
          copied.sort();
        }
        sortedMapping.current[item.key] = true;
        setValue(copied, true);
        onSort && onSort(item, copied);
      } else {
        sortedMapping.current[item.key] = false;
        setValue(data);
      }
    };
    const cellClasses = (item) => {
      return {
        [`${headerClassPrefix}-border`]: bordered,
        [`${headerClassPrefix}-align${item.align ? item.align : ""}`]: true
      };
    };
    const getColumnItem = (value) => {
      return columns.filter((item) => item.key === value)[0];
    };
    const renderHeadCells = () => {
      return columns.map((item, index) => {
        return /* @__PURE__ */ React.createElement(
          "div",
          {
            className: classNames(
              `${headerClassPrefix}-th`,
              cellClasses(item),
              getStickyClass(item.key)
            ),
            key: item.key,
            onClick: () => handleSorterClick(item),
            style: getStickyStyle(item.key)
          },
          item.title,
          " ",
          item.sorter && (sorterIcon || /* @__PURE__ */ React.createElement(i$9, { width: "12px", height: "12px" }))
        );
      });
    };
    const sortDataItem = () => {
      return columns.map((columns2) => {
        return [columns2.key, columns2.render];
      });
    };
    const renderBodyTds = (item, rowIndex) => {
      return sortDataItem().map(([value, render2]) => {
        return /* @__PURE__ */ React.createElement(
          "div",
          {
            className: classNames(
              `${bodyClassPrefix}-td`,
              cellClasses(getColumnItem(value)),
              getStickyClass(value)
            ),
            key: value,
            style: getStickyStyle(value)
          },
          typeof item[value] === "function" || typeof render2 === "function" ? /* @__PURE__ */ React.createElement("div", null, render2 ? render2(item, rowIndex) : item[value](item)) : item[value]
        );
      });
    };
    const renderBodyTrs = () => {
      return innerValue.map((item, index) => {
        const inner = renderBodyTds(item, index);
        const { rowRender } = item;
        if (rowRender && typeof rowRender === "function") {
          return rowRender(item, index, { inner });
        }
        return /* @__PURE__ */ React.createElement("div", { className: bodyClassPrefix, key: index }, inner);
      });
    };
    return /* @__PURE__ */ React.createElement("div", { className: cls, ...rest }, /* @__PURE__ */ React.createElement(
      "div",
      {
        className: classNames(
          `${classPrefix2}-wrapper ${isSticky ? `${classPrefix2}-wrapper-sticky` : ""}`
        ),
        style
      },
      /* @__PURE__ */ React.createElement(
        "div",
        {
          className: classNames(`${classPrefix2}-main`, {
            [`${classPrefix2}-main-striped`]: striped
          })
        },
        showHeader && /* @__PURE__ */ React.createElement("div", { className: `${classPrefix2}-main-head` }, /* @__PURE__ */ React.createElement("div", { className: headerClassPrefix }, renderHeadCells())),
        /* @__PURE__ */ React.createElement("div", { className: `${classPrefix2}-main-body` }, renderBodyTrs())
      )
    ), isSticky ? /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(
      "div",
      {
        className: `${classPrefix2}-sticky-left`,
        style: { width: stickyLeftWidth }
      }
    ), /* @__PURE__ */ React.createElement(
      "div",
      {
        className: `${classPrefix2}-sticky-right`,
        style: { width: stickyRightWidth }
      }
    )) : null, (summary || innerValue.length === 0) && /* @__PURE__ */ React.createElement("div", { className: `${classPrefix2}-summary` }, summary || noData));
  };
  Table.displayName = "NutTable";
  const defaultProps$9 = {
    ...ComponentDefaults,
    type: "default",
    background: "",
    color: "",
    plain: false,
    round: false,
    mark: false,
    closeable: false,
    closeIcon: null,
    onClose: (e) => {
    },
    onClick: (e) => {
    }
  };
  const Tag = (props) => {
    const {
      className,
      style,
      background,
      plain,
      type,
      round,
      children,
      mark,
      closeable,
      closeIcon,
      color,
      onClick,
      onClose
    } = {
      ...defaultProps$9,
      ...props
    };
    const [visible, setVisible] = React.useState(true);
    const classPrefix2 = "nut-tag";
    const classes = classNames({
      [classPrefix2]: true,
      [`${classPrefix2}-${type}`]: type,
      [`${classPrefix2}-plain`]: plain,
      [`${classPrefix2}-round`]: round,
      [`${classPrefix2}-mark`]: mark,
      [`${classPrefix2}-close`]: closeable,
      [`${className}`]: className
    });
    const handleClick2 = (e) => {
      onClick && onClick(e);
    };
    const getStyle = () => {
      const style2 = {};
      if (color) {
        style2.color = color;
      } else if (background && plain) {
        style2.color = background;
      }
      if (plain) {
        style2.borderColor = background;
      } else if (background) {
        style2.background = background;
      }
      return style2;
    };
    return /* @__PURE__ */ React.createElement(React.Fragment, null, closeable ? visible && /* @__PURE__ */ React.createElement(
      "div",
      {
        className: classes,
        style: { ...style, ...getStyle() },
        onClick: (e) => handleClick2(e)
      },
      children && /* @__PURE__ */ React.createElement("span", { className: `${classPrefix2}-text` }, children),
      React.isValidElement(closeIcon) ? /* @__PURE__ */ React.createElement(
        "i",
        {
          className: `${classPrefix2}-custom-icon`,
          onClick: (e) => {
            setVisible(false);
            onClose && onClose(e);
          }
        },
        closeIcon
      ) : /* @__PURE__ */ React.createElement(
        n$5,
        {
          width: 8,
          height: 8,
          onClick: (e) => {
            setVisible(false);
            onClose && onClose(e);
          }
        }
      )
    ) : /* @__PURE__ */ React.createElement(
      "div",
      {
        className: classes,
        style: { ...style, ...getStyle() },
        onClick: (e) => handleClick2(e)
      },
      children && /* @__PURE__ */ React.createElement("span", { className: `${classPrefix2}-text` }, children)
    ));
  };
  Tag.displayName = "NutTag";
  const defaultProps$8 = {
    ...ComponentDefaults,
    visible: false,
    type: "step",
    location: "bottom",
    mask: true,
    maskWidth: "",
    maskHeight: "",
    offset: [8, 10],
    title: "",
    next: "",
    prev: "",
    complete: "",
    showPrev: true,
    closeOnOverlayClick: true
  };
  const classPrefix$2 = "nut-tour";
  const Tour = (props) => {
    const { locale } = useConfig();
    const {
      children,
      className,
      title,
      closeOnOverlayClick,
      showPrev,
      list,
      type,
      location,
      visible,
      mask,
      maskWidth,
      maskHeight,
      offset,
      next,
      prev,
      complete,
      onClose,
      onChange,
      ...rest
    } = {
      ...defaultProps$8,
      ...props
    };
    const [showTour, setShowTour] = React.useState(false);
    const [showPopup, setShowPopup] = React.useState(false);
    const [active, setActive] = React.useState(0);
    const [maskRect, setMaskRect] = React.useState({
      top: 0,
      left: 0,
      right: 0,
      bottom: 0,
      width: 0,
      height: 0
    });
    const classes = classNames(classPrefix$2, className);
    React.useEffect(() => {
      if (visible) {
        getRootPosition();
      }
      setActive(0);
      setShowTour(visible);
      setShowPopup(visible);
    }, [visible]);
    React.useEffect(() => {
      if (visible) {
        setShowPopup(true);
        getRootPosition();
      }
    }, [active]);
    const getRootPosition = () => {
      const el = document.querySelector(`#${list[active].target}`);
      const rect = getRect(el);
      setMaskRect(rect);
    };
    const maskStyle = () => {
      const { width, height, left, top } = maskRect;
      const center = [left + width / 2, top + height / 2];
      const w = Number(maskWidth || width);
      const h = Number(maskHeight || height);
      const styles = {
        width: `${w + +offset[1] * 2}px`,
        height: `${h + +offset[0] * 2}px`,
        top: `${center[1] - h / 2 - +offset[0]}px`,
        left: `${center[0] - w / 2 - +offset[1]}px`
      };
      return styles;
    };
    const maskClose = (e) => {
      setShowTour(false);
      setShowPopup(false);
      onClose && onClose(e);
    };
    const handleClickMask = (e) => {
      closeOnOverlayClick && maskClose(e);
    };
    const changeStep = (type22) => {
      if (type22 === "next") {
        setActive(active + 1);
        onChange && onChange(active + 1);
      } else {
        setActive(active - 1);
        onChange && onChange(active - 1);
      }
      setShowPopup(false);
    };
    return /* @__PURE__ */ React.createElement("div", { className: classes, ...rest }, /* @__PURE__ */ React.createElement(
      "div",
      {
        className: "nut-tour-masked",
        style: { display: showTour ? "block" : "none" },
        onClick: handleClickMask
      }
    ), list.map((item, index) => {
      return /* @__PURE__ */ React.createElement("div", { key: index, style: { height: 0 } }, index === active && /* @__PURE__ */ React.createElement(React.Fragment, null, showTour && /* @__PURE__ */ React.createElement(
        "div",
        {
          className: `${mask ? "nut-tour-mask" : "nut-tour-mask nut-tour-mask-none"}`,
          id: "nut-tour-popid",
          style: maskStyle()
        }
      ), /* @__PURE__ */ React.createElement(
        Popover,
        {
          visible: showPopup,
          location: item.location || location,
          targetId: "nut-tour-popid",
          closeOnOutsideClick: false,
          offset: item.popoverOffset || [0, 12],
          arrowOffset: item.arrowOffset || 0
        },
        /* @__PURE__ */ React.createElement(React.Fragment, null),
        /* @__PURE__ */ React.createElement(React.Fragment, null, children || /* @__PURE__ */ React.createElement(React.Fragment, null, type === "step" && /* @__PURE__ */ React.createElement("div", { className: "nut-tour-content" }, title && /* @__PURE__ */ React.createElement("div", { className: "nut-tour-content-top" }, /* @__PURE__ */ React.createElement("div", { onClick: (e) => maskClose(e) }, /* @__PURE__ */ React.createElement(n$5, { className: "nut-tour-content-top-close" }))), /* @__PURE__ */ React.createElement("div", { className: "nut-tour-content-inner" }, item.content), /* @__PURE__ */ React.createElement("div", { className: "nut-tour-content-bottom" }, /* @__PURE__ */ React.createElement("div", { className: "nut-tour-content-bottom-init" }, active + 1, "/", list.length), /* @__PURE__ */ React.createElement("div", { className: "nut-tour-content-bottom-operate" }, active !== 0 && showPrev && /* @__PURE__ */ React.createElement(
          "div",
          {
            className: "nut-tour-content-bottom-operate-btn",
            onClick: () => changeStep("prev")
          },
          prev || locale.tour.prevStepText
        ), list.length - 1 === active && /* @__PURE__ */ React.createElement(
          "div",
          {
            className: "nut-tour-content-bottom-operate-btn active",
            onClick: (e) => maskClose(e)
          },
          complete || locale.tour.completeText
        ), list.length - 1 !== active && /* @__PURE__ */ React.createElement(
          "div",
          {
            className: "nut-tour-content-bottom-operate-btn active",
            onClick: () => changeStep("next")
          },
          next || locale.tour.nextStepText
        )))), type === "tile" && /* @__PURE__ */ React.createElement("div", { className: "nut-tour-content nut-tour-content-tile" }, /* @__PURE__ */ React.createElement("div", { className: "nut-tour-content-inner" }, item.content))))
      )));
    }));
  };
  Tour.displayName = "NutTour";
  const initPositinoCache = (reaItemSize, length = 0) => {
    let index = 0;
    const positions = Array(length);
    while (index < length) {
      positions[index] = {
        index,
        height: reaItemSize,
        width: reaItemSize,
        top: index * reaItemSize,
        bottom: (index + 1) * reaItemSize,
        left: index * reaItemSize,
        right: (index + 1) * reaItemSize
      };
      index++;
    }
    return positions;
  };
  const getListTotalSize = (positions, horizontal) => {
    const index = positions.length - 1;
    let size = 0;
    if (index < 0) {
      size = 0;
    } else {
      size = horizontal ? positions[index].right : positions[index].bottom;
    }
    return size;
  };
  const binarySearch = (positionsList, horizontal, value = 0) => {
    let start2 = 0;
    let end = positionsList.length - 1;
    let tempIndex = null;
    const key = horizontal ? "right" : "bottom";
    while (start2 <= end) {
      const midIndex = Math.floor((start2 + end) / 2);
      const midValue = positionsList[midIndex][key];
      if (midValue === value) {
        return midIndex + 1;
      }
      if (midValue < value) {
        start2 = midIndex + 1;
      } else if (midValue > value) {
        if (tempIndex === null || tempIndex > midIndex) {
          tempIndex = midIndex;
        }
        end = midIndex - 1;
      }
    }
    tempIndex = tempIndex || 0;
    return tempIndex;
  };
  const getEndIndex = ({
    list,
    startIndex,
    visibleCount,
    itemEqual = true,
    positions,
    offSetSize,
    overscan,
    sizeKey = "width"
  }) => {
    const dataLength = list.length;
    let tempIndex = null;
    if (itemEqual) {
      const endIndex = startIndex + visibleCount;
      tempIndex = dataLength > 0 ? Math.min(dataLength, endIndex) : endIndex;
    } else {
      let sizeNum = 0;
      for (let i2 = startIndex; i2 < dataLength; i2++) {
        sizeNum += positions[i2][sizeKey] || 0;
        if (sizeNum > offSetSize) {
          const endIndex = i2 + overscan;
          tempIndex = dataLength > 0 ? Math.min(dataLength, endIndex) : endIndex;
          break;
        }
      }
      if (sizeNum < offSetSize) {
        tempIndex = dataLength;
      }
    }
    tempIndex = tempIndex || 0;
    return tempIndex;
  };
  const updateItemSize = (positions, items, sizeKey, margin) => {
    const newPos = positions.concat();
    Array.from(items).forEach((item) => {
      const index = Number(item.getAttribute("data-index"));
      const styleVal = item.getAttribute("style");
      if (styleVal && styleVal.includes("none")) return;
      let nowSize = item.getBoundingClientRect()[sizeKey];
      const oldSize = positions[index][sizeKey];
      const dValue = oldSize - nowSize;
      if (dValue) {
        if (sizeKey === "width") {
          newPos[index].right -= dValue;
          newPos[index][sizeKey] = nowSize;
          for (let k = index + 1; k < positions.length; k++) {
            newPos[k].left = positions[k - 1].right;
            newPos[k].right -= dValue;
          }
        } else if (sizeKey === "height") {
          newPos[index].bottom -= dValue;
          newPos[index][sizeKey] = nowSize;
          for (let k = index + 1; k < positions.length; k++) {
            newPos[k].top = positions[k - 1].bottom;
            newPos[k].bottom -= dValue;
          }
        }
      }
    });
  };
  const defaultProps$7 = {
    ...ComponentDefaults,
    list: [],
    itemHeight: 66,
    itemEqual: true,
    direction: "vertical",
    overscan: 2
  };
  const VirtualList = (props) => {
    const {
      list,
      itemRender,
      itemEqual,
      itemHeight,
      direction,
      overscan,
      key,
      onScroll,
      className,
      containerHeight,
      ...rest
    } = {
      ...defaultProps$7,
      ...props
    };
    const horizontal = direction === "horizontal";
    const sizeKey = horizontal ? "width" : "height";
    const scrollKey = horizontal ? "scrollLeft" : "scrollTop";
    const offsetKey = horizontal ? "left" : "top";
    const scrollRef = React.useRef(null);
    const itemsRef = React.useRef(null);
    const [positions, setPositions] = React.useState([
      {
        index: 0,
        left: 0,
        top: 0,
        bottom: 0,
        width: 0,
        height: 0,
        right: 0
      }
    ]);
    const [listTotalSize, setListTotalSize] = React.useState(99999999);
    const [visibleCount, setVisibleCount] = React.useState(0);
    const [offSetSize, setOffSetSize] = React.useState(containerHeight || 0);
    const [options2, setOptions] = React.useState({
      startOffset: 0,
      // 可视区域距离顶部的偏移量
      startIndex: 0,
      // 可视区域开始索引
      overStart: 0,
      endIndex: 10
      // 可视区域结束索引
    });
    React.useEffect(() => {
      const pos = initPositinoCache(itemHeight, list.length);
      setPositions(pos);
      const totalSize = getListTotalSize(pos, horizontal);
      setListTotalSize(totalSize);
    }, [list, itemHeight, horizontal]);
    const getElement = React.useCallback(() => {
      var _a;
      return ((_a = scrollRef.current) == null ? void 0 : _a.parentElement) || document.body;
    }, []);
    React.useEffect(() => {
      if (containerHeight) return;
      const size = horizontal ? getElement().offsetWidth : getElement().offsetHeight;
      setOffSetSize(size);
    }, [getElement, horizontal, containerHeight]);
    React.useEffect(() => {
      if (offSetSize === 0) return;
      const count = Math.ceil(offSetSize / itemHeight) + overscan;
      setVisibleCount(count);
      setOptions((options22) => {
        return { ...options22, endIndex: count };
      });
    }, [getElement, horizontal, itemHeight, overscan, offSetSize]);
    const updateTotalSize = React.useCallback(() => {
      if (!itemsRef.current) return;
      const items = itemsRef.current.children;
      if (!items.length) return;
      updateItemSize(positions, items, sizeKey);
      const totalSize = getListTotalSize(positions, horizontal);
      setListTotalSize(totalSize);
    }, [positions, sizeKey, horizontal]);
    const scroll = React.useCallback(() => {
      requestAnimationFrame((e) => {
        const scrollSize = getElement()[scrollKey];
        const startIndex = binarySearch(positions, horizontal, scrollSize);
        const overStart = startIndex - overscan > -1 ? startIndex - overscan : 0;
        if (!itemEqual) {
          updateTotalSize();
        }
        const endIndex = getEndIndex({
          list,
          startIndex,
          visibleCount,
          itemEqual,
          positions,
          offSetSize,
          sizeKey,
          overscan
        });
        const startOffset = positions[startIndex][offsetKey];
        setOptions({ startOffset, startIndex, overStart, endIndex });
        if (endIndex > list.length - 1) {
          if (onScroll) {
            onScroll();
          }
        }
      });
    }, [
      positions,
      getElement,
      list,
      visibleCount,
      itemEqual,
      updateTotalSize,
      offsetKey,
      sizeKey,
      scrollKey,
      horizontal,
      overscan,
      offSetSize
    ]);
    React.useEffect(() => {
      const element = getElement();
      element.addEventListener("scroll", scroll, false);
      return () => {
        element.removeEventListener("scroll", scroll, false);
      };
    }, [getElement, scroll]);
    return /* @__PURE__ */ React.createElement(
      "div",
      {
        className: classNames("nut-virtualList-box", className),
        ...rest,
        style: {
          [sizeKey]: containerHeight ? `${offSetSize}px` : ""
        }
      },
      /* @__PURE__ */ React.createElement(
        "div",
        {
          ref: scrollRef,
          className: classNames({
            "nut-horizontal-box": horizontal,
            "nut-vertical-box": !horizontal
          }),
          style: {
            position: "relative",
            [sizeKey]: `${listTotalSize}px`
          }
        },
        /* @__PURE__ */ React.createElement(
          "ul",
          {
            className: classNames("nut-virtuallist-items", {
              "nut-horizontal-items": horizontal,
              "nut-vertical-items": !horizontal
            }),
            ref: itemsRef,
            style: {
              transform: horizontal ? `translate3d(${options2.startOffset}px,0,0)` : `translate3d(0,${options2.startOffset}px,0)`
            }
          },
          list.slice(options2.overStart, options2.endIndex).map((data, index) => {
            const { startIndex, overStart } = options2;
            const dataIndex = overStart + index;
            const styleVal = dataIndex < startIndex ? "none" : "block";
            const keyVal = key && data[key] ? data[key] : dataIndex;
            return /* @__PURE__ */ React.createElement(
              "li",
              {
                "data-index": `${dataIndex}`,
                className: "nut-virtuallist-item",
                key: `${keyVal}`,
                style: { display: styleVal }
              },
              itemRender ? itemRender(data, dataIndex, index) : data
            );
          })
        )
      )
    );
  };
  VirtualList.displayName = "NutVirtualList";
  const defaultProps$6 = {
    ...ComponentDefaults,
    list: [],
    interval: 500,
    loop: true,
    duration: 3e3,
    rows: 3,
    gapY: 10
  };
  const classPrefix$1 = `nut-barrage`;
  const InternalBarrage = (props, ref) => {
    const {
      className,
      interval,
      loop: loop2,
      list,
      duration,
      rows,
      gapY,
      ...restProps
    } = {
      ...defaultProps$6,
      ...props
    };
    const barrageBody = React.useRef(null);
    const barrageContainer = React.useRef(null);
    const barrageCWidth = React.useRef(0);
    const timer = React.useRef(0);
    const index = React.useRef(0);
    const times = React.useRef([]);
    const historyIndex = React.useRef(-1);
    const classes = classNames(classPrefix$1, className);
    React.useImperativeHandle(ref, () => ({
      add: (word) => {
        const _index = index.current % list.length;
        if (!loop2 && index.current === list.length) {
          list.splice(list.length, 0, word);
        } else {
          list.splice(_index, 0, word);
        }
      }
    }));
    React.useEffect(() => {
      if (barrageBody.current) {
        barrageCWidth.current = barrageBody.current.offsetWidth;
      }
      setTimeout(() => {
        var _a;
        (_a = barrageBody.current) == null ? void 0 : _a.style.setProperty(
          "--move-distance",
          `-${barrageCWidth.current}px`
        );
        index.current = 0;
        run();
      }, 300);
      return () => {
        clearInterval(timer.current);
      };
    }, [list]);
    const run = () => {
      clearInterval(timer.current);
      let intervalCache = interval;
      const _index = (loop2 ? index.current % list.length : index.current) % rows;
      const result = times.current[_index] - rows * interval;
      if (result > 0) {
        intervalCache += result;
      }
      timer.current = window.setTimeout(() => {
        play();
      }, intervalCache);
    };
    const play = () => {
      if (!loop2 && index.current >= list.length) {
        return;
      }
      const _index = loop2 ? index.current % list.length : index.current;
      const el = document.createElement(`div`);
      let currentIndex = _index % rows;
      if (currentIndex <= historyIndex.current || historyIndex.current === 3 && currentIndex !== 0 || Math.abs(currentIndex - historyIndex.current) !== 1) {
        currentIndex = historyIndex.current + 1 >= rows ? 0 : historyIndex.current + 1;
      }
      historyIndex.current = currentIndex;
      el.innerHTML = list[_index];
      el.classList.add("barrage-item");
      barrageContainer.current.appendChild(el);
      const width = el.offsetWidth;
      const height = el.offsetHeight;
      el.classList.add("move");
      const elScrollDuration = Math.ceil(
        width / barrageCWidth.current * duration
      );
      times.current[currentIndex] = elScrollDuration;
      el.style.animationDuration = `${duration + elScrollDuration}ms`;
      el.style.top = `${currentIndex * (height + gapY) + 20}px`;
      el.style.width = `${width}px`;
      el.addEventListener("animationend", () => {
        barrageContainer.current.removeChild(el);
      });
      index.current++;
      run();
    };
    return /* @__PURE__ */ React.createElement("div", { className: classes, ref: barrageBody, ...restProps }, /* @__PURE__ */ React.createElement("div", { ref: barrageContainer, className: "bContainer" }));
  };
  const Barrage = React.forwardRef(
    InternalBarrage
  );
  Barrage.displayName = "NutBarrage";
  const defaultProps$5 = {
    ...ComponentDefaults,
    src: "",
    title: "",
    price: "",
    vipPrice: "",
    shopDescription: "",
    delivery: "",
    shopName: "",
    description: "",
    tag: "",
    priceTag: "",
    extra: ""
  };
  const Card = (props) => {
    const {
      className,
      style,
      src,
      title,
      price,
      vipPrice,
      shopDescription,
      delivery,
      shopName,
      tag,
      priceTag,
      description,
      extra,
      ...rest
    } = {
      ...defaultProps$5,
      ...props
    };
    const classPrefix2 = "nut-card";
    return /* @__PURE__ */ React.createElement("div", { className: classNames(classPrefix2, className), style, ...rest }, /* @__PURE__ */ React.createElement("div", { className: `${classPrefix2}-left` }, /* @__PURE__ */ React.createElement("img", { src, alt: "" })), /* @__PURE__ */ React.createElement("div", { className: `${classPrefix2}-right` }, /* @__PURE__ */ React.createElement("div", { className: `${classPrefix2}-right-title` }, title), description, /* @__PURE__ */ React.createElement("div", { className: `${classPrefix2}-right-price` }, price && /* @__PURE__ */ React.createElement(Price, { size: "normal", price }), priceTag || vipPrice && /* @__PURE__ */ React.createElement(
      Price,
      {
        size: "normal",
        className: `${classPrefix2}-right-price-origin`,
        price: vipPrice
      }
    )), /* @__PURE__ */ React.createElement("div", { className: `${classPrefix2}-right-other` }, tag || /* @__PURE__ */ React.createElement(React.Fragment, null, shopDescription && /* @__PURE__ */ React.createElement(Tag, { type: "danger" }, shopDescription), delivery && /* @__PURE__ */ React.createElement(Tag, { plain: true }, delivery))), /* @__PURE__ */ React.createElement("div", { className: `${classPrefix2}-right-shop` }, shopName && /* @__PURE__ */ React.createElement("div", { className: `${classPrefix2}-right-shop-name` }, shopName), extra)));
  };
  Card.displayName = "NutCard";
  const defaultProps$4 = {
    ...ComponentDefaults,
    activeDate: "",
    activeTime: [],
    options: [],
    optionKey: {
      valueKey: "value",
      textKey: "text",
      childrenKey: "children"
    },
    onSelect: () => {
    }
  };
  const TimeDetail = (props) => {
    const { options: options2, optionKey, className, activeDate, activeTime, onSelect } = {
      ...defaultProps$4,
      ...props
    };
    const classPrefix2 = "nut-timedetail";
    const timeList = React.useMemo(() => {
      return (options2 == null ? void 0 : options2.find(
        (item) => item[optionKey.valueKey] === activeDate
      )) || {
        [optionKey.childrenKey]: []
      };
    }, [options2, optionKey, activeDate]);
    const isActive = React.useCallback(
      (timeKey) => {
        const date = activeTime.find((item) => {
          return item[optionKey.valueKey] === activeDate;
        });
        if (date == null ? void 0 : date[optionKey.childrenKey]) {
          const time = date == null ? void 0 : date[optionKey.childrenKey].find((time2) => {
            return time2[optionKey.valueKey] === timeKey;
          });
          return time;
        }
        return false;
      },
      [activeTime, optionKey, activeDate]
    );
    return /* @__PURE__ */ React.createElement("div", { className: classNames(classPrefix2, className) }, timeList[optionKey.childrenKey].map((item) => /* @__PURE__ */ React.createElement(
      "span",
      {
        className: classNames(`${classPrefix2}-item`, {
          active: isActive(item[optionKey.valueKey])
        }),
        key: item[optionKey.valueKey],
        onClick: () => onSelect(item)
      },
      item[optionKey.textKey]
    )));
  };
  TimeDetail.displayName = "NutTimeDetail";
  const defaultProps$3 = {
    ...ComponentDefaults,
    visible: false,
    multiple: false,
    defaultValue: [],
    options: [],
    optionKey: {
      valueKey: "value",
      textKey: "text",
      childrenKey: "children"
    }
  };
  const TimeSelect = (props) => {
    const { locale } = useConfig();
    const {
      visible,
      className,
      style,
      title,
      defaultValue,
      options: options2,
      optionKey,
      multiple,
      onSelect,
      onDateChange,
      onTimeChange,
      ...rest
    } = {
      ...defaultProps$3,
      ...props
    };
    const [activeDate, setActiveDate] = React.useState(() => {
      if (defaultValue == null ? void 0 : defaultValue.length) {
        return defaultValue[0][optionKey.valueKey];
      }
      if (options2 == null ? void 0 : options2.length) {
        return options2[0][optionKey.valueKey];
      }
      return "";
    });
    const [activeTime, setActiveTime] = React.useState(
      () => defaultValue || []
    );
    const classPrefix2 = "nut-timeselect";
    const closeFun = () => {
      onSelect && onSelect(activeTime);
    };
    const handleSelectTime = (selectTime) => {
      let newActiveTime = [...activeTime];
      const date = newActiveTime.find((item) => {
        return item[optionKey.valueKey] === activeDate;
      });
      if (date) {
        const timeIndex = date[optionKey.childrenKey].findIndex(
          (time) => {
            return time[optionKey.valueKey] === selectTime[optionKey.valueKey];
          }
        );
        if (timeIndex > -1) {
          if (multiple) {
            date[optionKey.childrenKey].splice(timeIndex, 1);
          } else {
            newActiveTime = [];
          }
        } else if (multiple) {
          date[optionKey.childrenKey].push({ ...selectTime });
        } else {
          newActiveTime = [
            {
              [optionKey.valueKey]: activeDate,
              [optionKey.childrenKey]: [{ ...selectTime }]
            }
          ];
        }
      } else if (multiple) {
        newActiveTime.push({
          [optionKey.valueKey]: activeDate,
          [optionKey.childrenKey]: [{ ...selectTime }]
        });
      } else {
        newActiveTime = [
          {
            [optionKey.valueKey]: activeDate,
            [optionKey.childrenKey]: [{ ...selectTime }]
          }
        ];
      }
      newActiveTime = newActiveTime.filter((item) => {
        var _a;
        return ((_a = item[optionKey.childrenKey]) == null ? void 0 : _a.length) > 0;
      });
      setActiveTime(newActiveTime);
      onTimeChange && onTimeChange(selectTime, newActiveTime);
    };
    const handleChange = (date) => {
      setActiveDate(date[optionKey.valueKey]);
      onDateChange && onDateChange(date, activeTime);
    };
    return /* @__PURE__ */ React.createElement(
      Popup,
      {
        closeable: true,
        round: true,
        visible,
        position: "bottom",
        title: title || locale.timeselect.pickupTime,
        style: {
          width: "100%",
          height: "20%",
          ...style
        },
        onClose: closeFun,
        ...rest
      },
      /* @__PURE__ */ React.createElement("div", { className: classNames(classPrefix2, className) }, /* @__PURE__ */ React.createElement("div", { className: `${classPrefix2}-content` }, /* @__PURE__ */ React.createElement("div", { className: `${classPrefix2}-content-left` }, options2.map((item) => /* @__PURE__ */ React.createElement(
        "div",
        {
          key: item[optionKey.valueKey],
          className: classNames("nut-timepannel", {
            active: item[optionKey.valueKey] === activeDate
          }),
          onClick: () => handleChange(item)
        },
        item[optionKey.textKey]
      ))), /* @__PURE__ */ React.createElement(
        TimeDetail,
        {
          options: options2,
          optionKey,
          activeDate,
          activeTime,
          onSelect: handleSelectTime
        }
      )))
    );
  };
  TimeSelect.displayName = "NutTimeSelect";
  const defaultProps$2 = {
    ...ComponentDefaults,
    value: 0,
    digits: 2,
    symbol: false,
    zero: false,
    left: false,
    sync: true,
    color: "",
    riseColor: "var(--nutui-brand-6)",
    dropColor: "var(--nutui-secondary-1)",
    riseIcon: null,
    dropIcon: null
  };
  const TrendArrow = (props) => {
    const {
      value,
      digits,
      symbol,
      zero,
      left,
      sync: sync2,
      color,
      riseColor,
      dropColor,
      riseIcon,
      dropIcon,
      className,
      style,
      children,
      ...rest
    } = { ...defaultProps$2, ...props };
    const classPrefix2 = "nut-trendarrow";
    const rateTrend = React.useRef(value > 0);
    const myFixed = (num, digit = 2) => {
      if (Object.is(parseFloat(num), NaN)) {
        return console.warn(`传入的值：${num}不是一个数字`);
      }
      num = parseFloat(num);
      const numPow = 10 ** digit;
      return (Math.round((num + Number.EPSILON) * numPow) / numPow).toFixed(digit);
    };
    const calcStyle = (() => {
      const arrowColor = rateTrend.current ? riseColor : dropColor;
      const textEquArrowColor = sync2 ? arrowColor : color;
      const style2 = {
        color: value === 0 ? color : textEquArrowColor
      };
      return style2;
    })();
    const calcRate = (() => {
      rateTrend.current = value > 0;
      const absRate = Math.abs(value);
      if (!zero && value === 0) {
        return "--";
      }
      const resultRate = `${// eslint-disable-next-line no-nested-ternary
      symbol && value !== 0 ? rateTrend.current ? "+" : "-" : ""}${myFixed(Number(absRate), digits)}%`;
      return resultRate;
    })();
    const calcIconProps = (() => {
      const iconProps = {
        color: rateTrend.current ? riseColor : dropColor
      };
      return iconProps;
    })();
    const renderContent = (left2) => {
      const classNameSuffix = !left2 ? "icon-after" : "icon-before";
      return /* @__PURE__ */ React.createElement(
        "span",
        {
          className: `${classPrefix2}-${classNameSuffix} ${classPrefix2}-value`,
          style: calcStyle
        },
        calcRate
      );
    };
    return /* @__PURE__ */ React.createElement("div", { className: `${classPrefix2} ${className}`, style, ...rest }, !left && renderContent(!left), Number(value) !== 0 && /* @__PURE__ */ React.createElement(React.Fragment, null, rateTrend.current ? /* @__PURE__ */ React.createElement(React.Fragment, null, riseIcon || /* @__PURE__ */ React.createElement(p, { color: calcIconProps.color })) : /* @__PURE__ */ React.createElement(React.Fragment, null, dropIcon || /* @__PURE__ */ React.createElement(s, { color: calcIconProps.color }))), left && renderContent(!left));
  };
  TrendArrow.displayName = "NutTrendArrow";
  const defaultProps$1 = {
    ...ComponentDefaults,
    content: "",
    fullPage: true,
    zIndex: 2e3,
    gapX: 24,
    gapY: 48,
    width: 120,
    height: 64,
    startX: 0,
    startY: 0,
    image: "",
    imageWidth: 120,
    imageHeight: 64,
    rotate: -22,
    color: "rgba(0,0,0,.15)",
    fontStyle: "normal",
    fontWeight: "normal",
    fontSize: 14
  };
  const WaterMark = (props) => {
    const { locale } = useConfig();
    const {
      content,
      fullPage,
      zIndex,
      className,
      gapX,
      gapY,
      startX,
      startY,
      width,
      height,
      image,
      imageWidth,
      imageHeight,
      rotate,
      color,
      fontStyle,
      fontFamily,
      fontWeight,
      fontSize,
      style
    } = {
      ...defaultProps$1,
      ...props
    };
    const [base64Url, setBase64Url] = React.useState("");
    const classPrefix2 = "nut-watermark";
    const classes = classNames(classPrefix2, {
      [`${classPrefix2}-full-page`]: fullPage
    });
    const cls = classNames(classes, className);
    React.useEffect(() => {
      init();
    }, []);
    const init = () => {
      const canvas = document.createElement("canvas");
      const ratio = window.devicePixelRatio;
      const ctx2 = canvas.getContext("2d");
      const canvasWidth = `${(gapX + width) * ratio}px`;
      const canvasHeight = `${(gapY + height) * ratio}px`;
      const markWidth = width * ratio;
      const markHeight = height * ratio;
      canvas.setAttribute("width", canvasWidth);
      canvas.setAttribute("height", canvasHeight);
      if (ctx2) {
        if (image) {
          ctx2.translate(markWidth / 2, markHeight / 2);
          ctx2.rotate(Math.PI / 180 * Number(rotate));
          const img = new Image();
          img.crossOrigin = "anonymous";
          img.referrerPolicy = "no-referrer";
          img.src = image;
          img.onload = () => {
            ctx2.drawImage(
              img,
              -imageWidth * ratio / 2,
              -imageHeight * ratio / 2,
              imageWidth * ratio,
              imageHeight * ratio
            );
            ctx2.restore();
            setBase64Url(canvas.toDataURL());
          };
        } else if (content) {
          ctx2.textBaseline = "middle";
          ctx2.textAlign = "center";
          ctx2.translate(markWidth / 2, markHeight / 2);
          ctx2.rotate(Math.PI / 180 * Number(rotate));
          const markSize = Number(fontSize) * ratio;
          ctx2.font = `${fontStyle} normal ${fontWeight} ${markSize}px/${markHeight}px ${fontFamily}`;
          ctx2.fillStyle = color;
          ctx2.fillText(content, startX, startY);
          ctx2.restore();
          setBase64Url(canvas.toDataURL());
        }
      } else {
        throw new Error(locale.watermark.errorCanvasTips);
      }
    };
    return /* @__PURE__ */ React.createElement(
      "div",
      {
        className: cls,
        style: {
          zIndex,
          backgroundSize: `${gapX + width}px`,
          backgroundImage: `url('${base64Url}')`,
          ...style
        }
      }
    );
  };
  WaterMark.displayName = "NutWaterMark";
  const defaultProps = {
    ...ComponentDefaults,
    maxZoom: 3,
    space: 10,
    toolbar: [
      /* @__PURE__ */ React.createElement(Button, { type: "danger", key: "cancel" }, "Cancel"),
      /* @__PURE__ */ React.createElement(Button, { key: "reset" }, "Reset"),
      /* @__PURE__ */ React.createElement(Button, { key: "rotate" }, "Rotate"),
      /* @__PURE__ */ React.createElement(Button, { type: "success", key: "confirm" }, "Confirm")
    ],
    toolbarPosition: "bottom",
    editText: "Edit",
    shape: "square"
  };
  const classPrefix = `nut-avatar-cropper`;
  const AvatarCropper = (props) => {
    const { locale } = useConfig();
    defaultProps.toolbar = [
      /* @__PURE__ */ React.createElement(Button, { type: "danger", key: "cancel" }, locale.cancel),
      /* @__PURE__ */ React.createElement(Button, { key: "reset" }, locale.reset),
      /* @__PURE__ */ React.createElement(Button, { key: "rotate" }, locale.avatarCropper.rotate),
      /* @__PURE__ */ React.createElement(Button, { type: "success", key: "confirm" }, locale.confirm)
    ];
    defaultProps.editText = locale.edit;
    const {
      children,
      maxZoom,
      space,
      toolbar,
      toolbarPosition,
      editText,
      shape,
      className,
      style,
      onConfirm,
      onCancel,
      ...rest
    } = {
      ...defaultProps,
      ...props
    };
    const cls = classNames(classPrefix, className, shape === "round" && "round");
    const toolbarPositionCls = classNames(
      `${classPrefix}-popup-toolbar`,
      toolbarPosition
    );
    const inputImageRef = React.useRef(null);
    const cropperPopupRef = React.useRef(null);
    const canvasRef = React.useRef(null);
    const [visible, setVisible] = React.useState(false);
    const [moving, setMoving] = React.useState(false);
    const [zooming, setZooming] = React.useState(false);
    const [state, setState] = React.useState({
      defScale: 1,
      scale: 1,
      angle: 0,
      moveX: 0,
      moveY: 0,
      displayWidth: 0,
      displayHeight: 0
    });
    const defDrawImage = {
      img: new Image(),
      // 规定要使用的图像
      sx: 0,
      // 开始剪切的 x 坐标位置
      sy: 0,
      // 开始剪切的 y 坐标位置
      swidth: 0,
      // 被剪切区域的宽度
      sheight: 0,
      // 被剪切区域的高度
      x: 0,
      // 在画布上x的坐标位置
      y: 0,
      // 在画布上y的坐标位置
      width: 0,
      // 要使用的图像的宽度
      height: 0
      // 要使用的图像的高度
    };
    const [drawImage, setDrawImg] = React.useState({ ...defDrawImage });
    const devicePixelRatio = window.devicePixelRatio || 1;
    const touch = useTouch();
    const highlightStyle = React.useMemo(() => {
      const width = `${drawImage.swidth / devicePixelRatio}px`;
      const height = width;
      return {
        width,
        height,
        borderRadius: shape === "round" ? "50%" : ""
      };
    }, [devicePixelRatio, drawImage.swidth]);
    const isAngle = React.useMemo(() => {
      return state.angle === 90 || state.angle === 270;
    }, [state.angle]);
    const maxMoveX = React.useMemo(() => {
      const { swidth, height } = drawImage;
      if (isAngle) {
        return Math.max(0, (height * state.scale - swidth) / 2);
      }
      return Math.max(0, (state.displayWidth * state.scale - swidth) / 2);
    }, [state.scale, state.displayWidth, drawImage, isAngle]);
    const maxMoveY = React.useMemo(() => {
      const { swidth, height } = drawImage;
      if (isAngle) {
        return Math.max(0, (state.displayWidth * state.scale - swidth) / 2);
      }
      return Math.max(0, (height * state.scale - swidth) / 2);
    }, [state.scale, state.displayWidth, drawImage, isAngle]);
    const fileToDataURL = (file) => {
      return new Promise((resolve) => {
        const reader = new FileReader();
        reader.onloadend = (e) => resolve(e.target.result);
        reader.readAsDataURL(file);
      });
    };
    const dataURLToImage = (dataURL) => {
      return new Promise((resolve) => {
        const img = new Image();
        img.onload = () => resolve(img);
        img.src = dataURL;
      });
    };
    const draw = React.useCallback(() => {
      const { img, width, height, x, y, swidth } = drawImage;
      const { moveX, moveY, scale, angle, displayWidth, displayHeight } = state;
      const canvas = canvasRef.current;
      if (!canvas) return;
      const ctx2 = canvas.getContext("2d");
      canvas.width = displayWidth;
      canvas.height = displayHeight;
      ctx2.clearRect(0, 0, canvas.width, canvas.height);
      ctx2.fillStyle = "#666";
      ctx2.fillRect(0, 0, canvas.width, canvas.height);
      ctx2.fillStyle = "#000";
      ctx2.fillRect(
        space * devicePixelRatio,
        (canvas.height - swidth) / 2,
        swidth,
        swidth
      );
      ctx2.translate(canvas.width / 2 + moveX, canvas.height / 2 + moveY);
      ctx2.rotate(Math.PI / 180 * angle);
      ctx2.scale(scale, scale);
      ctx2.drawImage(img, x, y, width, height);
    }, [drawImage, state, devicePixelRatio, space]);
    React.useEffect(() => {
      if (Math.abs(state.moveX) > maxMoveX) {
        setState({ ...state, moveX: maxMoveX });
      }
      if (Math.abs(state.moveY) > maxMoveY) {
        setState({ ...state, moveY: maxMoveY });
      }
      draw();
    }, [state, maxMoveX, maxMoveY, draw]);
    const setDrawImgs = (image) => {
      const rect = getRect(cropperPopupRef.current);
      if (!rect) return;
      const { width: clientWidth, height: clientHeight } = rect;
      const canvasWidth = state.displayWidth = clientWidth * devicePixelRatio;
      const canvasHeight = state.displayHeight = clientHeight * devicePixelRatio;
      const copyDrawImg = { ...defDrawImage };
      const { width: imgWidth, height: imgHeight } = image;
      copyDrawImg.img = image;
      const isPortrait = imgHeight > imgWidth;
      const rate = isPortrait ? imgWidth / imgHeight : imgHeight / imgWidth;
      copyDrawImg.width = canvasWidth;
      copyDrawImg.height = isPortrait ? canvasWidth / rate : canvasWidth * rate;
      copyDrawImg.x = -copyDrawImg.width / 2;
      copyDrawImg.y = -copyDrawImg.height / 2;
      copyDrawImg.swidth = canvasWidth - space * 2 * devicePixelRatio;
      copyDrawImg.sheight = isPortrait ? copyDrawImg.swidth / rate : copyDrawImg.swidth * rate;
      copyDrawImg.sx = space * devicePixelRatio;
      copyDrawImg.sy = (canvasHeight - copyDrawImg.swidth) / 2;
      setDrawImg(copyDrawImg);
      const scale = copyDrawImg.swidth / (isPortrait ? copyDrawImg.width : copyDrawImg.height);
      setState({ ...state, defScale: scale });
      resetScale(scale);
    };
    const inputImageChange = async (event) => {
      setVisible(true);
      const $el = event.target;
      const { files } = $el;
      if (!(files == null ? void 0 : files.length)) return;
      const base64 = await fileToDataURL(files[0]);
      const image = await dataURLToImage(base64);
      setDrawImgs(image);
    };
    const resetScale = (scale) => {
      setState({
        ...state,
        moveX: 0,
        moveY: 0,
        angle: 0,
        scale: scale || state.defScale,
        defScale: scale || state.defScale
      });
    };
    const setScale = (scale) => {
      scale = clamp(scale, 0.3, +maxZoom + 1);
      if (scale !== state.scale) {
        setState({ ...state, scale });
      }
    };
    const getDistance = (touches) => Math.sqrt(
      (touches[0].clientX - touches[1].clientX) ** 2 + (touches[0].clientY - touches[1].clientY) ** 2
    );
    const [startMove, setStartMove] = React.useState({
      startMoveX: 0,
      startMoveY: 0,
      startScale: 0,
      startDistance: 0
    });
    const { startMoveX, startMoveY, startScale, startDistance } = startMove;
    const onTouchStart = (event) => {
      const { touches } = event;
      const { offsetX } = touch;
      touch.start(event);
      const fingerNum = touches == null ? void 0 : touches.length;
      setStartMove({
        ...startMove,
        startMoveX: state.moveX,
        startMoveY: state.moveY
      });
      setMoving(fingerNum === 1);
      setZooming(fingerNum === 2 && !offsetX.current);
      if (fingerNum === 2 && !offsetX.current) {
        setStartMove({
          ...startMove,
          startScale: state.scale,
          startDistance: getDistance(event.touches)
        });
      }
    };
    const onTouchMove = (event) => {
      const { touches } = event;
      touch.move(event);
      if (moving || zooming) {
        preventDefault$1(event, true);
      }
      if (moving) {
        const { deltaX, deltaY } = touch;
        const moveX = deltaX.current * state.scale + startMoveX;
        const moveY = deltaY.current * state.scale + startMoveY;
        setState({
          ...state,
          moveX: clamp(moveX, -maxMoveX, maxMoveX),
          moveY: clamp(moveY, -maxMoveY, maxMoveY)
        });
      }
      if (zooming && touches.length === 2) {
        const distance = getDistance(touches);
        const scale = startScale * distance / startDistance;
        setScale(scale);
      }
    };
    const onTouchEnd = (event) => {
      let stopPropagation = false;
      if (moving || zooming) {
        stopPropagation = !(moving && startMoveX === state.moveX && startMoveY === state.moveY);
        if (!event.touches.length) {
          if (zooming) {
            setState({
              ...state,
              moveX: clamp(state.moveX, -maxMoveX, maxMoveX),
              moveY: clamp(state.moveY, -maxMoveY, maxMoveY)
            });
            setZooming(false);
          }
          setMoving(false);
          setStartMove({
            ...startMove,
            startMoveX: 0,
            startMoveY: 0,
            startScale: state.defScale
          });
          if (state.scale < state.defScale) {
            resetScale();
          }
          if (state.scale > maxZoom) {
            setState({ ...state, scale: +maxZoom });
          }
        }
      }
      preventDefault$1(event, stopPropagation);
      touch.reset();
    };
    const reset = () => {
      setState({ ...state, angle: 0 });
    };
    const rotate = () => {
      if (state.angle === 270) {
        setState({ ...state, angle: 0 });
        return;
      }
      setState({ ...state, angle: state.angle + 90 });
    };
    const cancel = (isEmit = true) => {
      setVisible(false);
      resetScale();
      inputImageRef.current && (inputImageRef.current.value = "");
      isEmit && onCancel && onCancel();
    };
    const confirm2 = () => {
      const canvas = canvasRef.current;
      const { sx, sy, swidth } = drawImage;
      const width = swidth;
      const height = swidth;
      const croppedCanvas = document.createElement("canvas");
      const croppedCtx = croppedCanvas.getContext(
        "2d"
      );
      croppedCanvas.width = width;
      croppedCanvas.height = height;
      canvas && croppedCtx.drawImage(canvas, sx, sy, width, height, 0, 0, width, height);
      const imageDataURL = croppedCanvas.toDataURL("image/png");
      onConfirm && onConfirm(imageDataURL);
      cancel(false);
    };
    const ToolBar = () => {
      const actions = [cancel, reset, rotate, confirm2];
      return /* @__PURE__ */ React.createElement("div", { className: `${classPrefix}-popup-toolbar-flex` }, actions.map((action, index) => /* @__PURE__ */ React.createElement(
        "div",
        {
          key: index,
          className: `${classPrefix}-popup-toolbar-item`,
          onClick: (_e) => action()
        },
        toolbar[index]
      )));
    };
    const CropperPopup = () => {
      return /* @__PURE__ */ React.createElement(
        "div",
        {
          ref: cropperPopupRef,
          className: `${classPrefix}-popup`,
          style: { display: visible ? "block" : "none" }
        },
        /* @__PURE__ */ React.createElement("canvas", { ref: canvasRef, className: `${classPrefix}-popup-canvas` }),
        /* @__PURE__ */ React.createElement(
          "div",
          {
            className: `${classPrefix}-popup-highlight`,
            onTouchStart,
            onTouchMove,
            onTouchEnd
          },
          /* @__PURE__ */ React.createElement("div", { className: "highlight", style: highlightStyle })
        ),
        /* @__PURE__ */ React.createElement("div", { className: toolbarPositionCls }, /* @__PURE__ */ React.createElement(ToolBar, null))
      );
    };
    return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement("div", { className: cls, ...rest, style }, children, /* @__PURE__ */ React.createElement(
      "input",
      {
        ref: inputImageRef,
        type: "file",
        accept: "image/*",
        className: `${classPrefix}-input`,
        onChange: (e) => inputImageChange(e),
        "aria-label": locale.avatarCropper.selectImage
      }
    ), /* @__PURE__ */ React.createElement("div", { className: "nut-avatar-cropper-edit-text" }, editText)), CropperPopup());
  };
  AvatarCropper.displayName = "NutAvatarCropper";
  exports2.ActionSheet = ActionSheet;
  exports2.Address = Address;
  exports2.Animate = Animate;
  exports2.AnimatingNumbers = AnimatingNumbers;
  exports2.Audio = Audio;
  exports2.Avatar = Avatar;
  exports2.AvatarCropper = AvatarCropper;
  exports2.AvatarGroup = AvatarGroup;
  exports2.BackTop = BackTop;
  exports2.Badge = Badge;
  exports2.Barrage = Barrage;
  exports2.Button = Button;
  exports2.Calendar = Calendar;
  exports2.CalendarCard = CalendarCard;
  exports2.CalendarItem = CalendarItem;
  exports2.Card = Card;
  exports2.Cascader = Cascader;
  exports2.Cell = Cell;
  exports2.CellGroup = CellGroup;
  exports2.Checkbox = Checkbox;
  exports2.CheckboxGroup = CheckboxGroup;
  exports2.CircleProgress = CircleProgress;
  exports2.Col = Col;
  exports2.Collapse = Collapse;
  exports2.CollapseItem = CollapseItem;
  exports2.ConfigProvider = ConfigProvider;
  exports2.CountDown = CountDown;
  exports2.DatePicker = DatePicker;
  exports2.Dialog = Dialog;
  exports2.Divider = Divider;
  exports2.Drag = Drag;
  exports2.Elevator = Elevator;
  exports2.Ellipsis = Ellipsis;
  exports2.Empty = Empty;
  exports2.FixedNav = FixedNav;
  exports2.Form = InnerForm;
  exports2.FormItem = FormItem;
  exports2.Grid = Grid;
  exports2.GridItem = GridItem;
  exports2.Image = Image$1;
  exports2.ImagePreview = ImagePreview;
  exports2.Indicator = Indicator;
  exports2.InfiniteLoading = InfiniteLoading;
  exports2.Input = Input;
  exports2.InputNumber = InputNumber;
  exports2.Layout = Layout;
  exports2.Loading = Loading;
  exports2.Menu = Menu;
  exports2.MenuItem = MenuItem;
  exports2.NavBar = NavBar;
  exports2.NoticeBar = NoticeBar;
  exports2.Notify = Notify;
  exports2.NumberKeyboard = NumberKeyboard;
  exports2.Overlay = Overlay;
  exports2.Pagination = Pagination;
  exports2.Picker = Picker;
  exports2.Popover = Popover;
  exports2.Popup = Popup;
  exports2.Price = Price;
  exports2.Progress = Progress;
  exports2.PullToRefresh = PullToRefresh;
  exports2.Radio = Radio;
  exports2.RadioGroup = RadioGroup;
  exports2.Range = Range;
  exports2.Rate = Rate;
  exports2.Row = Row;
  exports2.SafeArea = SafeArea;
  exports2.SearchBar = SearchBar;
  exports2.ShortPassword = ShortPassword;
  exports2.SideNavBar = SideNavBar;
  exports2.SideNavBarItem = SideNavBarItem;
  exports2.Signature = Signature;
  exports2.Skeleton = Skeleton;
  exports2.Space = Space;
  exports2.Step = Step;
  exports2.Steps = Steps;
  exports2.Sticky = Sticky;
  exports2.SubSideNavBar = SubSideNavBar;
  exports2.Swipe = Swipe;
  exports2.Swiper = InnerSwiper;
  exports2.SwiperItem = SwiperItem;
  exports2.Switch = Switch;
  exports2.TabPane = TabPane;
  exports2.Tabbar = Tabbar;
  exports2.TabbarItem = TabbarItem;
  exports2.Table = Table;
  exports2.Tabs = Tabs;
  exports2.Tag = Tag;
  exports2.TextArea = TextArea;
  exports2.TimeDetail = TimeDetail;
  exports2.TimeSelect = TimeSelect;
  exports2.Toast = Toast;
  exports2.Tour = Tour;
  exports2.TrendArrow = TrendArrow;
  exports2.Uploader = Uploader;
  exports2.Video = Video;
  exports2.VirtualList = VirtualList;
  exports2.WaterMark = WaterMark;
  exports2.getDefaultConfig = getDefaultConfig;
  exports2.setDefaultConfig = setDefaultConfig;
  exports2.useConfig = useConfig;
  exports2.useRtl = useRtl;
  Object.defineProperty(exports2, Symbol.toStringTag, { value: "Module" });
});
